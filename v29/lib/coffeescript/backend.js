// Generated by CoffeeScript 2.8.0
const hasProp = {}.hasOwnProperty;



const Backend = class Backend {
  constructor(options1 = {}, ast = {}) {
    this.options = options1;
    this.ast = ast;
  }

  _toLocation(pos) {
    let from, till;
    if (Array.isArray(pos)) {
      from = this.pos(pos[0]);
      till = this.pos(pos[1]);
    } else if (typeof pos === 'number') {
      from = till = this.pos(pos);
    }
    if (from && till) {
      return {
        first_line: from.first_line,
        first_column: from.first_column,
        last_line_exclusive: (ref = till.last_line_exclusive) != null ? ref : till.last_line,
        last_column_exclusive: (ref1 = till.last_column_exclusive) != null ? ref1 : till.last_column + 1,
        range: [(ref2 = (ref3 = from.range) != null ? ref3[0] : void 0) != null ? ref2 : 0, (ref4 = (ref5 = till.range) != null ? ref5[1] : void 0) != null ? ref4 : 0]
      };
    }
  }

  _toValue(base, properties, tag, isDefaultValue) {
    let props = Array.isArray(properties) ? properties : [];
    if (base instanceof this.ast.Value) {
      if (props.length) {
        return base.add(props);
      } else {
        return base;
      }
    } else {
      return new this.ast.Value(base, props, tag, isDefaultValue);
    }
  }

  reduce(values, positions, stackTop, symbolCount, directive) {
    this.tok = function(pos) {
      return values[stackTop - symbolCount + pos];
    };
    this.pos = function(pos) {
      return positions[stackTop - symbolCount + pos];
    };
    if (positions && symbolCount > 0) {
      this.loc = this._toLocation([1, symbolCount]);
    }
    let o = new Proxy(directive, {
      get: (target, prop) => {
        if (prop in target) {
          return target[prop];
        }
        if (/^\d+$/.test(prop)) {
          return this.tok(parseInt(prop, 10));
        }
        if (prop[0] === '$') {
          return this.tok(parseInt(prop.slice(1), 10));
        }
        return void 0;
      }
    });
    let result = this.process(o);
    if (result instanceof this.ast.Base && !result.locationData && this.loc) {
      result.locationData = this.loc;
    }
    return result;
  }

  process(o) {
    if (o.$ast != null) {
      return this.processAst(o);
    }
    if (o.$use != null) {
      return this.processUse(o);
    }
    if (o.$ops != null) {
      return this.processOps(o);
    }
    if (o.$arr != null) {
      return this.processArr(o);
    }
    return this.$(o);
  }

  $(value) {
    if (value == null) {
      return value;
    }
    if (typeof value === 'number') {
      return this.tok(value);
    }
    let results, resolved;
    if (Array.isArray(value)) {
      results = [];
/* DEFPART_MARKER */
      for (let i = 0, len = value.length; i < len; i++) {
        let item = value[i];
        resolved = this.$(item);
        if (resolved == null) {
          continue;
        }
        if (resolved instanceof this.ast.Base) {
          results.push(resolved);
        }
      }
      return results;
    }
    let result;
    if (typeof value === 'object' && (value != null)) {
      if (value.$ast || value.$ops || value.$use || value.$arr) {
        return this.process(value);
      }
      result = {};
/* DEFPART_MARKER */
      for (let key in value) {
        if (!hasProp.call(value, key)) continue;
        let val = value[key];
        result[key] = this.$(val);
      }
      return result;
    }
    return value;
  }

  processArr(o) {
    let items = this.$(o.$arr);
    let result = Array.isArray(items) ? items : [items];
    if (o.implicit != null) {
      result.implicit = !!this.$(o.implicit);
    }
    return result;
  }

  processUse(o) {
    let target = this.$(o.$use);
    if (o.method != null) {
      return target != null ? typeof target[name1 = o.method] === "function" ? target[name1](...((ref = o.args) != null ? ref : [])) : void 0 : void 0;
    }
    if (o.prop != null) {
      return target != null ? target[o.prop] : void 0;
    }
    if (o.index != null) {
      return target != null ? target[o.index] : void 0;
    }
    return target;
  }

  processOps(o) {
    switch (o.$ops) {
      case 'array':
        let result = [];
        let resolved;
        if (o.append != null) {
          const ref = o.append;
/* DEFPART_MARKER */
          for (let i = 0, len = ref.length; i < len; i++) {
            let item = ref[i];
            resolved = this.$(item);
            if (Array.isArray(resolved)) {
              result.push(...resolved);
            } else if (resolved != null) {
              result.push(resolved);
            }
          }
        }
        return result;
      case 'if':
        if (o.addElse != null) {
          [ifNode, elseBody] = o.addElse.map((item) => {
            return this.$(item);
          });
          if (elseBody && !elseBody.locationData && this.loc) {
            elseBody.locationData = this.loc;
          }
          ifNode.addElse(elseBody);
          return ifNode;
        }
        break;
      case 'value':
        if (o.add != null) {
          [value, accessor] = o.add.map((item) => {
            return this.$(item);
          });
          if (value instanceof this.ast.Value) {
            result = value.add(accessor);
            if (result.forceUpdateLocation) {
              result.updateLocationDataIfMissing(this.loc);
            }
            return result;
          } else {
            return this._toValue(value, [accessor]);
          }
        }
        break;
      case 'loop':
        if (o.addSource != null) {
          [loopNode, sourceInfo] = o.addSource.map((item) => {
            return this.$(item);
          });
          if ((loopNode != null ? loopNode.addSource : void 0) != null) {
            loopNode.addSource(sourceInfo);
          }
          return loopNode;
        }
        if (o.addBody != null) {
          [loopNode, body] = o.addBody.map((item) => {
            return this.$(item);
          });
          loopNode.addBody(this.ast.Block.wrap(body));
          if (o.postfix != null) {
            loopNode.postfix = this.$(o.postfix);
          }
          return loopNode;
        }
        break;
      case 'prop':
        let target;
        if (o.set != null) {
          target = this.$(o.set.target);
          value = this.$(o.set.value);
          if (target != null) {
            target[o.set.property] = value;
          }
          return target;
        }
    }
    console.warn("Missing $ops directive handler:", o);
    return new this.ast.Literal(`# Missing $ops directive handler for: ${JSON.stringify(o)}`);
  }

  processAst(o) {
    let node = (function() {
      switch (o.$ast) {
        case 'Value':
          return this._toValue(this.$(o.base), (ref = this.$(o.properties)) != null ? ref : [], o.this && 'this', (ref1 = this.$(o.isDefaultValue)) != null ? ref1 : false);
        case 'IdentifierLiteral':
          return new this.ast.IdentifierLiteral(this.$(o.value));
        case 'NumberLiteral':
          return new this.ast.NumberLiteral(this.$(o.value), {
            parsedValue: this.$(o.parsedValue)
          });
        case 'Literal':
          node = new this.ast.Literal(this.$(pos = o.value));
          if (typeof pos === 'number') {
            node.locationData = this._toLocation(pos);
          }
          return node;
        case 'StringLiteral':
          return new this.ast.StringLiteral(this.$(o.value), {
            quote: this.$(o.quote),
            initialChunk: this.$(o.initialChunk),
            finalChunk: this.$(o.finalChunk),
            indent: this.$(o.indent),
            double: this.$(o.double),
            heregex: this.$(o.heregex)
          });
        case 'Assign':
          let variable = this.$(o.variable);
          let operator = this.$(o.operator);
          let value = this.$(o.value);
          let context = this.$(o.context);
          if (context === 'object' && variable instanceof this.ast.Value && variable.base instanceof this.ast.ThisLiteral) {
            variable.this = true;
          }
          if (operator === '//=' || operator === '%%=') {
            value = new this.ast.Op(operator.slice(0, -1), variable, value);
            context = '=';
          } else if (operator && (operator !== '=' && operator !== '?=' && operator !== (void 0))) {
            context = operator;
          } else if (operator === '?=') {
            context = operator;
          }
          let options = {};
          const ref2 = ['operatorToken', 'moduleDeclaration', 'originalContext'];
/* DEFPART_MARKER */
          for (let i = 0, len = ref2.length; i < len; i++) {
            let k = ref2[i];
            if (o[k] != null) {
              options[k] = this.$(o[k]);
            }
          }
          return new this.ast.Assign(variable, value, context, options);
        case 'Call':
          return new this.ast.Call(this.$(o.variable), this.$(o.args) || [], this.$(o.soak));
        case 'Op':
          let args = ((ref3 = o.args) != null ? ref3.map((arg) => {
            return this.$(arg);
          }) : void 0) || [];
          if ((o.invertOperator != null) || (o.originalOperator != null)) {
            options = {};
            if (o.invertOperator != null) {
              options.invertOperator = this.$(o.invertOperator);
            }
            if (o.originalOperator != null) {
              options.originalOperator = this.$(o.originalOperator);
            }
            args.push(options);
          }
          return new this.ast.Op(...args);
        case 'Access':
          let name = this.$(o.name);
          if (name instanceof this.ast.IdentifierLiteral) {
            name = new this.ast.PropertyName(name.value);
          }
          return new this.ast.Access(name, {
            soak: this.$(o.soak),
            shorthand: this.$(o.shorthand)
          });
        case 'Index':
          return new this.ast.Index(this.$(o.index));
        case 'PropertyName':
          return new this.ast.PropertyName(this.$(o.value));
        case 'Block':
          let expressions = this.$(o.expressions);
          return new this.ast.Block((expressions instanceof this.ast.Block ? expressions.expressions : expressions) || []);
        case 'Root':
          let body = this.ast.Block.wrap(this.$(o.body));
          if (this.options.makeReturn) {
            body.makeReturn();
          }
          return new this.ast.Root(body);
        case 'If':
          let ifNode = new this.ast.If(this.$(o.condition), this.ast.Block.wrap(this.$(o.body)), {
            type: (this.$(o.invert) ? 'unless' : this.$(o.type)),
            postfix: this.$(o.postfix)
          });
          if (o.elseBody != null) {
            ifNode.addElse(this.ast.Block.wrap(this.$(o.elseBody)));
          }
          return ifNode;
        case 'While':
          let whileNode = new this.ast.While(this.$(o.condition), {
            invert: this.$(o.invert),
            guard: this.$(o.guard),
            isLoop: this.$(o.isLoop)
          });
          whileNode.body = this.ast.Block.wrap(this.$(o.body));
          return whileNode;
        case 'For':
          body = this.ast.Block.wrap(this.$(o.body));
          let forNode = new this.ast.For(body, {
            name: this.$(o.name),
            index: this.$(o.index),
            source: this.$(o.source)
          });
          const ref4 = ['await', 'awaitTag', 'own', 'ownTag', 'step', 'from', 'object', 'guard'];
/* DEFPART_MARKER */
          for (let j = 0, len1 = ref4.length; j < len1; j++) {
            let k = ref4[j];
            if (o[k] != null) {
              forNode[k] = this.$(o[k]);
            }
          }
          return forNode;
        case 'Return':
          return new this.ast.Return(this.$(o.expression));
        case 'Code':
          return new this.ast.Code(this.$(o.params) || [], this.ast.Block.wrap(this.$(o.body)), this.$(o.funcGlyph), this.$(o.paramStart));
        case 'FuncGlyph':
          return new this.ast.FuncGlyph(this.$(o.glyph) || this.$(o.value) || '->');
        case 'Class':
          return new this.ast.Class(this.$(o.variable), this.$(o.parent), this.$(o.body));
        case 'Param':
          name = this.$(o.name);
          if (name instanceof this.ast.Value && name.base instanceof this.ast.ThisLiteral) {
            name.this = true;
          }
          return new this.ast.Param(name, this.$(o.value), this.$(o.splat));
        case 'Obj':
          return new this.ast.Obj(this.$(o.properties) || [], this.$(o.generated));
        case 'Arr':
          return new this.ast.Arr(this.$(o.objects) || []);
        case 'Range':
          return new this.ast.Range(this.$(o.from), this.$(o.to), this.$(o.exclusive) ? 'exclusive' : void 0);
        case 'Slice':
          return new this.ast.Slice(this.$(o.range));
        case 'Expansion':
          return new this.ast.Expansion();
        case 'BooleanLiteral':
          return new this.ast.BooleanLiteral(this.$(o.value), {
            originalValue: this.$(o.originalValue)
          });
        case 'ThisLiteral':
          return new this.ast.ThisLiteral(this.$(o.value));
        case 'NullLiteral':
          return new this.ast.NullLiteral();
        case 'UndefinedLiteral':
          return new this.ast.UndefinedLiteral();
        case 'RegexLiteral':
          return new this.ast.RegexLiteral(this.$(o.value), {
            delimiter: this.$(o.delimiter),
            heregexCommentTokens: this.$(o.heregexCommentTokens)
          });
        case 'PassthroughLiteral':
          return new this.ast.PassthroughLiteral(this.$(o.value), {
            here: this.$(o.here),
            generated: this.$(o.generated)
          });
        case 'StatementLiteral':
          return new this.ast.StatementLiteral(this.$(o.value));
        case 'ComputedPropertyName':
          return new this.ast.ComputedPropertyName(this.$(o.value));
        case 'StringWithInterpolations':
          return new this.ast.StringWithInterpolations(this.ast.Block.wrap(this.$(o.body)), {
            quote: this.$(o.quote),
            startQuote: this.$(o.startQuote)
          });
        case 'Interpolation':
          let expression = this.$(o.expression);
          if (expression != null) {
            return new this.ast.Interpolation(expression);
          } else {
            return new this.ast.EmptyInterpolation();
          }
          break;
        case 'Switch':
          return new this.ast.Switch(this.$(o.subject), this.$(o.cases) || [], this.$(o.otherwise));
        case 'SwitchWhen':
          return new this.ast.SwitchWhen([].concat(this.$(o.conditions)), this.$(o.body));
        case 'Super':
          return new this.ast.Super(this.$(o.accessor), this.$(o.superLiteral));
        case 'SuperCall':
          return new this.ast.SuperCall(this.$(o.variable), this.$(o.args) || [], this.$(o.soak));
        case 'Existence':
          return new this.ast.Existence(this.$(o.expression));
        case 'Parens':
          return new this.ast.Parens(this.$(o.body));
        case 'Splat':
          return new this.ast.Splat(this.$(o.name), {
            postfix: this.$(o.postfix)
          });
        case 'Try':
          return new this.ast.Try(this.$(o.attempt), this.$(o.catch), this.$(o.ensure), this.$(o.finallyTag));
        case 'Catch':
          return new this.ast.Catch(this.$(o.recovery), this.$(o.variable) || this.$(o.errorVariable));
        case 'Throw':
          return new this.ast.Throw(this.$(o.expression));
        case 'ImportDeclaration':
          return new this.ast.ImportDeclaration(this.$(o.clause), this.$(o.source));
        case 'ImportClause':
          return new this.ast.ImportClause(this.$(o.defaultBinding), this.$(o.namedImports));
        case 'ImportSpecifierList':
          return new this.ast.ImportSpecifierList(this.$(o.specifiers) || []);
        case 'ImportSpecifier':
          return new this.ast.ImportSpecifier(this.$(o.imported), this.$(o.local));
        case 'ImportDefaultSpecifier':
          return new this.ast.ImportDefaultSpecifier(this.$(o.name) || this.$(o.value) || this.$(o));
        case 'ImportNamespaceSpecifier':
          return new this.ast.ImportNamespaceSpecifier(this.$(o.star), this.$(o.local));
        case 'ExportNamedDeclaration':
          return new this.ast.ExportNamedDeclaration(this.$(o.clause), this.$(o.source), this.$(o.assertions));
        case 'ExportDefaultDeclaration':
          return new this.ast.ExportDefaultDeclaration(this.$(o.declaration) || this.$(o.value));
        case 'ExportAllDeclaration':
          return new this.ast.ExportAllDeclaration(this.$(o.exported), this.$(o.source), this.$(o.assertions));
        case 'ExportSpecifierList':
          return new this.ast.ExportSpecifierList(this.$(o.specifiers) || []);
        case 'ExportSpecifier':
          return new this.ast.ExportSpecifier(this.$(o.value || o.local), this.$(o.exported));
        case 'InfinityLiteral':
          return new this.ast.InfinityLiteral('Infinity');
        case 'NaNLiteral':
          return new this.ast.NaNLiteral();
        case 'DefaultLiteral':
          return new this.ast.DefaultLiteral(this.$(o.value) || 'default');
        case 'YieldReturn':
          return new this.ast.YieldReturn(this.$(o.expression), {
            returnKeyword: this.$(o.returnKeyword)
          });
        case 'AwaitReturn':
          return new this.ast.AwaitReturn(this.$(o.expression), {
            returnKeyword: this.$(o.returnKeyword)
          });
        case 'DynamicImportCall':
          return new this.ast.DynamicImportCall(this.$(o.variable), this.$(o.args) || []);
        case 'DynamicImport':
          return new this.ast.DynamicImport();
        case 'TaggedTemplateCall':
          return new this.ast.TaggedTemplateCall(this.$(o.variable), this.$(o.template), this.$(o.soak));
        case 'MetaProperty':
          return new this.ast.MetaProperty(this.$(o.identifier), this.$(o.accessor));
        case 'RegexWithInterpolations':
          return new this.ast.RegexWithInterpolations(this.$(o.invocation), {
            heregexCommentTokens: this.$(o.heregexCommentTokens)
          });
        case 'Elision':
          return new this.ast.Elision();
        default:
          console.warn("Unknown $ast type:", o.$ast);
          return new this.ast.Literal(`# Missing AST node: ${o.$ast}`);
      }
    }).call(this);
    let loc;
    if (node instanceof this.ast.Base) {
      if (((pos = o.$loc) != null) && (loc = this._toLocation(pos))) {
        node.locationData = loc;
      } else if (!node.locationData && this.loc) {
        node.locationData = this.loc;
      }
    }
    return node;
  }

};


export default Backend;
