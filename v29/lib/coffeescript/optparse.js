// Generated by CoffeeScript 2.8.0
import { repeat } from './helpers.js';


let LONG_FLAG = /^(--\w[\w\-]*)/;

let SHORT_FLAG = /^(-\w)$/;

let MULTI_FLAG = /^-(\w{2,})/;

let OPTIONAL = /\[(\w+(\*?))\]/;

const buildRules = function(ruleDeclarations) {
  let ruleList = ruleDeclarations.map(function(tuple) {
    if (tuple.length < 3) {
      tuple.unshift(null);
    }
    return buildRule(...tuple);
  });
  let flagDict = {};
/* DEFPART_MARKER */
  for (let i = 0, len = ruleList.length; i < len; i++) {
    let rule = ruleList[i];
    const ref = [rule.shortFlag, rule.longFlag];
/* DEFPART_MARKER */
    for (let j = 0, len1 = ref.length; j < len1; j++) {
      let flag = ref[j];
      if (!(flag != null)) {
        continue;
      }
      if (flagDict[flag] != null) {
        throw new Error(`flag ${flag} for switch ${rule.name} was already declared for switch ${flagDict[flag].name}`);
      }
      flagDict[flag] = rule;
    }
  }
  return {ruleList, flagDict};
};

const buildRule = function(shortFlag, longFlag, description) {
  let match = longFlag.match(OPTIONAL);
  shortFlag = shortFlag != null ? shortFlag.match(SHORT_FLAG)[1] : void 0;
  longFlag = longFlag.match(LONG_FLAG)[1];
  return {
    name: longFlag.replace(/^--/, ''),
    shortFlag: shortFlag,
    longFlag: longFlag,
    description: description,
    hasArgument: !!(match && match[1]),
    isList: !!(match && match[2])
  };
};

const normalizeArguments = function(args, flagDict) {
  let rules = [];
  let positional = [];
  let needsArgOpt = null;
  let argIndex = 0;
  while (argIndex < args.length) {
    let arg = args[argIndex];
    let withArg;
    if (needsArgOpt != null) {
      withArg = Object.assign({}, needsArgOpt.rule, {
        argument: arg
      });
      rules.push(withArg);
      needsArgOpt = null;
      argIndex++;
      continue;
    }
    let multiMatch = arg.match(MULTI_FLAG);
    let multiFlags = multiMatch != null ? multiMatch[1].split('').map(function(flagName) {
      return `-${flagName}`;
    }) : null;
    let multiOpts, innerOpts, lastOpt, singleRule;
    if (multiFlags != null) {
      multiOpts = multiFlags.map(function(flag) {
        let rule = flagDict[flag];
        if (rule == null) {
          throw new Error(`unrecognized option ${flag} in multi-flag ${arg}`);
        }
        return {rule, flag};
      });
      innerOpts = multiOpts.slice(0, multiOpts.length - 1);
      lastOpt = multiOpts[multiOpts.length - 1];
/* DEFPART_MARKER */
      for (let i = 0, len = innerOpts.length; i < len; i++) {
        let {rule, flag} = innerOpts[i];
        if (rule.hasArgument) {
          throw new Error(`cannot use option ${flag} in multi-flag ${arg} except as the last option, because it needs an argument`);
        }
        rules.push(rule);
      }
      if (lastOpt.rule.hasArgument) {
        needsArgOpt = lastOpt;
      } else {
        rules.push(lastOpt.rule);
      }
    } else if ([LONG_FLAG, SHORT_FLAG].some(function(pat) {
      return arg.match(pat) != null;
    })) {
      singleRule = flagDict[arg];
      if (singleRule == null) {
        throw new Error(`unrecognized option ${arg}`);
      }
      if (singleRule.hasArgument) {
        needsArgOpt = {
          rule: singleRule,
          flag: arg
        };
      } else {
        rules.push(singleRule);
      }
    } else {
      positional = args.slice(argIndex);
      break;
    }
    argIndex++;
  }
  if (needsArgOpt != null) {
    throw new Error(`value required for ${needsArgOpt.flag}, but it was the last argument provided`);
  }
  return {rules, positional};
};


export class OptionParser {
  constructor(ruleDeclarations, banner) {
    this.banner = banner;
    this.rules = buildRules(ruleDeclarations);
  }

  parse(args) {
    let normalized = normalizeArguments(args, this.rules.flagDict);
    let rules = normalized.rules;
    let positional = normalized.positional;
    let options = {};
/* DEFPART_MARKER */
    for (let i = 0, len = rules.length; i < len; i++) {
      let {hasArgument, argument, isList, name} = rules[i];
      if (hasArgument) {
        if (isList) {
          if (options[name] == null) {
            options[name] = [];
          }
          options[name].push(argument);
        } else {
          options[name] = argument;
        }
      } else {
        options[name] = true;
      }
    }
    if (positional[0] === '--') {
      options.doubleDashed = true;
      positional = positional.slice(1);
    }
    options.arguments = positional;
    return options;
  }

  help() {
    let lines = [];
    if (this.banner) {
      lines.unshift(`${this.banner}\n`);
    }
    const ref = this.rules.ruleList;
/* DEFPART_MARKER */
    for (let i = 0, len = ref.length; i < len; i++) {
      let rule = ref[i];
      let spaces = 15 - rule.longFlag.length;
      spaces = spaces > 0 ? repeat(' ', spaces) : '';
      let letPart = rule.shortFlag ? rule.shortFlag + ', ' : '    ';
      lines.push('  ' + letPart + rule.longFlag + spaces + rule.description);
    }
    return `\n${lines.join('\n')}\n`;
  }

};
