// Generated by CoffeeScript 2.8.0
import {
  repeat
} from './helpers.js';


export class OptionParser {
  constructor(ruleDeclarations, banner) {
    this.banner = banner;
    this.rules = buildRules(ruleDeclarations);
  }

  parse(args) {
    ({rules, positional} = normalizeArguments(args, this.rules.flagDict));
    const options = {};
    for (let i = 0, len = rules.length; i < len; i++) {
      ({hasArgument, argument, isList, name} = rules[i]);
      if (hasArgument) {
        if (isList) {
          if (options[name] == null) {
            options[name] = [];
          }
          options[name].push(argument);
        } else {
          options[name] = argument;
        }
      } else {
        options[name] = true;
      }
    }
    if (positional[0] === '--') {
      options.doubleDashed = true;
      positional = positional.slice(1);
    }
    options.arguments = positional;
    return options;
  }

  help() {
    const lines = [];
    if (this.banner) {
      lines.unshift(`${this.banner}\n`);
    }
    const ref = this.rules.ruleList;
    for (let i = 0, len = ref.length; i < len; i++) {
      const rule = ref[i];
      let spaces = 15 - rule.longFlag.length;
      spaces = spaces > 0 ? repeat(' ', spaces) : '';
      const letPart = rule.shortFlag ? rule.shortFlag + ', ' : '    ';
      lines.push('  ' + letPart + rule.longFlag + spaces + rule.description);
    }
    return `\n${lines.join('\n')}\n`;
  }

};

const LONG_FLAG = /^(--\w[\w\-]*)/;

const SHORT_FLAG = /^(-\w)$/;

const MULTI_FLAG = /^-(\w{2,})/;

const OPTIONAL = /\[(\w+(\*?))\]/;

const buildRules = function(ruleDeclarations) {
  const ruleList = (function() {
    results = [];
    for (let i = 0, len = ruleDeclarations.length; i < len; i++) {
      const tuple = ruleDeclarations[i];
      if (tuple.length < 3) {
        tuple.unshift(null);
      }
      results.push(buildRule(...tuple));
    }
    return results;
  })();
  const flagDict = {};
  for (let i = 0, len = ruleList.length; i < len; i++) {
    const rule = ruleList[i];
    const ref = [rule.shortFlag, rule.longFlag];
    for (let j = 0, len1 = ref.length; j < len1; j++) {
      const flag = ref[j];
      if (!(flag != null)) {
        continue;
      }
      if (flagDict[flag] != null) {
        throw new Error(`flag ${flag} for switch ${rule.name} was already declared for switch ${flagDict[flag].name}`);
      }
      flagDict[flag] = rule;
    }
  }
  return {ruleList, flagDict};
};

const buildRule = function(shortFlag, longFlag, description) {
  const match = longFlag.match(OPTIONAL);
  shortFlag = shortFlag != null ? shortFlag.match(SHORT_FLAG)[1] : void 0;
  longFlag = longFlag.match(LONG_FLAG)[1];
  return {
    name: longFlag.replace(/^--/, ''),
    shortFlag: shortFlag,
    longFlag: longFlag,
    description: description,
    hasArgument: !!(match && match[1]),
    isList: !!(match && match[2])
  };
};

const normalizeArguments = function(args, flagDict) {
  const rules = [];
  let positional = [];
  let needsArgOpt = null;
  for (let argIndex = i = 0, len = args.length; i < len; argIndex = ++i) {
    const arg = args[argIndex];
    if (needsArgOpt != null) {
      const withArg = Object.assign({}, needsArgOpt.rule, {
        argument: arg
      });
      rules.push(withArg);
      needsArgOpt = null;
      continue;
    }
    const multiFlags = (ref = arg.match(MULTI_FLAG)) != null ? ref[1].split('').map(function(flagName) {
      return `-${flagName}`;
    }) : void 0;
    if (multiFlags != null) {
      const multiOpts = multiFlags.map(function(flag) {
        const rule = flagDict[flag];
        if (rule == null) {
          throw new Error(`unrecognized option ${flag} in multi-flag ${arg}`);
        }
        return {rule, flag};
      });
      [...innerOpts] = multiOpts, [lastOpt] = splice.call(innerOpts, -1);
      for (let j = 0, len1 = innerOpts.length; j < len1; j++) {
        ({rule, flag} = innerOpts[j]);
        if (rule.hasArgument) {
          throw new Error(`cannot use option ${flag} in multi-flag ${arg} except as the last option, because it needs an argument`);
        }
        rules.push(rule);
      }
      if (lastOpt.rule.hasArgument) {
        needsArgOpt = lastOpt;
      } else {
        rules.push(lastOpt.rule);
      }
    } else if ([LONG_FLAG, SHORT_FLAG].some(function(pat) {
      return arg.match(pat) != null;
    })) {
      const singleRule = flagDict[arg];
      if (singleRule == null) {
        throw new Error(`unrecognized option ${arg}`);
      }
      if (singleRule.hasArgument) {
        needsArgOpt = {
          rule: singleRule,
          flag: arg
        };
      } else {
        rules.push(singleRule);
      }
    } else {
      positional = args.slice(argIndex);
      break;
    }
  }
  if (needsArgOpt != null) {
    throw new Error(`value required for ${needsArgOpt.flag}, but it was the last argument provided`);
  }
  return {rules, positional};
};
