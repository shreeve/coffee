// Generated by CoffeeScript 2.8.0
import fs from 'fs';
import path from 'path';
import * as helpers from './helpers.js';
import * as optparse from './optparse.js';
import * as CoffeeScript from './index.js';
import {
  spawn,
  exec
} from 'child_process';
import {
  EventEmitter
} from 'events';



let useWinPathSep = path.sep === '\\';

helpers.extend(CoffeeScript, new EventEmitter());

const printLine = function(line) {
  return process.stdout.write(line + '\n');
};

const printWarn = function(line) {
  return process.stderr.write(line + '\n');
};

const hidden = function(file) {
  return /^\.|~$/.test(file);
};

let BANNER = `Usage: coffee [options] path/to/script.coffee [args]

If called without options, \`coffee\` will run your script.`;

let SWITCHES = [['-a', '--ast', 'generate ESTree-compatible AST for tooling'], ['-b', '--bare', 'compile without a top-level function wrapper'], ['-c', '--compile', 'compile to JavaScript and save as .js files'], ['-e', '--eval', 'pass a string from the command line as input'], ['-h', '--help', 'display this help message'], ['-j', '--join [FILE]', 'concatenate the source CoffeeScript before compiling'], ['-m', '--map', 'generate source map and save as .js.map files'], ['-M', '--inline-map', 'generate source map and include it directly in output'], ['-n', '--nodes', 'print out the parse tree that the parser produces'], ['-N', '--nodejs [ARGS]', 'pass options directly to the "node" binary'], ['-H', '--no-header', 'suppress the "Generated by" header'], ['-o', '--output [PATH]', 'set the output path or path/filename for compiled JavaScript'], ['-p', '--print', 'print out the compiled JavaScript'], ['-s', '--stdio', 'listen for and compile scripts over stdio'], ['-t', '--tokens', 'print out the tokens that the lexer/rewriter produce'], ['-v', '--version', 'display the version number'], ['-w', '--watch', 'watch scripts for changes and rerun commands']];

let opts = {};

let sources = [];

let sourceCode = [];

let notSources = {};

let watchedDirs = {};

let optionParser = null;

export const buildCSOptionParser = function() {
  return new optparse.OptionParser(SWITCHES, BANNER);
};

export const run = function() {
  optionParser = buildCSOptionParser();
  try {
    parseOptions();
  } catch (error) {
    let err = error;
    console.error(`option parsing error: ${err.message}`);
    process.exit(1);
  }
  if ((!opts.doubleDashed) && (opts.arguments[1] === '--')) {
    printWarn(`coffee was invoked with '--' as the second positional argument, which is
now deprecated. To pass '--' as an argument to a script to run, put an
additional '--' before the path to your script.

'--' will be removed from the argument list.`);
    printWarn(`The positional arguments were: ${JSON.stringify(opts.arguments)}`);
    opts.arguments = [opts.arguments[0]].concat(opts.arguments.slice(2));
  }
  if (opts.nodejs) {
    return forkNode();
  }
  if (opts.help) {
    return usage();
  }
  if (opts.version) {
    return version();
  }
  if (opts.stdio) {
    return compileStdio();
  }
  if (opts.eval) {
    return compileScript(null, opts.arguments[0]);
  }
  if (!opts.arguments.length) {
    return usage();
  }
  let literals = opts.run ? opts.arguments.splice(1) : [];
  process.argv = process.argv.slice(0, 2).concat(literals);
  process.argv[0] = 'coffee';
  if (opts.output) {
    let outputBasename = path.basename(opts.output);
    if (indexOf.call(outputBasename, '.') >= 0 && (outputBasename !== '.' && outputBasename !== '..') && !helpers.ends(opts.output, path.sep)) {
      opts.outputFilename = outputBasename;
      opts.outputPath = path.resolve(path.dirname(opts.output));
    } else {
      opts.outputFilename = null;
      opts.outputPath = path.resolve(opts.output);
    }
  }
  if (opts.join) {
    opts.join = path.resolve(opts.join);
    console.error(`
The --join option is deprecated and will be removed in a future version.

If for some reason it's necessary to share local variables between files,
replace...

    $ coffee --compile --join bundle.js -- a.coffee b.coffee c.coffee

with...

    $ cat a.coffee b.coffee c.coffee | coffee --compile --stdio > bundle.js
`);
  }
  const ref = opts.arguments;
  results = [];
  for (let i = 0, len = ref.length; i < len; i++) {
    const source = ref[i];
    source = path.resolve(source);
    results.push(compilePath(source, true, source));
  }
  return results;
};

const compilePath = function(source, topLevel, base) {
  if (indexOf.call(sources, source) >= 0 || watchedDirs[source] || !topLevel && (notSources[source] || hidden(source))) {
    return;
  }
  try {
    let stats = fs.statSync(source);
  } catch (error) {
    let err = error;
    if (err.code === 'ENOENT') {
      console.error(`File not found: ${source}`);
      process.exit(1);
    }
    throw err;
  }
  if (stats.isDirectory()) {
    if (path.basename(source) === 'node_modules') {
      notSources[source] = true;
      return;
    }
    if (opts.run) {
      compilePath(findDirectoryIndex(source), topLevel, base);
      return;
    }
    if (opts.watch) {
      watchDir(source, base);
    }
    try {
      let files = fs.readdirSync(source);
    } catch (error) {
      err = error;
      if (err.code === 'ENOENT') {
        return;
      } else {
        throw err;
      }
    }
    results = [];
    for (let i = 0, len = files.length; i < len; i++) {
      const file = files[i];
      results.push(compilePath(path.join(source, file), false, base));
    }
    return results;
  } else if (topLevel || helpers.isCoffee(source)) {
    sources.push(source);
    sourceCode.push(null);
    delete notSources[source];
    if (opts.watch) {
      watch(source, base);
    }
    try {
      let code = fs.readFileSync(source);
    } catch (error) {
      err = error;
      if (err.code === 'ENOENT') {
        return;
      } else {
        throw err;
      }
    }
    return compileScript(source, code.toString(), base);
  } else {
    return notSources[source] = true;
  }
};

const findDirectoryIndex = function(source) {
  const ref = CoffeeScript.FILE_EXTENSIONS;
  for (let i = 0, len = ref.length; i < len; i++) {
    const ext = ref[i];
    let index = path.join(source, `index${ext}`);
    try {
      if ((fs.statSync(index)).isFile()) {
        return index;
      }
    } catch (error) {
      let err = error;
      if (err.code !== 'ENOENT') {
        throw err;
      }
    }
  }
  console.error(`Missing index.coffee in ${source}`);
  return process.exit(1);
};

const compileScript = function(file, input, base = null) {
  let options = compileOptions(file, base);
  try {
    let task = {file, input, options};
    CoffeeScript.emit('compile', task);
    if (opts.tokens) {
      return printTokens(CoffeeScript.tokens(task.input, task.options));
    } else if (opts.nodes) {
      return printLine(CoffeeScript.nodes(task.input, task.options).toString().trim());
    } else if (opts.ast) {
      let compiled = CoffeeScript.compile(task.input, task.options);
      return printLine(JSON.stringify(compiled, null, 2));
    } else if (opts.run) {
      return CoffeeScript.run(task.input, task.options);
    } else if (opts.join && task.file !== opts.join) {
      sourceCode[sources.indexOf(task.file)] = task.input;
      return compileJoin();
    } else {
      compiled = CoffeeScript.compile(task.input, task.options);
      task.output = compiled;
      if (opts.map) {
        task.output = compiled.js;
        task.sourceMap = compiled.v3SourceMap;
      }
      CoffeeScript.emit('success', task);
      if (opts.print) {
        return printLine(task.output.trim());
      } else if (opts.compile || opts.map) {
        let saveTo = opts.outputFilename && sources.length === 1 ? path.join(opts.outputPath, opts.outputFilename) : options.jsPath;
        return writeJs(base, task.file, task.output, saveTo, task.sourceMap);
      }
    }
  } catch (error) {
    let err = error;
    CoffeeScript.emit('failure', err, task);
    if (CoffeeScript.listeners('failure').length) {
      return;
    }
    let message = (err != null ? err.stack : void 0) || `${err}`;
    if (opts.watch) {
      return printLine(message + '\x07');
    } else {
      printWarn(message);
      return process.exit(1);
    }
  }
};

const compileStdio = function() {
  if (opts.map) {
    console.error('--stdio and --map cannot be used together');
    process.exit(1);
  }
  let buffers = [];
  let stdin = process.openStdin();
  stdin.on('data', function(buffer) {
    if (buffer) {
      return buffers.push(buffer);
    }
  });
  return stdin.on('end', function() {
    return compileScript(null, Buffer.concat(buffers).toString());
  });
};

let joinTimeout = null;

const compileJoin = function() {
  if (!opts.join) {
    return;
  }
  if (!sourceCode.some(function(code) {
    return code === null;
  })) {
    clearTimeout(joinTimeout);
    return joinTimeout = wait(100, function() {
      return compileScript(opts.join, sourceCode.join('\n'), opts.join);
    });
  }
};

const watch = function(source, base) {
  let watcher = null;
  let prevStats = null;
  let compileTimeout = null;
  const watchErr = function(err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
    if (indexOf.call(sources, source) < 0) {
      return;
    }
    try {
      rewatch();
      return compile();
    } catch (error) {
      removeSource(source, base);
      return compileJoin();
    }
  };
  const compile = function() {
    clearTimeout(compileTimeout);
    return compileTimeout = wait(25, function() {
      return fs.stat(source, function(err, stats) {
        if (err) {
          return watchErr(err);
        }
        if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
          return rewatch();
        }
        prevStats = stats;
        return fs.readFile(source, function(err, code) {
          if (err) {
            return watchErr(err);
          }
          compileScript(source, code.toString(), base);
          return rewatch();
        });
      });
    });
  };
  const startWatcher = function() {
    return watcher = fs.watch(source).on('change', compile).on('error', function(err) {
      if (err.code !== 'EPERM') {
        throw err;
      }
      return removeSource(source, base);
    });
  };
  const rewatch = function() {
    if (watcher != null) {
      watcher.close();
    }
    return startWatcher();
  };
  try {
    return startWatcher();
  } catch (error) {
    let err = error;
    return watchErr(err);
  }
};

const watchDir = function(source, base) {
  let watcher = null;
  let readdirTimeout = null;
  const startWatcher = function() {
    return watcher = fs.watch(source).on('error', function(err) {
      if (err.code !== 'EPERM') {
        throw err;
      }
      return stopWatcher();
    }).on('change', function() {
      clearTimeout(readdirTimeout);
      return readdirTimeout = wait(25, function() {
        try {
          let files = fs.readdirSync(source);
        } catch (error) {
          let err = error;
          if (err.code !== 'ENOENT') {
            throw err;
          }
          return stopWatcher();
        }
        results = [];
        for (let i = 0, len = files.length; i < len; i++) {
          const file = files[i];
          results.push(compilePath(path.join(source, file), false, base));
        }
        return results;
      });
    });
  };
  const stopWatcher = function() {
    watcher.close();
    return removeSourceDir(source, base);
  };
  watchedDirs[source] = true;
  try {
    return startWatcher();
  } catch (error) {
    let err = error;
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }
};

const removeSourceDir = function(source, base) {
  delete watchedDirs[source];
  let sourcesChanged = false;
  for (let i = 0, len = sources.length; i < len; i++) {
    const file = sources[i];
    if (!(source === path.dirname(file))) {
      continue;
    }
    removeSource(file, base);
    sourcesChanged = true;
  }
  if (sourcesChanged) {
    return compileJoin();
  }
};

const removeSource = function(source, base) {
  let index = sources.indexOf(source);
  sources.splice(index, 1);
  sourceCode.splice(index, 1);
  if (!opts.join) {
    silentUnlink(outputPath(source, base));
    silentUnlink(outputPath(source, base, '.js.map'));
    return timeLog(`removed ${source}`);
  }
};

const silentUnlink = function(path) {
  try {
    return fs.unlinkSync(path);
  } catch (error) {
    let err = error;
    if ((ref = err.code) !== 'ENOENT' && ref !== 'EPERM') {
      throw err;
    }
  }
};

const outputPath = function(source, base, extension = ".js") {
  let basename = helpers.baseFileName(source, true, useWinPathSep);
  let srcDir = path.dirname(source);
  let dir = !opts.outputPath ? srcDir : source === base ? opts.outputPath : path.join(opts.outputPath, path.relative(base, srcDir));
  return path.join(dir, basename + extension);
};

const mkdirp = function(dir, fn) {
  let mode = 0o777 & ~process.umask();
  return (mkdirs = function(p, fn) {
    return fs.exists(p, function(exists) {
      if (exists) {
        return fn();
      } else {
        return mkdirs(path.dirname(p), function() {
          return fs.mkdir(p, mode, function(err) {
            if (err) {
              return fn(err);
            }
            return fn();
          });
        });
      }
    });
  })(dir, fn);
};

const writeJs = function(base, sourcePath, js, jsPath, generatedSourceMap = null) {
  let sourceMapPath = `${jsPath}.map`;
  let jsDir = path.dirname(jsPath);
  const compile = function() {
    if (opts.compile) {
      if (js.length <= 0) {
        js = ' ';
      }
      if (generatedSourceMap) {
        js = `${js}\n//# sourceMappingURL=${helpers.baseFileName(sourceMapPath, false, useWinPathSep)}\n`;
      }
      fs.writeFile(jsPath, js, function(err) {
        if (err) {
          printLine(err.message);
          return process.exit(1);
        } else if (opts.compile && opts.watch) {
          return timeLog(`compiled ${sourcePath}`);
        }
      });
    }
    if (generatedSourceMap) {
      return fs.writeFile(sourceMapPath, generatedSourceMap, function(err) {
        if (err) {
          printLine(`Could not write source map: ${err.message}`);
          return process.exit(1);
        }
      });
    }
  };
  return fs.exists(jsDir, function(itExists) {
    if (itExists) {
      return compile();
    } else {
      return mkdirp(jsDir, compile);
    }
  });
};

const wait = function(milliseconds, func) {
  return setTimeout(func, milliseconds);
};

const timeLog = function(message) {
  return console.log(`${(new Date()).toLocaleTimeString()} - ${message}`);
};

const printTokens = function(tokens) {
  let strings = (function() {
    results = [];
    for (let i = 0, len = tokens.length; i < len; i++) {
      const token = tokens[i];
      let tag = token[0];
      let value = token[1].toString().replace(/\n/, '\\n');
      results.push(`[${tag} ${value}]`);
    }
    return results;
  })();
  return printLine(strings.join(' '));
};

const parseOptions = function() {
  let o = opts = optionParser.parse(process.argv.slice(2));
  o.compile || (o.compile = !!o.output);
  o.run = !(o.compile || o.print || o.map);
  return o.print = !!(o.print || (o.eval || o.stdio && o.compile));
};

const compileOptions = function(filename, base) {
  let answer = {
    filename: filename,
    bare: opts.bare,
    header: opts.compile && !opts['no-header'],
    sourceMap: opts.map,
    inlineMap: opts['inline-map'],
    ast: opts.ast
  };
  if (filename) {
    if (base) {
      let cwd = process.cwd();
      let jsPath = outputPath(filename, base);
      let jsDir = path.dirname(jsPath);
      answer = helpers.merge(answer, {
        jsPath,
        sourceRoot: path.relative(jsDir, cwd) + path.sep,
        sourceFiles: [path.relative(cwd, filename)],
        generatedFile: helpers.baseFileName(jsPath, false, useWinPathSep)
      });
    } else {
      answer = helpers.merge(answer, {
        sourceRoot: "",
        sourceFiles: [helpers.baseFileName(filename, false, useWinPathSep)],
        generatedFile: helpers.baseFileName(filename, true, useWinPathSep) + ".js"
      });
    }
  }
  return answer;
};

const forkNode = function() {
  let nodeArgs = opts.nodejs.split(/\s+/);
  let args = process.argv.slice(1);
  args.splice(args.indexOf('--nodejs'), 2);
  let p = spawn(process.execPath, nodeArgs.concat(args), {
    cwd: process.cwd(),
    env: process.env,
    stdio: [0, 1, 2]
  });
  const ref = ['SIGINT', 'SIGTERM'];
  for (let i = 0, len = ref.length; i < len; i++) {
    const signal = ref[i];
    process.on(signal, (function(signal) {
      return function() {
        return p.kill(signal);
      };
    })(signal));
  }
  return p.on('exit', function(code) {
    return process.exit(code);
  });
};

const usage = function() {
  return printLine(optionParser.help());
};

const version = function() {
  return printLine(`CoffeeScript version ${CoffeeScript.VERSION}`);
};
