// Generated by CoffeeScript 2.8.0


const LineMap = class LineMap {
  constructor(line1) {
    this.line = line1;
    this.columns = [];
  }

  add(column, [sourceLine, sourceColumn], options = {}) {
    if (this.columns[column] && options.noReplace) {
      return;
    }
    return this.columns[column] = {
      line: this.line,
      column,
      sourceLine,
      sourceColumn
    };
  }

  sourceLocation(column) {
    while (!((mapping = this.columns[column]) || (column <= 0))) {
      column--;
    }
    return mapping && [mapping.sourceLine, mapping.sourceColumn];
  }

};

export default const SourceMap = (function() {

  class SourceMap {
    constructor() {
      this.lines = [];
    }

    add(sourceLocation, generatedLocation, options = {}) {
      [line, column] = generatedLocation;
      const lineMap = ((base = this.lines)[line] || (base[line] = new LineMap(line)));
      return lineMap.add(column, sourceLocation, options);
    }

    sourceLocation([line, column]) {
      while (!((lineMap = this.lines[line]) || (line <= 0))) {
        line--;
      }
      return lineMap && lineMap.sourceLocation(column);
    }

    static getSourceMap(filename) {
      return SourceMap.sourceMaps[filename];
    }

    generate(options = {}, code = null) {
      let writingline = 0;
      let lastColumn = 0;
      let lastSourceLine = 0;
      let lastSourceColumn = 0;
      let needComma = false;
      let buffer = "";
      const ref = this.lines;
      for (let lineNumber = i = 0, len = ref.length; i < len; lineNumber = ++i) {
        const lineMap = ref[lineNumber];
        if (lineMap) {
          const ref1 = lineMap.columns;
          for (let j = 0, len1 = ref1.length; j < len1; j++) {
            const mapping = ref1[j];
            if (!(mapping)) {
              continue;
            }
            while (writingline < mapping.line) {
              lastColumn = 0;
              needComma = false;
              buffer += ";";
              writingline++;
            }
            if (needComma) {
              buffer += ",";
              needComma = false;
            }
            buffer += this.encodeVlq(mapping.column - lastColumn);
            lastColumn = mapping.column;
            buffer += this.encodeVlq(0);
            buffer += this.encodeVlq(mapping.sourceLine - lastSourceLine);
            lastSourceLine = mapping.sourceLine;
            buffer += this.encodeVlq(mapping.sourceColumn - lastSourceColumn);
            lastSourceColumn = mapping.sourceColumn;
            needComma = true;
          }
        }
      }
      const sources = options.sourceFiles ? options.sourceFiles : options.filename ? [options.filename] : ['<anonymous>'];
      const v3 = {
        version: 3,
        file: options.generatedFile || '',
        sourceRoot: options.sourceRoot || '',
        sources: sources,
        names: [],
        mappings: buffer
      };
      if (options.sourceMap || options.inlineMap) {
        v3.sourcesContent = [code];
      }
      return v3;
    }

    encodeVlq(value) {
      let answer = '';
      const signBit = value < 0 ? 1 : 0;
      let valueToEncode = (Math.abs(value) << 1) + signBit;
      while (valueToEncode || !answer) {
        let nextChunk = valueToEncode & VLQ_VALUE_MASK;
        valueToEncode = valueToEncode >> VLQ_SHIFT;
        if (valueToEncode) {
          nextChunk |= VLQ_CONTINUATION_BIT;
        }
        answer += this.encodeBase64(nextChunk);
      }
      return answer;
    }

    encodeBase64(value) {
      return BASE64_CHARS[value] || (function() {
        throw new Error(`Cannot Base64 encode value: ${value}`);
      })();
    }

  };

  SourceMap.sourceMaps = Object.create(null);

  const VLQ_SHIFT = 5;

  const VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;

  const VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;

  const BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  return SourceMap;

}).call(this);
