// Generated by CoffeeScript 2.8.0
import {
  isUnassignable,
  JS_FORBIDDEN
} from './lexer.js';
import {
  compact,
  flatten,
  extend,
  merge,
  del,
  starts,
  ends,
  some,
  addDataToNode,
  attachCommentsToNode,
  locationDataToString,
  throwSyntaxError,
  replaceUnicodeCodePointEscapes,
  isFunction,
  isPlainObject,
  isNumber,
  parseNumber
} from './helpers.js';



Error.stackTraceLimit = 2e308;

const Scope = class Scope {
  constructor(parent1, expressions1, method1, referencedVars) {
    this.parent = parent1;
    this.expressions = expressions1;
    this.method = method1;
    this.referencedVars = referencedVars;
    this.variables = [
      {
        name: 'arguments',
        type: 'arguments'
      }
    ];
    this.comments = {};
    this.positions = {};
    if (!this.parent) {
      this.utilities = {};
    }
    this.root = (ref1 = (ref2 = this.parent) != null ? ref2.root : void 0) != null ? ref1 : this;
  }

  add(name, type, immediate) {
    if (this.shared && !immediate) {
      return this.parent.add(name, type, immediate);
    }
    if (Object.prototype.hasOwnProperty.call(this.positions, name)) {
      return this.variables[this.positions[name]].type = type;
    } else {
      return this.positions[name] = this.variables.push({name, type}) - 1;
    }
  }

  namedMethod() {
    if (((ref1 = this.method) != null ? ref1.name : void 0) || !this.parent) {
      return this.method;
    }
    return this.parent.namedMethod();
  }

  find(name, type = 'var') {
    if (this.check(name)) {
      return true;
    }
    this.add(name, type);
    return false;
  }

  parameter(name) {
    if (this.shared && this.parent.check(name, true)) {
      return;
    }
    return this.add(name, 'param');
  }

  check(name) {
    return !!(this.type(name) || ((ref1 = this.parent) != null ? ref1.check(name) : void 0));
  }

  temporary(name, index, single = false) {
    if (single) {
      let startCode = name.charCodeAt(0);
      let endCode = 'z'.charCodeAt(0);
      let diff = endCode - startCode;
      let newCode = startCode + index % (diff + 1);
      let letter = String.fromCharCode(newCode);
      let num = Math.floor(index / (diff + 1));
      return `${letter}${num || ''}`;
    } else {
      return `${name}${index || ''}`;
    }
  }

  type(name) {
    const ref1 = this.variables;
    for (let j = 0, len1 = ref1.length; j < len1; j++) {
      const v = ref1[j];
      if (v.name === name) {
        return v.type;
      }
    }
    return null;
  }

  freeVariable(name, options = {}) {
    let index = 0;
    while (true) {
      let temp = this.temporary(name, index, options.single);
      if (!(this.check(temp) || indexOf.call(this.root.referencedVars, temp) >= 0)) {
        break;
      }
      index++;
    }
    if ((ref1 = options.reserve) != null ? ref1 : true) {
      this.add(temp, 'var', true);
    }
    return temp;
  }

  assign(name, value) {
    this.add(name, {
      value,
      assigned: true
    }, true);
    return this.hasAssignments = true;
  }

  hasDeclarations() {
    return !!this.declaredVariables().length;
  }

  declaredVariables() {
    return ((function() {
      const ref1 = this.variables;
      const results1 = [];
      for (let j = 0, len1 = ref1.length; j < len1; j++) {
        const v = ref1[j];
        if (v.type === 'var') {
          results1.push(v.name);
        }
      }
      return results1;
    }).call(this)).sort();
  }

  assignedVariables() {
    const ref1 = this.variables;
    const results1 = [];
    for (let j = 0, len1 = ref1.length; j < len1; j++) {
      const v = ref1[j];
      if (v.type.assigned) {
        results1.push(`${v.name} = ${v.type.value}`);
      }
    }
    return results1;
  }

};

const YES = function() {
  return true;
};

const NO = function() {
  return false;
};

const THIS = function() {
  return this;
};

const NEGATE = function() {
  this.negated = !this.negated;
  return this;
};

export class CodeFragment {
  constructor(parent, code) {
    this.code = `${code}`;
    this.type = (parent != null ? (ref1 = parent.constructor) != null ? ref1.name : void 0 : void 0) || 'unknown';
    this.locationData = parent != null ? parent.locationData : void 0;
    this.comments = parent != null ? parent.comments : void 0;
  }

  toString() {
    return `${this.code}${this.locationData ? ": " + locationDataToString(this.locationData) : ''}`;
  }

};

const fragmentsToText = function(fragments) {
  return ((function() {
    const results1 = [];
    for (let j = 0, len1 = fragments.length; j < len1; j++) {
      const fragment = fragments[j];
      results1.push(fragment.code);
    }
    return results1;
  })()).join('');
};

export class Base {






































































};

export class HoistTarget extends Base {
  static expand(fragments) {
    for (let i = j = fragments.length - 1; j >= 0; i = j += -1) {
      const fragment = fragments[i];
      if (fragment.fragments) {
        splice.apply(fragments, [i, i - i + 1].concat(ref1 = this.expand(fragment.fragments))), ref1;
      }
    }
    return fragments;
  }

  constructor(source1) {
    super();
    this.source = source1;
    this.options = {};
    this.targetFragments = {
      fragments: []
    };
  }

  isStatement(o) {
    return this.source.isStatement(o);
  }

  update(compile, o) {
    return this.targetFragments.fragments = compile.call(this.source, merge(o, this.options));
  }

  compileToFragments(o, level) {
    this.options.indent = o.indent;
    this.options.level = level != null ? level : o.level;
    return [this.targetFragments];
  }

  compileNode(o) {
    return this.compileToFragments(o);
  }

  compileClosure(o) {
    return this.compileToFragments(o);
  }

};

export class Root extends Base {














};

export class Block extends Base {






































};

export class Directive extends Base {
  constructor(value1) {
    super();
    this.value = value1;
  }

  astProperties(o) {
    return {
      value: Object.assign({}, this.value.ast(o), {
        type: 'DirectiveLiteral'
      })
    };
  }

};

export class Literal extends Base {










};

export class NumberLiteral extends Literal {
  constructor(value1, {parsedValue} = {}) {
    super();
    this.value = value1;
    this.parsedValue = parsedValue;
    if (this.parsedValue == null) {
      if (isNumber(this.value)) {
        this.parsedValue = this.value;
        this.value = `${this.value}`;
      } else {
        this.parsedValue = parseNumber(this.value);
      }
    }
  }

  isBigInt() {
    return /n$/.test(this.value);
  }

  astType() {
    if (this.isBigInt()) {
      return 'BigIntLiteral';
    } else {
      return 'NumericLiteral';
    }
  }

  astProperties() {
    return {
      value: this.isBigInt() ? this.parsedValue.toString() : this.parsedValue,
      extra: {
        rawValue: this.isBigInt() ? this.parsedValue.toString() : this.parsedValue,
        raw: this.value
      }
    };
  }

};

export class InfinityLiteral extends NumberLiteral {
  constructor(value1, {originalValue: originalValue = 'Infinity'} = {}) {
    super();
    this.value = value1;
    this.originalValue = originalValue;
  }

  compileNode() {
    return [this.makeCode('2e308')];
  }

  astNode(o) {
    if (this.originalValue !== 'Infinity') {
      return new NumberLiteral(this.value).withLocationDataFrom(this).ast(o);
    }
    return super.astNode(o);
  }

  astType() {
    return 'Identifier';
  }

  astProperties() {
    return {
      name: 'Infinity',
      declaration: false
    };
  }

};

export class NaNLiteral extends NumberLiteral {
  constructor() {
    super('NaN');
  }

  compileNode(o) {
    let code = [this.makeCode('0/0')];
    if (o.level >= LEVEL_OP) {
      return this.wrapInParentheses(code);
    } else {
      return code;
    }
  }

  astType() {
    return 'Identifier';
  }

  astProperties() {
    return {
      name: 'NaN',
      declaration: false
    };
  }

};

export class StringLiteral extends Literal {
  constructor(originalValue, {
      quote,
      initialChunk,
      finalChunk,
      indent: indent1,
      double: double1,
      heregex: heregex1
    } = {}) {
    super('');
    this.originalValue = originalValue;
    this.quote = quote;
    this.initialChunk = initialChunk;
    this.finalChunk = finalChunk;
    this.indent = indent1;
    this.double = double1;
    this.heregex = heregex1;
    if (this.quote === '///') {
      this.quote = null;
    }
    this.fromSourceString = this.quote != null;
    if (this.quote == null) {
      this.quote = '"';
    }
    let heredoc = this.isFromHeredoc();
    let val = this.originalValue;
    if (this.heregex) {
      val = val.replace(HEREGEX_OMIT, '$1$2');
      val = replaceUnicodeCodePointEscapes(val, {
        flags: this.heregex.flags
      });
    } else {
      val = val.replace(STRING_OMIT, '$1');
      val = !this.fromSourceString ? val : heredoc ? (this.indent ? indentRegex = RegExp(`\\n${this.indent}`, "g") : void 0, indentRegex ? val = val.replace(indentRegex, '\n') : void 0, this.initialChunk ? val = val.replace(LEADING_BLANK_LINE, '') : void 0, this.finalChunk ? val = val.replace(TRAILING_BLANK_LINE, '') : void 0, val) : val.replace(SIMPLE_STRING_OMIT, (match, offset) => {
        if ((this.initialChunk && offset === 0) || (this.finalChunk && offset + match.length === val.length)) {
          return '';
        } else {
          return ' ';
        }
      });
    }
    this.delimiter = this.quote.charAt(0);
    this.value = makeDelimitedLiteral(val, {delimiter: this.delimiter, double: this.double});
    this.unquotedValueForTemplateLiteral = makeDelimitedLiteral(val, {
      delimiter: '`',
      double: this.double,
      escapeNewlines: false,
      includeDelimiters: false,
      convertTrailingNullEscapes: true
    });
  }

  compileNode(o) {
    if (this.shouldGenerateTemplateLiteral()) {
      return StringWithInterpolations.fromStringLiteral(this).compileNode(o);
    }
    return super.compileNode(o);
  }

  withoutQuotesInLocationData() {
    let endsWithNewline = this.originalValue.slice(-1) === '\n';
    let locationData = Object.assign({}, this.locationData);
    locationData.first_column += this.quote.length;
    if (endsWithNewline) {
      locationData.last_line -= 1;
      locationData.last_column = locationData.last_line === locationData.first_line ? locationData.first_column + this.originalValue.length - '\n'.length : this.originalValue.slice(0, -1).length - '\n'.length - this.originalValue.slice(0, -1).lastIndexOf('\n');
    } else {
      locationData.last_column -= this.quote.length;
    }
    locationData.last_column_exclusive -= this.quote.length;
    locationData.range = [locationData.range[0] + this.quote.length, locationData.range[1] - this.quote.length];
    let copy = new StringLiteral(this.originalValue, {quote: this.quote, initialChunk: this.initialChunk, finalChunk: this.finalChunk, indent: this.indent, double: this.double, heregex: this.heregex});
    copy.locationData = locationData;
    return copy;
  }

  isFromHeredoc() {
    return this.quote.length === 3;
  }

  shouldGenerateTemplateLiteral() {
    return this.isFromHeredoc();
  }

  astNode(o) {
    if (this.shouldGenerateTemplateLiteral()) {
      return StringWithInterpolations.fromStringLiteral(this).ast(o);
    }
    return super.astNode(o);
  }

  astProperties() {
    return {
      value: this.originalValue,
      extra: {
        raw: `${this.delimiter}${this.originalValue}${this.delimiter}`
      }
    };
  }

};

export class RegexLiteral extends Literal {






};

export class PassthroughLiteral extends Literal {
  constructor(originalValue, {here, generated} = {}) {
    super('');
    this.originalValue = originalValue;
    this.here = here;
    this.generated = generated;
    this.value = this.originalValue.replace(/\\+(`|$)/g, function(string) {
      return string.slice(-Math.ceil(string.length / 2));
    });
  }

  astNode(o) {
    if (this.generated) {
      return null;
    }
    return super.astNode(o);
  }

  astProperties() {
    return {
      value: this.originalValue,
      here: !!this.here
    };
  }

};

export class IdentifierLiteral extends Literal {






};

export class PropertyName extends Literal {




};

export class ComputedPropertyName extends PropertyName {
  compileNode(o) {
    return [this.makeCode('['), ...this.value.compileToFragments(o, LEVEL_LIST), this.makeCode(']')];
  }

  astNode(o) {
    return this.value.ast(o);
  }

};

export class StatementLiteral extends Literal {






};

export class ThisLiteral extends Literal {
  constructor(value) {
    super('this');
    this.shorthand = value === '@';
  }

  compileNode(o) {
    let code = ((ref1 = o.scope.method) != null ? ref1.bound : void 0) ? o.scope.method.context : this.value;
    return [this.makeCode(code)];
  }

  astType() {
    return 'ThisExpression';
  }

  astProperties() {
    return {
      shorthand: this.shorthand
    };
  }

};

export class UndefinedLiteral extends Literal {
  constructor() {
    super('undefined');
  }

  compileNode(o) {
    return [this.makeCode(o.level >= LEVEL_ACCESS ? '(void 0)' : 'void 0')];
  }

  astType() {
    return 'Identifier';
  }

  astProperties() {
    return {
      name: this.value,
      declaration: false
    };
  }

};

export class NullLiteral extends Literal {
  constructor() {
    super('null');
  }

};

export class BooleanLiteral extends Literal {
  constructor(value, {originalValue} = {}) {
    super(value);
    this.originalValue = originalValue;
    if (this.originalValue == null) {
      this.originalValue = this.value;
    }
  }

  astProperties() {
    return {
      value: this.value === 'true' ? true : false,
      name: this.originalValue
    };
  }

};

export class DefaultLiteral extends Literal {
  astType() {
    return 'Identifier';
  }

  astProperties() {
    return {
      name: 'default',
      declaration: false
    };
  }

};

export class Return extends Base {












};

export class FuncDirectiveReturn extends Return {








};

export class YieldReturn extends FuncDirectiveReturn {};

export class AwaitReturn extends FuncDirectiveReturn {};

export class Value extends Base {


































































};

export class MetaProperty extends Base {








};

export class HereComment extends Base {
  constructor({
      content,
      newLine,
      unshift,
      locationData: locationData1
    }) {
    super();
    this.content = content;
    this.newLine = newLine;
    this.unshift = unshift;
    this.locationData = locationData1;
  }

  compileNode(o) {
    let multiline = indexOf.call(this.content, '\n') >= 0;
    if (multiline) {
      let indent = null;
      const ref1 = this.content.split('\n');
      for (let j = 0, len1 = ref1.length; j < len1; j++) {
        const line = ref1[j];
        let leadingWhitespace = /^\s*/.exec(line)[0];
        if (!indent || leadingWhitespace.length < indent.length) {
          indent = leadingWhitespace;
        }
      }
      if (indent) {
        this.content = this.content.replace(RegExp(`\\n${indent}`, "g"), '\n');
      }
    }
    let hasLeadingMarks = /\n\s*[#|\*]/.test(this.content);
    if (hasLeadingMarks) {
      this.content = this.content.replace(/^([ \t]*)#(?=\s)/gm, ' *');
    }
    this.content = `/*${this.content}${hasLeadingMarks ? ' ' : ''}*/`;
    let fragment = this.makeCode(this.content);
    fragment.newLine = this.newLine;
    fragment.unshift = this.unshift;
    fragment.multiline = multiline;
    fragment.isComment = fragment.isHereComment = true;
    return fragment;
  }

  astType() {
    return 'CommentBlock';
  }

  astProperties() {
    return {
      value: this.content
    };
  }

};

export class LineComment extends Base {
  constructor({
      content,
      newLine,
      unshift,
      locationData: locationData1,
      precededByBlankLine
    }) {
    super();
    this.content = content;
    this.newLine = newLine;
    this.unshift = unshift;
    this.locationData = locationData1;
    this.precededByBlankLine = precededByBlankLine;
  }

  compileNode(o) {
    let fragment = this.makeCode(/^\s*$/.test(this.content) ? '' : `${this.precededByBlankLine ? `\n${o.indent}` : ''}//${this.content}`);
    fragment.newLine = this.newLine;
    fragment.unshift = this.unshift;
    fragment.trail = !this.newLine && !this.unshift;
    fragment.isComment = fragment.isLineComment = true;
    return fragment;
  }

  astType() {
    return 'CommentLine';
  }

  astProperties() {
    return {
      value: this.content
    };
  }

};

export class Call extends Base {




















};

export class SuperCall extends Call {




};

export class Super extends Base {








};

export class RegexWithInterpolations extends Base {








};

export class TaggedTemplateCall extends Call {
  constructor(variable, arg, soak) {
    if (arg instanceof StringLiteral) {
      arg = StringWithInterpolations.fromStringLiteral(arg);
    }
    super(variable, [arg], soak);
  }

  compileNode(o) {
    return this.variable.compileToFragments(o, LEVEL_ACCESS).concat(this.args[0].compileToFragments(o, LEVEL_LIST));
  }

  astType() {
    return 'TaggedTemplateExpression';
  }

  astProperties(o) {
    return {
      tag: this.variable.ast(o, LEVEL_ACCESS),
      quasi: this.args[0].ast(o, LEVEL_LIST)
    };
  }

};

export class Extends extends Base {




};

export class Access extends Base {






};

export class Index extends Base {








};

export class Range extends Base {










};

export class Slice extends Base {






};

export class Obj extends Base {






























};

export class ObjectProperty extends Base {
  constructor({key, fromAssign}) {
    super();
    if (fromAssign) {
      ({
        variable: this.key,
        value,
        context
      } = fromAssign);
      if (context === 'object') {
        this.value = value;
      } else {
        this.value = fromAssign;
        this.shorthand = true;
      }
      this.locationData = fromAssign.locationData;
    } else {
      this.key = key;
      this.shorthand = true;
      this.locationData = key.locationData;
    }
  }

  astProperties(o) {
    let isComputedPropertyName = (this.key instanceof Value && this.key.base instanceof ComputedPropertyName) || this.key.unwrap() instanceof StringWithInterpolations;
    let keyAst = this.key.ast(o, LEVEL_LIST);
    return {
      key: (keyAst != null ? keyAst.declaration : void 0) ? Object.assign({}, keyAst, {
        declaration: false
      }) : keyAst,
      value: (ref1 = (ref2 = this.value) != null ? ref2.ast(o, LEVEL_LIST) : void 0) != null ? ref1 : keyAst,
      shorthand: !!this.shorthand,
      computed: !!isComputedPropertyName,
      method: false
    };
  }

};

export class Arr extends Base {




















};

export class Class extends Base {






































};

export class ExecutableClassBody extends Base {










};

export class ClassProperty extends Base {




};

export class ClassPrototypeProperty extends Base {




};

export class ModuleDeclaration extends Base {








};

export class ImportDeclaration extends ModuleDeclaration {
  compileNode(o) {
    this.checkScope(o, 'import');
    o.importedSymbols = [];
    let code = [];
    code.push(this.makeCode(`${this.tab}import `));
    if (this.clause != null) {
      code.push(...this.clause.compileNode(o));
    }
    if (((ref1 = this.source) != null ? ref1.value : void 0) != null) {
      if (this.clause !== null) {
        code.push(this.makeCode(' from '));
      }
      let sourceValue = this.source.value;
      if (sourceValue.match(/^['"]\.\.?\//) != null) {
        let unquoted = sourceValue.slice(1, -1);
        if (unquoted.match(/\.\w+$/) == null) {
          let quoteMark = sourceValue[0];
          sourceValue = `${quoteMark}${unquoted}.js${quoteMark}`;
        }
      }
      code.push(this.makeCode(sourceValue));
      if (this.source.value.match(/\.json['"]$/) && (this.assertions == null)) {
        code.push(this.makeCode(" with { type: 'json' }"));
      } else if (this.assertions != null) {
        code.push(this.makeCode(' with '));
        code.push(...this.assertions.compileToFragments(o));
      }
    }
    code.push(this.makeCode(';'));
    return code;
  }

  astNode(o) {
    o.importedSymbols = [];
    return super.astNode(o);
  }

  astProperties(o) {
    let ret = {
      specifiers: (ref1 = (ref2 = this.clause) != null ? ref2.ast(o) : void 0) != null ? ref1 : [],
      source: this.source.ast(o),
      assertions: this.astAssertions(o)
    };
    if (this.clause) {
      ret.importKind = 'value';
    }
    return ret;
  }

};

export class ImportClause extends Base {






};

export class ExportDeclaration extends ModuleDeclaration {
  compileNode(o) {
    this.checkScope(o, 'export');
    this.checkForAnonymousClassExport();
    let code = [];
    code.push(this.makeCode(`${this.tab}export `));
    if (this instanceof ExportDefaultDeclaration) {
      code.push(this.makeCode('default '));
    }
    if (!(this instanceof ExportDefaultDeclaration)) {
      if (this.clause instanceof Class) {
        this.clause.moduleDeclaration = 'export';
      } else if (this.clause instanceof Assign) {
        code.push(this.makeCode('const '));
        this.clause.moduleDeclaration = 'export';
      }
    } else {
      if (this.clause instanceof Class) {
        this.clause.moduleDeclaration = 'export default';
      }
    }
    if ((this.clause.body != null) && this.clause.body instanceof Block) {
      code = code.concat(this.clause.compileToFragments(o, LEVEL_TOP));
    } else {
      code = code.concat(this.clause.compileNode(o));
    }
    if (((ref1 = this.source) != null ? ref1.value : void 0) != null) {
      let sourceValue = this.source.value;
      if (sourceValue.match(/^['"]\.\.?\//) != null) {
        let unquoted = sourceValue.slice(1, -1);
        if (unquoted.match(/\.\w+$/) == null) {
          let quoteMark = sourceValue[0];
          sourceValue = `${quoteMark}${unquoted}.js${quoteMark}`;
        }
      }
      code.push(this.makeCode(` from ${sourceValue}`));
      if (this.assertions != null) {
        code.push(this.makeCode(' assert '));
        code.push(...this.assertions.compileToFragments(o));
      }
    }
    code.push(this.makeCode(';'));
    return code;
  }

  checkForAnonymousClassExport() {
    if (!(this instanceof ExportDefaultDeclaration) && this.clause instanceof Class && !this.clause.variable) {
      return this.clause.error('anonymous classes cannot be exported');
    }
  }

  astNode(o) {
    this.checkForAnonymousClassExport();
    return super.astNode(o);
  }

};

export class ExportNamedDeclaration extends ExportDeclaration {
  astProperties(o) {
    let ret = {
      source: (ref1 = (ref2 = this.source) != null ? ref2.ast(o) : void 0) != null ? ref1 : null,
      assertions: this.astAssertions(o),
      exportKind: 'value'
    };
    let clauseAst = this.clause.ast(o);
    if (this.clause instanceof ExportSpecifierList) {
      ret.specifiers = clauseAst;
      ret.declaration = null;
    } else {
      ret.specifiers = [];
      ret.declaration = clauseAst;
    }
    return ret;
  }

};

export class ExportDefaultDeclaration extends ExportDeclaration {
  astProperties(o) {
    return {
      declaration: this.clause.ast(o),
      assertions: this.astAssertions(o)
    };
  }

};

export class ExportAllDeclaration extends ExportDeclaration {
  astProperties(o) {
    return {
      source: this.source.ast(o),
      assertions: this.astAssertions(o),
      exportKind: 'value'
    };
  }

};

export class ModuleSpecifierList extends Base {






};

export class ImportSpecifierList extends ModuleSpecifierList {};

export class ExportSpecifierList extends ModuleSpecifierList {};

export class ModuleSpecifier extends Base {








};

export class ImportSpecifier extends ModuleSpecifier {
  constructor(imported, local) {
    super(imported, local, 'import');
  }

  addIdentifierToScope(o) {
    if ((ref1 = this.identifier, indexOf.call(o.importedSymbols, ref1) >= 0) || o.scope.check(this.identifier)) {
      this.error(`'${this.identifier}' has already been declared`);
    } else {
      o.importedSymbols.push(this.identifier);
    }
    return super.addIdentifierToScope(o);
  }

  astProperties(o) {
    let originalAst = this.original.ast(o);
    return {
      imported: originalAst,
      local: (ref1 = (ref2 = this.alias) != null ? ref2.ast(o) : void 0) != null ? ref1 : originalAst,
      importKind: null
    };
  }

};

export class ImportDefaultSpecifier extends ImportSpecifier {
  astProperties(o) {
    return {
      local: this.original.ast(o)
    };
  }

};

export class ImportNamespaceSpecifier extends ImportSpecifier {
  astProperties(o) {
    return {
      local: this.alias.ast(o)
    };
  }

};

export class ExportSpecifier extends ModuleSpecifier {
  constructor(local, exported) {
    super(local, exported, 'export');
  }

  astProperties(o) {
    let originalAst = this.original.ast(o);
    return {
      local: originalAst,
      exported: (ref1 = (ref2 = this.alias) != null ? ref2.ast(o) : void 0) != null ? ref1 : originalAst
    };
  }

};

export class DynamicImport extends Base {
  compileNode() {
    return [this.makeCode('import')];
  }

  astType() {
    return 'Import';
  }

};

export class DynamicImportCall extends Call {
  compileNode(o) {
    this.checkArguments();
    return super.compileNode(o);
  }

  checkArguments() {
    if (!((1 <= (ref1 = this.args.length) && ref1 <= 2))) {
      return this.error('import() accepts either one or two arguments');
    }
  }

  astNode(o) {
    this.checkArguments();
    return super.astNode(o);
  }

};

export class Assign extends Base {












































};

export class FuncGlyph extends Base {
  constructor(glyph) {
    super();
    this.glyph = glyph;
  }

};

export class Code extends Base {
















































};

export class Param extends Base {














};

export class Splat extends Base {


















};

export class Expansion extends Base {














};

export class Elision extends Base {










};

export class While extends Base {
















};

export class Op extends Base {






















































};

export class In extends Base {










};

export class Try extends Base {












};

export class Catch extends Base {
















};

export class Throw extends Base {








};

export class Existence extends Base {








};

export class Parens extends Base {










};

export class StringWithInterpolations extends Base {
















};

export class TemplateElement extends Base {
  constructor(value1, {
      tail: tail1
    } = {}) {
    super();
    this.value = value1;
    this.tail = tail1;
  }

  astProperties() {
    return {
      value: {
        raw: this.value
      },
      tail: !!this.tail
    };
  }

};

export class Interpolation extends Base {


};

export class EmptyInterpolation extends Base {
  constructor() {
    super();
  }

};

export class For extends While {
















};

export class Switch extends Base {














};

let SwitchCase = (function() {
  class SwitchCase extends Base {
    constructor(test1, block1, {trailing} = {}) {
      super();
      this.test = test1;
      this.block = block1;
      this.trailing = trailing;
    }

    astProperties(o) {
      return {
        test: (ref1 = (ref2 = this.test) != null ? ref2.ast(o, LEVEL_PAREN) : void 0) != null ? ref1 : null,
        consequent: (ref3 = (ref4 = this.block) != null ? ref4.ast(o, LEVEL_TOP).body : void 0) != null ? ref3 : [],
        trailing: !!this.trailing
      };
    }

  };

  SwitchCase.prototype.children = ['test', 'block'];

  return SwitchCase;

}).call(this);

export class SwitchWhen extends Base {


};

export class If extends Base {
































};

export class Sequence extends Base {








};

const UTILITIES = {
  modulo: function() {
    return 'function(a, b) { return (+a % (b = +b) + b) % b; }';
  },
  boundMethodCheck: function() {
    return "function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } }";
  },
  hasProp: function() {
    return '{}.hasOwnProperty';
  },
  indexOf: function() {
    return '[].indexOf';
  },
  slice: function() {
    return '[].slice';
  },
  splice: function() {
    return '[].splice';
  }
};

const LEVEL_TOP = 1;

const LEVEL_PAREN = 2;

const LEVEL_LIST = 3;

const LEVEL_COND = 4;

const LEVEL_OP = 5;

const LEVEL_ACCESS = 6;

const TAB = '  ';

const SIMPLENUM = /^[+-]?\d+(?:_\d+)*$/;

const SIMPLE_STRING_OMIT = /\s*\n\s*/g;

const LEADING_BLANK_LINE = /^[^\n\S]*\n/;

const TRAILING_BLANK_LINE = /\n[^\n\S]*$/;

const STRING_OMIT = /((?:\\\\)+)|\\[^\S\n]*\n\s*/g;

const HEREGEX_OMIT = /((?:\\\\)+)|\\(\s)|\s+(?:#.*)?/g;

const utility = function(name, o) {
  ({root} = o.scope);
  if (name in root.utilities) {
    return root.utilities[name];
  } else {
    let ref = root.freeVariable(name);
    root.assign(ref, UTILITIES[name](o));
    return root.utilities[name] = ref;
  }
};

const multident = function(code, tab, includingFirstLine = true) {
  let endsWithNewLine = code[code.length - 1] === '\n';
  code = (includingFirstLine ? tab : '') + code.replace(/\n/g, `$&${tab}`);
  code = code.replace(/\s+$/, '');
  if (endsWithNewLine) {
    code = code + '\n';
  }
  return code;
};

const indentInitial = function(fragments, node) {
  for (let fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {
    const fragment = fragments[fragmentIndex];
    if (fragment.isHereComment) {
      fragment.code = multident(fragment.code, node.tab);
    } else {
      fragments.splice(fragmentIndex, 0, node.makeCode(`${node.tab}`));
      break;
    }
  }
  return fragments;
};

const hasLineComments = function(node) {
  if (!node.comments) {
    return false;
  }
  const ref1 = node.comments;
  for (let j = 0, len1 = ref1.length; j < len1; j++) {
    const comment = ref1[j];
    if (comment.here === false) {
      return true;
    }
  }
  return false;
};

const moveComments = function(from, to) {
  if (!(from != null ? from.comments : void 0)) {
    return;
  }
  attachCommentsToNode(from.comments, to);
  return delete from.comments;
};

const unshiftAfterComments = function(fragments, fragmentToInsert) {
  let inserted = false;
  for (let fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {
    const fragment = fragments[fragmentIndex];
    if (!(!fragment.isComment)) {
      continue;
    }
    fragments.splice(fragmentIndex, 0, fragmentToInsert);
    inserted = true;
    break;
  }
  if (!inserted) {
    fragments.push(fragmentToInsert);
  }
  return fragments;
};

const isLiteralArguments = function(node) {
  return node instanceof IdentifierLiteral && node.value === 'arguments';
};

const isLiteralThis = function(node) {
  return node instanceof ThisLiteral || (node instanceof Code && node.bound);
};

const shouldCacheOrIsAssignable = function(node) {
  return node.shouldCache() || (typeof node.isAssignable === "function" ? node.isAssignable() : void 0);
};

const unfoldSoak = function(o, parent, name) {
  if (!(ifn = parent[name].unfoldSoak(o))) {
    return;
  }
  parent[name] = ifn.body;
  ifn.body = new Value(parent);
  return ifn;
};

const makeDelimitedLiteral = function(body, {
    delimiter: delimiterOption,
    escapeNewlines,
    double,
    includeDelimiters = true,
    escapeDelimiter = true,
    convertTrailingNullEscapes
  } = {}) {
  if (body === '' && delimiterOption === '/') {
    body = '(?:)';
  }
  let escapeTemplateLiteralCurlies = delimiterOption === '`';
  let regex = RegExp(`(\\\\\\\\)|(\\\\0(?=\\d))${convertTrailingNullEscapes ? /|(\\0)$/.source : ''}${escapeDelimiter ? RegExp(`|\\\\?(${delimiterOption})`).source : ''}${escapeTemplateLiteralCurlies ? /|\\?(\$\{)/.source : ''}|\\\\?(?:${escapeNewlines ? '(\n)|' : ''}(\\r)|(\\u2028)|(\\u2029))|(\\\\.)`, "g");
  body = body.replace(regex, function(match, backslash, nul, ...args) {
    let trailingNullEscape = convertTrailingNullEscapes ? args.shift() : void 0;
    let delimiter = escapeDelimiter ? args.shift() : void 0;
    let templateLiteralCurly = escapeTemplateLiteralCurlies ? args.shift() : void 0;
    let lf = escapeNewlines ? args.shift() : void 0;
    [cr, ls, ps, other] = args;
    switch (false) {
      case !backslash:
        if (double) {
          return backslash + backslash;
        } else {
          return backslash;
        }
      case !nul:
        return '\\x00';
      case !trailingNullEscape:
        return "\\x00";
      case !delimiter:
        return `\\${delimiter}`;
      case !templateLiteralCurly:
        return "\\${";
      case !lf:
        return '\\n';
      case !cr:
        return '\\r';
      case !ls:
        return '\\u2028';
      case !ps:
        return '\\u2029';
      case !other:
        if (double) {
          return `\\${other}`;
        } else {
          return other;
        }
    }
  });
  let printedDelimiter = includeDelimiters ? delimiterOption : '';
  return `${printedDelimiter}${body}${printedDelimiter}`;
};

const sniffDirectives = function(expressions, {notFinalExpression} = {}) {
  let index = 0;
  let lastIndex = expressions.length - 1;
  results1 = [];
  while (index <= lastIndex) {
    if (index === lastIndex && notFinalExpression) {
      break;
    }
    let expression = expressions[index];
    if ((unwrapped = expression != null ? typeof expression.unwrap === "function" ? expression.unwrap() : void 0 : void 0) instanceof PassthroughLiteral && unwrapped.generated) {
      index++;
      continue;
    }
    if (!(expression instanceof Value && expression.isString() && !expression.unwrap().shouldGenerateTemplateLiteral())) {
      break;
    }
    expressions[index] = new Directive(expression).withLocationDataFrom(expression);
    results1.push(index++);
  }
  return results1;
};

const astAsBlockIfNeeded = function(node, o) {
  let unwrapped = node.unwrap();
  if (unwrapped instanceof Block && unwrapped.expressions.length > 1) {
    unwrapped.makeReturn(null, true);
    return unwrapped.ast(o, LEVEL_TOP);
  } else {
    return node.ast(o, LEVEL_PAREN);
  }
};

const lesser = function(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
};

const greater = function(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
};

const isAstLocGreater = function(a, b) {
  if (a.line > b.line) {
    return true;
  }
  if (a.line !== b.line) {
    return false;
  }
  return a.column > b.column;
};

const isLocationDataStartGreater = function(a, b) {
  if (a.first_line > b.first_line) {
    return true;
  }
  if (a.first_line !== b.first_line) {
    return false;
  }
  return a.first_column > b.first_column;
};

const isLocationDataEndGreater = function(a, b) {
  if (a.last_line > b.last_line) {
    return true;
  }
  if (a.last_line !== b.last_line) {
    return false;
  }
  return a.last_column > b.last_column;
};

export const mergeLocationData = function(locationDataA, locationDataB, {justLeading, justEnding} = {}) {
  return Object.assign(justEnding ? {
    first_line: locationDataA.first_line,
    first_column: locationDataA.first_column
  } : isLocationDataStartGreater(locationDataA, locationDataB) ? {
    first_line: locationDataB.first_line,
    first_column: locationDataB.first_column
  } : {
    first_line: locationDataA.first_line,
    first_column: locationDataA.first_column
  }, justLeading ? {
    last_line: locationDataA.last_line,
    last_column: locationDataA.last_column,
    last_line_exclusive: locationDataA.last_line_exclusive,
    last_column_exclusive: locationDataA.last_column_exclusive
  } : isLocationDataEndGreater(locationDataA, locationDataB) ? {
    last_line: locationDataA.last_line,
    last_column: locationDataA.last_column,
    last_line_exclusive: locationDataA.last_line_exclusive,
    last_column_exclusive: locationDataA.last_column_exclusive
  } : {
    last_line: locationDataB.last_line,
    last_column: locationDataB.last_column,
    last_line_exclusive: locationDataB.last_line_exclusive,
    last_column_exclusive: locationDataB.last_column_exclusive
  }, {
    range: [justEnding ? locationDataA.range[0] : lesser(locationDataA.range[0], locationDataB.range[0]), justLeading ? locationDataA.range[1] : greater(locationDataA.range[1], locationDataB.range[1])]
  });
};

export const mergeAstLocationData = function(nodeA, nodeB, {justLeading, justEnding} = {}) {
  return {
    loc: {
      start: justEnding ? nodeA.loc.start : isAstLocGreater(nodeA.loc.start, nodeB.loc.start) ? nodeB.loc.start : nodeA.loc.start,
      end: justLeading ? nodeA.loc.end : isAstLocGreater(nodeA.loc.end, nodeB.loc.end) ? nodeA.loc.end : nodeB.loc.end
    },
    range: [justEnding ? nodeA.range[0] : lesser(nodeA.range[0], nodeB.range[0]), justLeading ? nodeA.range[1] : greater(nodeA.range[1], nodeB.range[1])],
    start: justEnding ? nodeA.start : lesser(nodeA.start, nodeB.start),
    end: justLeading ? nodeA.end : greater(nodeA.end, nodeB.end)
  };
};

export const convertLocationDataToAst = function({first_line, first_column, last_line_exclusive, last_column_exclusive, range}) {
  return {
    loc: {
      start: {
        line: first_line + 1,
        column: first_column
      },
      end: {
        line: last_line_exclusive + 1,
        column: last_column_exclusive
      }
    },
    range: [range[0], range[1]],
    start: range[0],
    end: range[1]
  };
};

const zeroWidthLocationDataFromEndLocation = function({
    range: [, endRange],
    last_line_exclusive,
    last_column_exclusive
  }) {
  return {
    first_line: last_line_exclusive,
    first_column: last_column_exclusive,
    last_line: last_line_exclusive,
    last_column: last_column_exclusive,
    last_line_exclusive,
    last_column_exclusive,
    range: [endRange, endRange]
  };
};

const extractSameLineLocationDataFirst = function(numChars) {
  return function({
      range: [startRange],
      first_line,
      first_column
    }) {
    return {
      first_line,
      first_column,
      last_line: first_line,
      last_column: first_column + numChars - 1,
      last_line_exclusive: first_line,
      last_column_exclusive: first_column + numChars,
      range: [startRange, startRange + numChars]
    };
  };
};

const extractSameLineLocationDataLast = function(numChars) {
  return function({
      range: [, endRange],
      last_line,
      last_column,
      last_line_exclusive,
      last_column_exclusive
    }) {
    return {
      first_line: last_line,
      first_column: last_column - (numChars - 1),
      last_line: last_line,
      last_column: last_column,
      last_line_exclusive,
      last_column_exclusive,
      range: [endRange - numChars, endRange]
    };
  };
};

const emptyExpressionLocationData = function({
    interpolationNode: element,
    openingBrace,
    closingBrace
  }) {
  return {
    first_line: element.locationData.first_line,
    first_column: element.locationData.first_column + openingBrace.length,
    last_line: element.locationData.last_line,
    last_column: element.locationData.last_column - closingBrace.length,
    last_line_exclusive: element.locationData.last_line,
    last_column_exclusive: element.locationData.last_column,
    range: [element.locationData.range[0] + openingBrace.length, element.locationData.range[1] - closingBrace.length]
  };
};
