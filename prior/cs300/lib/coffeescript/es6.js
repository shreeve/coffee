// Generated by CoffeeScript 2.9.0

import { createRequire } from 'module';
const require = createRequire(import.meta.url);

const hasProp = {}.hasOwnProperty;

class ES6Backend {
  constructor(options1 = {}, ast = {}) {
    this.options = options1;
    this.ast = ast;
    this.cache = new Map();
    this.currentDirective = null;
    this.currentRule = null;
  }

  _ensureLocationData(node) {
    let ref;
    if (typeof node === "object" && node !== null) {
      node.locationData = (ref = node.locationData) != null ? ref : {
        first_line: 0,
        first_column: 0,
        last_line: 0,
        last_column: 0,
        range: [0, 0]
      };
      if (typeof node.updateLocationDataIfMissing === "function") {
        node.updateLocationDataIfMissing(node.locationData);
      }
    }
    return node;
  }

  _stripQuotes(str) {
    let ref;
    if (str == null) {
      return str;
    }
    if (((ref = str[0]) === "\"" || ref === "'") && str[0] === str[str.length - 1]) {
      return str.slice(1, -1);
    } else {
      return str;
    }
  }

  _toNode(value) {
    if (value instanceof this.ast.Base) {
      return value;
    }
    if (typeof value === "string") {
      return new this.ast.IdentifierLiteral(value);
    }
    if (typeof value === "number") {
      return new this.ast.NumberLiteral(value);
    }
    if (typeof value === "boolean") {
      return new this.ast.BooleanLiteral(value);
    }
    return value;
  }

  _toValue(base, properties) {
    let props;
    props = Array.isArray(properties) ? properties : [];
    if (base instanceof this.ast.Value) {
      if (props.length) {
        base.add(props);
      }
      return base;
    }
    if ((base != null) && !(base instanceof this.ast.Base)) {
      base = this._toNode(base);
    }
    return new this.ast.Value(base, props);
  }

  reduce(values, positions, stackTop, symbolCount, directive) {
    let handler, lookup, o, outName, ref, result, util;
    lookup = function(index) {
      return values[stackTop - symbolCount + 1 + index];
    };
    this.currentDirective = directive;
    this.currentRule = directive;
    this.currentLookup = lookup;
    handler = {
      get: function(target, prop) {
        var idx;
        if (prop in target) {
          return target[prop];
        }
        if (typeof prop === "string" && /^\d+$/.test(prop)) {
          idx = parseInt(prop, 10) - 1;
          if (idx >= 0) {
            return lookup(idx);
          }
        }
        if (typeof prop === "string" && prop[0] === "$") {
          idx = parseInt(prop.slice(1), 10) - 1;
          if (idx >= 0) {
            return lookup(idx);
          }
        }
        return void 0;
      }
    };
    o = new Proxy(directive, handler);
    result = this.process(o);
    if (global.process.env.SOLAR_DEBUG) {
      util = require("util");
      outName = (ref = result.constructor.name) != null ? ref : typeof result;
      console.log("[Solar] result:", outName, util.inspect(result, {
        depth: 3,
        colors: true
      }));
    }
    return result;
  }

  process(o) {
    if (o.$ast != null) {
      return this.processAst(o);
    }
    if (o.$use != null) {
      return this.processUse(o);
    }
    if (o.$ops != null) {
      return this.processOps(o);
    }
    if (o.$arr != null) {
      return this.processArr(o);
    }
    return this.$(o);
  }

  $(value) {
    let key, result, val;
    if (value == null) {
      return value;
    }
    if (typeof value === "number") {
      if (this.currentLookup) {
        return this.currentLookup(value - 1);
      }
      return value;
    }
    if (Array.isArray(value)) {
      return value.map((item) => {
        return this.$(item);
      });
    }
    if (typeof value === "object") {
      if (value.$ast || value.$ops || value.$use || value.$arr) {
        return this.process(value);
      }
      result = {};
      for (key in value) {
        if (!hasProp.call(value, key)) continue;
        val = value[key];
        result[key] = this.$(val);
      }
      return result;
    }
    return value;
  }

  processArr(o) {
    let items;
    items = this.$(o.$arr);
    if (Array.isArray(items)) {
      return items;
    } else {
      return [items];
    }
  }

  processUse(o) {
    let target;
    target = this.$(o.$use);
    if (o.method != null) {
      return typeof target?.[o.method] === "function" ? target[o.method]() : void 0;
    }
    if (o.prop != null) {
      return target?.[o.prop];
    }
    if (o.index != null) {
      return target?.[o.index];
    }
    return target;
  }

  processOps(o) {
    let accessor, body, elseBody, i, ifNode, item, len, loopNode, ref, resolved, result, sourceInfo, util, value;
    switch (o.$ops) {
      case "array":
        result = [];
        if (o.append != null) {
          ref = o.append;
          for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            resolved = this.$(item);
            if (Array.isArray(resolved)) {
              result.push(...resolved);
            } else if (resolved != null) {
              result.push(resolved);
            }
          }
        }
        return result;
      case "if":
        if (o.addElse != null) {
          [ifNode, elseBody] = o.addElse.map((item) => {
            return this.$(item);
          });
          this._ensureLocationData(ifNode);
          this._ensureLocationData(elseBody);
          ifNode.addElse(elseBody);
          return ifNode;
        }
        break;
      case "value":
        if (o.add != null) {
          [value, accessor] = o.add.map((item) => {
            return this.$(item);
          });
          if (value instanceof this.ast.Value) {
            return value.add(accessor);
          } else {
            return this._toValue(value, [accessor]);
          }
        }
        break;
      case "loop":
        if (o.addSource != null) {
          [loopNode, sourceInfo] = o.addSource.map((item) => {
            return this.$(item);
          });
          this._ensureLocationData(loopNode);
          if (sourceInfo != null) {
            this._ensureLocationData(sourceInfo);
          }
          if (loopNode.addSource != null) {
            loopNode.addSource(sourceInfo);
          }
          return loopNode;
        }
        if (o.addBody != null) {
          if (global.process.env.SOLAR_DEBUG) {
            console.log("[Solar] loop.addBody operation:", o.addBody);
          }
          [loopNode, body] = o.addBody.map((item) => {
            return this.$(item);
          });
          if (!(body instanceof this.ast.Block)) {
            body = new this.ast.Block((Array.isArray(body) ? body : [body]));
          }
          if (global.process.env.SOLAR_DEBUG) {
            util = require("util");
            console.log("[Solar] loop.addBody loopNode:", loopNode.constructor.name);
            console.log("[Solar] loop.addBody body:", util.inspect(body, {
              depth: 2,
              colors: true
            }));
          }
          this._ensureLocationData(loopNode);
          this._ensureLocationData(body);
          loopNode.addBody(body);
          return loopNode;
        }
    }
    console.warn("Missing $ops directive handler:", o);
    return new this.ast.Literal(`# Missing $ops directive handler for: ${JSON.stringify(o)}`);
  }

  processAst(o) {
    let args, body, catchNode, condition, context, elseBody, errorVariable, exclusive, expression, expressions, forNode, ifNode, index, invert, name, opValue, operator, options, params, recovery, ref, ref1, tag, type, value, variable, whileNode;
    switch (o.$ast) {
      case "Root":
        body = this.$(o.body);
        if (!(body instanceof this.ast.Block)) {
          body = new this.ast.Block([body]);
        }
        if (this.options.makeReturn) {
          body.makeReturn();
        }
        return new this.ast.Root(body);
      case "Block":
        expressions = this.$(o.expressions);
        if (expressions instanceof this.ast.Block) {
          expressions = expressions.expressions;
        }
        return new this.ast.Block(expressions != null ? expressions : []);
      case "Splat":
        return new this.ast.Splat(this.$(o.name), {
          postfix: this.$(o.postfix)
        });
      case "Literal":
        return new this.ast.Literal(this.$(o.value));
      case "NumberLiteral":
        return new this.ast.NumberLiteral(this.$(o.value));
      case "StringLiteral":
        return new this.ast.StringLiteral(this._stripQuotes(this.$(o.value)));
      case "StringWithInterpolations":
        body = this.$(o.body);
        return new this.ast.StringWithInterpolations((() => {
          switch (false) {
            case !Array.isArray(body):
              return new this.ast.Block(body);
            case !(body instanceof this.ast.Block):
              return body;
            case body == null:
              return new this.ast.Block([body]);
            default:
              return new this.ast.Block([]);
          }
        })());
      case "BooleanLiteral":
        return new this.ast.BooleanLiteral(this.$(o.value));
      case "IdentifierLiteral":
        return new this.ast.IdentifierLiteral(this.$(o.value));
      case "PropertyName":
        return new this.ast.PropertyName(this.$(o.value));
      case "StatementLiteral":
        return new this.ast.StatementLiteral(this.$(o.value));
      case "ThisLiteral":
        return new this.ast.ThisLiteral();
      case "UndefinedLiteral":
        return new this.ast.UndefinedLiteral();
      case "NullLiteral":
        return new this.ast.NullLiteral();
      case "InfinityLiteral":
        return new this.ast.InfinityLiteral();
      case "NaNLiteral":
        return new this.ast.NaNLiteral();
      case "Value":
        return this._toValue(this.$(o.base), (ref = this.$(o.properties)) != null ? ref : []);
      case "Access":
        name = this.$(o.name);
        if (name instanceof this.ast.IdentifierLiteral) {
          name = new this.ast.PropertyName(name.value);
        }
        return new this.ast.Access(name, this.$(o.soak));
      case "Index":
        return new this.ast.Index(this.$(o.index));
      case "Slice":
        return new this.ast.Slice(this.$(o.range));
      case "Op":
        args = o.args.map((arg) => {
          return this.$(arg);
        }) || [];
        if ((o.invertOperator != null) || (o.originalOperator != null)) {
          options = {};
          if (o.invertOperator != null) {
            options.invertOperator = this.$(o.invertOperator);
          }
          if (o.originalOperator != null) {
            options.originalOperator = this.$(o.originalOperator);
          }
          args.push(options);
        }
        return new this.ast.Op(...args);
      case "Assign":
        variable = this.$(o.variable);
        value = this.$(o.value);
        context = this.$(o.context);
        if (context === "object" && variable instanceof this.ast.Value && variable.base instanceof this.ast.ThisLiteral) {
          variable.this = true;
        }
        if (o.operator != null) {
          operator = this.$(o.operator);
          if (operator && operator !== "=") {
            opValue = new this.ast.Op(operator.replace("=", ""), variable, value);
            return new this.ast.Assign(variable, opValue, context);
          } else {
            return new this.ast.Assign(variable, value, context);
          }
        } else {
          options = {};
          if (o.operatorToken) {
            options.operatorToken = this.$(o.operatorToken);
          }
          return new this.ast.Assign(variable, value, context, options);
        }
        break;
      case "If":
        condition = this._ensureLocationData(this.$(o.condition));
        body = this._ensureLocationData(this.$(o.body));
        invert = this.$(o.invert);
        type = invert ? "unless" : this.$(o.type);
        ifNode = new this.ast.If(condition, body, {
          type,
          postfix: this.$(o.postfix)
        });
        if (o.elseBody != null) {
          elseBody = this._ensureLocationData(this.$(o.elseBody));
          ifNode.addElse(elseBody);
        }
        return ifNode;
      case "While":
        whileNode = new this.ast.While(this.$(o.condition), {
          invert: this.$(o.invert),
          guard: this.$(o.guard)
        });
        whileNode.body = (ref1 = whileNode.body) != null ? ref1 : new this.ast.Block([]);
        return whileNode;
      case "For":
        body = this.$(o.body) || [];
        if (Array.isArray(body)) {
          body = body.filter((item) => {
            if ((item != null) && typeof item === "object" && !(item instanceof this.ast.Base) && Object.keys(item).length === 0) {
              return false;
            }
            return true;
          });
        }
        if (!(body instanceof this.ast.Block)) {
          body = new this.ast.Block(body);
        }
        this._ensureLocationData(body);
        name = this.$(o.name);
        index = this.$(o.index);
        forNode = new this.ast.For(body, {
          name,
          index,
          source: this.$(o.source)
        });
        if (o.await != null) {
          forNode.await = this.$(o.await);
        }
        if (o.own != null) {
          forNode.own = this.$(o.own);
        }
        return forNode;
      case "Switch":
        return new this.ast.Switch(this.$(o.subject), this.$(o.cases) || [], this.$(o.otherwise));
      case "When":
        return new this.ast.SwitchWhen(this.$(o.conditions), this.$(o.body));
      case "SwitchWhen":
        return new this.ast.SwitchWhen(this.$(o.conditions), this.$(o.body));
      case "Obj":
        return new this.ast.Obj(this.$(o.properties) || [], this.$(o.generated));
      case "Arr":
        return new this.ast.Arr(this.$(o.objects) || []);
      case "Range":
        exclusive = this.$(o.exclusive);
        tag = exclusive ? "exclusive" : void 0;
        return new this.ast.Range(this.$(o.from), this.$(o.to), tag);
      case "Code":
        params = this.$(o.params) || [];
        body = this.$(o.body);
        if (!(body instanceof this.ast.Block)) {
          body = new this.ast.Block(Array.isArray(body) ? body : [body]);
        }
        return new this.ast.Code(params, body);
      case "Param":
        return new this.ast.Param(this.$(o.name), this.$(o.value), this.$(o.splat));
      case "Call":
        args = this.$(o.args) || [];
        args = args.filter((arg) => {
          if ((arg != null) && typeof arg === "object" && !(arg instanceof this.ast.Base) && Object.keys(arg).length === 0) {
            return false;
          }
          return true;
        });
        return new this.ast.Call(this.$(o.variable), args, this.$(o.soak));
      case "Return":
        return new this.ast.Return(this.$(o.expression));
      case "Yield":
        return new this.ast.Yield(this.$(o.expression) || new this.ast.Value(new this.ast.Literal("")));
      case "Class":
        return new this.ast.Class(this.$(o.variable), this.$(o.parent), this.$(o.body));
      case "ClassProtoAssignOp":
        return new this.ast.ClassProtoAssignOp(this.$(o.variable), this.$(o.value));
      case "Try":
        catchNode = this.$(o.catch);
        return new this.ast.Try(this.$(o.attempt), catchNode, this.$(o.ensure));
      case "Catch":
        recovery = this.$(o.recovery) || this.$(o.body);
        errorVariable = this.$(o.variable) || this.$(o.errorVariable);
        return new this.ast.Catch(recovery, errorVariable);
      case "Throw":
        return new this.ast.Throw(this.$(o.expression));
      case "Existence":
        return new this.ast.Existence(this.$(o.expression));
      case "Parens":
        return new this.ast.Parens(this.$(o.body));
      case "Expansion":
        return new this.ast.Expansion();
      case "ImportDeclaration":
        return new this.ast.ImportDeclaration(this.$(o.clause), this.$(o.source), this.$(o.assertions));
      case "ImportClause":
        return new this.ast.ImportClause(this.$(o.defaultBinding), this.$(o.namedImports));
      case "ImportDefaultSpecifier":
        return new this.ast.ImportDefaultSpecifier(this.$(o.value));
      case "ImportNamespaceSpecifier":
        return new this.ast.ImportNamespaceSpecifier(this.$(o.star), this.$(o.local));
      case "ImportSpecifierList":
        return new this.ast.ImportSpecifierList(this.$(o.specifiers) || []);
      case "ImportSpecifier":
        return new this.ast.ImportSpecifier(this.$(o.imported), this.$(o.local));
      case "DynamicImportCall":
        return new this.ast.DynamicImportCall(this.$(o.variable), this.$(o.args));
      case "DynamicImport":
        return new this.ast.DynamicImport();
      case "ExportDeclaration":
        return new this.ast.ExportDeclaration(this.$(o.clause), this.$(o.source), this.$(o.default));
      case "PassthroughLiteral":
        return new this.ast.Literal(this.$(o.value));
      case "FuncGlyph":
        return new this.ast.Literal(this.$(o.value) || "->");
      case "RegexLiteral":
        return new this.ast.Literal(this.$(o.value));
      case "Interpolation":
        expression = this.$(o.expression);
        if (expression != null) {
          return new this.ast.Interpolation(expression);
        } else {
          return new this.ast.EmptyInterpolation();
        }
        break;
      default:
        console.warn("Unknown $ast type:", o.$ast);
        return new this.ast.Literal(`# Missing AST node: ${o.$ast}`);
    }
  }

}

export default ES6Backend;
