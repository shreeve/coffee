// Generated by CoffeeScript 2.9.0


const LineMap = class LineMap {
  constructor(line1) {
    this.line = line1;
    this.columns = [];
  }

  add(column, [sourceLine, sourceColumn], options = {}) {
    if (this.columns[column] && options.noReplace) {
      return;
    }
    return this.columns[column] = {
      line: this.line,
      column,
      sourceLine,
      sourceColumn
    };
  }

  sourceLocation(column) {
    while (!((mapping = this.columns[column]) || (column <= 0))) {
      column--;
    }
    return mapping && [mapping.sourceLine, mapping.sourceColumn];
  }

};

export class SourceMap {
  constructor() {
    this.lines = [];
  }

  add(sourceLocation, generatedLocation, options = {}) {
    const [line, column] = generatedLocation;
    const lineMap = (this.lines[line] = this.lines[line] || new LineMap(line));
    return lineMap.add(column, sourceLocation, options);
  }

  sourceLocation([line, column]) {
    while (!((lineMap = this.lines[line]) || (line <= 0))) {
      line--;
    }
    return lineMap && lineMap.sourceLocation(column);
  }

  generate(options = {}, code = null) {
    let writingline = 0;
    let lastColumn = 0;
    let lastSourceLine = 0;
    let lastSourceColumn = 0;
    let needComma = false;
    let buffer = "";
    const ref = this.lines;
    for (let lineNumber = i = 0, len = ref.length; i < len; lineNumber = ++i) {
      const lineMap = ref[lineNumber];
      if (lineMap) {
        const ref1 = lineMap.columns;
        for (let j = 0, len1 = ref1.length; j < len1; j++) {
          const mapping = ref1[j];
          if (!(mapping)) {
            continue;
          }
          while (writingline < mapping.line) {
            lastColumn = 0;
            needComma = false;
            buffer = buffer + ";";
            writingline++;
          }
          if (needComma) {
            buffer = buffer + ",";
            needComma = false;
          }
          buffer = buffer + this.encodeVlq(mapping.column - lastColumn);
          lastColumn = mapping.column;
          buffer = buffer + this.encodeVlq(0);
          buffer = buffer + this.encodeVlq(mapping.sourceLine - lastSourceLine);
          lastSourceLine = mapping.sourceLine;
          buffer = buffer + this.encodeVlq(mapping.sourceColumn - lastSourceColumn);
          lastSourceColumn = mapping.sourceColumn;
          needComma = true;
        }
      }
    }
    const v3 = {
      version: 3,
      file: options.generatedFile || '',
      sourceRoot: options.sourceRoot || '',
      sources: options.sourceFiles || [''],
      names: [],
      mappings: buffer
    };
    if (options.inlineMap) {
      v3.sourcesContent = [code];
    }
    return v3;
  }

  encodeVlq(value) {
    const VLQ_SHIFT = 5;
    const VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;
    const VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;
    const signBit = value < 0 ? 1 : 0;
    value = (Math.abs(value) << 1) + signBit;
    let answer = '';
    while (value || !answer) {
      let nextChunk = value & VLQ_VALUE_MASK;
      let value = value >> VLQ_SHIFT;
      if (value) {
        nextChunk = nextChunk | VLQ_CONTINUATION_BIT;
      }
      answer = answer + this.encodeBase64(nextChunk);
    }
    return answer;
  }

  encodeBase64(value) {
    const BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    return BASE64_CHARS[value] || (function() {
      throw new Error(`Cannot Base64 encode value: ${value}`);
    })();
  }

};

SourceMap.sourceMaps = Object.create(null);

SourceMap.registerCompiled = function(filename, source, sourcemap) {
  if (sourcemap != null) {
    return SourceMap.sourceMaps[filename] = sourcemap;
  }
};

SourceMap.getSourceMap = function(filename) {
  return SourceMap.sourceMaps[filename];
};

export const registerCompiled = SourceMap.registerCompiled;

export const getSourceMap = SourceMap.getSourceMap;
