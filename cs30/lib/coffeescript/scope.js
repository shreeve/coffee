// Generated by CoffeeScript 2.9.0


export class Scope {
  constructor(parent, expressions, method, referencedVars) {
    this.parent = parent;
    this.expressions = expressions;
    this.method = method;
    this.referencedVars = referencedVars;
    this.variables = [
      {
        name: 'arguments',
        type: 'arguments'
      }
    ];
    this.comments = {};
    this.positions = {};
    if (!this.parent) {
      this.utilities = {};
    }
    this.root = (ref = (ref1 = this.parent) != null ? ref1.root : void 0) != null ? ref : this;
  }

  add(name, type, immediate) {
    if (this.shared && !immediate) {
      return this.parent.add(name, type, immediate);
    }
    if (Object.prototype.hasOwnProperty.call(this.positions, name)) {
      return this.variables[this.positions[name]].type = type;
    } else {
      return this.positions[name] = this.variables.push({name, type}) - 1;
    }
  }

  namedMethod() {
    if (((ref = this.method) != null ? ref.name : void 0) || !this.parent) {
      return this.method;
    }
    return this.parent.namedMethod();
  }

  find(name, type = 'var') {
    if (this.check(name)) {
      return true;
    }
    this.add(name, type);
    return false;
  }

  parameter(name) {
    if (this.shared && this.parent.check(name, true)) {
      return;
    }
    return this.add(name, 'param');
  }

  check(name) {
    return !!(this.type(name) || ((ref = this.parent) != null ? ref.check(name) : void 0));
  }

  temporary(name, index, single = false) {
    if (single) {
      const startCode = name.charCodeAt(0);
      const endCode = 'z'.charCodeAt(0);
      const diff = endCode - startCode;
      const newCode = startCode + index % (diff + 1);
      const letter = String.fromCharCode(newCode);
      const num = Math.floor(index / (diff + 1));
      return `${letter}${num || ''}`;
    } else {
      return `${name}${index || ''}`;
    }
  }

  type(name) {
    const ref = this.variables;
    for (let i = 0, len = ref.length; i < len; i++) {
      const v = ref[i];
      if (v.name === name) {
        return v.type;
      }
    }
    return null;
  }

  freeVariable(name, options = {}) {
    let index = 0;
    while (true) {
      const temp = this.temporary(name, index, options.single);
      if (!(this.check(temp) || indexOf.call(this.root.referencedVars, temp) >= 0)) {
        break;
      }
      index++;
    }
    if ((ref = options.reserve) != null ? ref : true) {
      this.add(temp, 'var', true);
    }
    return temp;
  }

  assign(name, value) {
    this.add(name, {
      value,
      assigned: true
    }, true);
    return this.hasAssignments = true;
  }

  hasDeclarations() {
    return !!this.declaredVariables().length;
  }

  declaredVariables() {
    return ((function() {
      const ref = this.variables;
      let results = [];
      for (let i = 0, len = ref.length; i < len; i++) {
        const v = ref[i];
        if (v.type === 'var') {
          results.push(v.name);
        }
      }
      return results;
    }).call(this)).sort();
  }

  assignedVariables() {
    const ref = this.variables;
    results = [];
    for (let i = 0, len = ref.length; i < len; i++) {
      const v = ref[i];
      if (v.type.assigned) {
        results.push(`${v.name} = ${v.type.value}`);
      }
    }
    return results;
  }

};
