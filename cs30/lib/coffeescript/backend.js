// Generated by CoffeeScript 2.9.0
import util from 'util';



export class Backend {
  constructor(options1 = {}, ast = {}) {
    this.options = options1;
    this.ast = ast;
    this.currentDirective = null;
    this.currentRule = null;
    this.currentLookup = null;
  }

  _toValue(base, properties) {
    const props = Array.isArray(properties) ? properties : [];
    if (base instanceof this.ast.Value) {
      if (props.length) {
        base.add(props);
      }
      return base;
    }
    return new this.ast.Value(base, props);
  }

  reduce(values, positions, stackTop, symbolCount, directive) {
    this.currentDirective = directive;
    this.currentRule = directive;
    this.currentLookup = function(index) {
      return values[stackTop - symbolCount + 1 + index];
    };
    if (positions && symbolCount > 0) {
      const firstPos = positions[stackTop - symbolCount + 1];
      const lastPos = positions[stackTop];
      if (firstPos && lastPos) {
        this.currentLocationData = {
          first_line: firstPos.first_line,
          first_column: firstPos.first_column,
          last_line_exclusive: (ref = lastPos.last_line_exclusive) != null ? ref : lastPos.last_line,
          last_column_exclusive: (ref1 = lastPos.last_column_exclusive) != null ? ref1 : lastPos.last_column + 1,
          range: [(ref2 = (ref3 = firstPos.range) != null ? ref3[0] : void 0) != null ? ref2 : 0, (ref4 = (ref5 = lastPos.range) != null ? ref5[1] : void 0) != null ? ref4 : 0]
        };
      }
    } else {
      this.currentLocationData = null;
    }
    const handler = {
      get: function(target, prop) {
        if (prop in target) {
          return target[prop];
        }
        if (typeof prop === 'string' && /^\d+$/.test(prop)) {
          let idx = parseInt(prop, 10) - 1;
          if (idx >= 0) {
            return this.currentLookup(idx);
          }
        }
        if (typeof prop === 'string' && prop[0] === '$') {
          idx = parseInt(prop.slice(1), 10) - 1;
          if (idx >= 0) {
            return this.currentLookup(idx);
          }
        }
        return void 0;
      }
    };
    const o = new Proxy(directive, handler);
    const result = this.process(o);
    if (result instanceof this.ast.Base && this.currentLocationData) {
      result.locationData = this.currentLocationData;
      if (typeof result.updateLocationDataIfMissing === "function") {
        result.updateLocationDataIfMissing(this.currentLocationData);
      }
    }
    if ((ref6 = global.process) != null ? (ref7 = ref6.env) != null ? ref7.SOLAR_DEBUG : void 0 : void 0) {
      const outName = (ref8 = result != null ? (ref9 = result.constructor) != null ? ref9.name : void 0 : void 0) != null ? ref8 : typeof result;
      console.log("[Solar] result:", outName, util.inspect(result, {
        depth: 3,
        colors: true
      }));
    }
    return result;
  }

  process(o) {
    if (o.$ast != null) {
      return this.processAst(o);
    }
    if (o.$use != null) {
      return this.processUse(o);
    }
    if (o.$ops != null) {
      return this.processOps(o);
    }
    if (o.$arr != null) {
      return this.processArr(o);
    }
    return this.$(o);
  }

  $(value) {
    if (value == null) {
      return value;
    }
    if (typeof value === 'number') {
      if (this.currentLookup) {
        return this.currentLookup(value - 1);
      }
      return value;
    }
    if (Array.isArray(value)) {
      const results = [];
      for (let i = 0, len = value.length; i < len; i++) {
        const item = value[i];
        const resolved = this.$(item);
        if (resolved == null) {
          continue;
        }
        if (resolved instanceof this.ast.Base) {
          results.push(resolved);
        }
      }
      return results;
    }
    if (typeof value === 'object' && (value != null)) {
      if (value.$ast || value.$ops || value.$use || value.$arr) {
        return this.process(value);
      }
      const result = {};
      for (let key in value) {
        if (!hasProp.call(value, key)) continue;
        const val = value[key];
        result[key] = this.$(val);
      }
      return result;
    }
    return value;
  }

  processArr(o) {
    const items = this.$(o.$arr);
    const result = Array.isArray(items) ? items : [items];
    if (o.implicit != null) {
      result.implicit = !!this.$(o.implicit);
    }
    return result;
  }

  processUse(o) {
    const target = this.$(o.$use);
    if (o.method != null) {
      return target != null ? typeof target[name1 = o.method] === "function" ? target[name1](...((ref = o.args) != null ? ref : [])) : void 0 : void 0;
    }
    if (o.prop != null) {
      return target != null ? target[o.prop] : void 0;
    }
    if (o.index != null) {
      return target != null ? target[o.index] : void 0;
    }
    return target;
  }

  processOps(o) {
    switch (o.$ops) {
      case 'array':
        const result = [];
        if (o.append != null) {
          const ref = o.append;
          for (let i = 0, len = ref.length; i < len; i++) {
            const item = ref[i];
            const resolved = this.$(item);
            if (Array.isArray(resolved)) {
              result.push(...resolved);
            } else if (resolved != null) {
              result.push(resolved);
            }
          }
        }
        return result;
      case 'if':
        if (o.addElse != null) {
          const [ifNode, elseBody] = o.addElse.map((item) => {
            return this.$(item);
          });
          if (elseBody && !elseBody.locationData && this.currentLocationData) {
            elseBody.locationData = this.currentLocationData;
          }
          ifNode.addElse(elseBody);
          return ifNode;
        }
        break;
      case 'value':
        if (o.add != null) {
          const [value, accessor] = o.add.map((item) => {
            return this.$(item);
          });
          if (value instanceof this.ast.Value) {
            return value.add(accessor);
          } else {
            return this._toValue(value, [accessor]);
          }
        }
        break;
      case 'loop':
        if (o.addSource != null) {
          const [loopNode, sourceInfo] = o.addSource.map((item) => {
            return this.$(item);
          });
          if ((loopNode != null ? loopNode.addSource : void 0) != null) {
            loopNode.addSource(sourceInfo);
          }
          return loopNode;
        }
        if (o.addBody != null) {
          if ((ref1 = global.process) != null ? (ref2 = ref1.env) != null ? ref2.SOLAR_DEBUG : void 0 : void 0) {
            console.log("[Solar] loop.addBody operation:", o.addBody);
          }
          const [loopNode, body] = o.addBody.map((item) => {
            return this.$(item);
          });
          body = this.ast.Block.wrap(body);
          if ((ref3 = global.process) != null ? (ref4 = ref3.env) != null ? ref4.SOLAR_DEBUG : void 0 : void 0) {
            console.log("[Solar] loop.addBody loopNode:", loopNode != null ? (ref5 = loopNode.constructor) != null ? ref5.name : void 0 : void 0);
            console.log("[Solar] loop.addBody body:", util.inspect(body, {
              depth: 2,
              colors: true
            }));
          }
          loopNode.addBody(body);
          if (o.postfix != null) {
            loopNode.postfix = this.$(o.postfix);
          }
          return loopNode;
        }
        break;
      case 'prop':
        if (o.set != null) {
          const target = this.$(o.set.target);
          const property = o.set.property;
          value = this.$(o.set.value);
          if (target != null) {
            target[property] = value;
          }
          return target;
        }
    }
    console.warn("Missing $ops directive handler:", o);
    return new this.ast.Literal(`# Missing $ops directive handler for: ${JSON.stringify(o)}`);
  }

  processAst(o) {
    switch (o.$ast) {
      case 'Value':
        let value = this._toValue(this.$(o.base), (ref = this.$(o.properties)) != null ? ref : []);
        if (o.this) {
          value.this = true;
        }
        return value;
      case 'IdentifierLiteral':
        return new this.ast.IdentifierLiteral(this.$(o.value));
      case 'Literal':
        return new this.ast.Literal(this.$(o.value));
      case 'NumberLiteral':
        return new this.ast.NumberLiteral(this.$(o.value), {
          parsedValue: this.$(o.parsedValue)
        });
      case 'StringLiteral':
        return new this.ast.StringLiteral(this.$(o.value), {
          quote: this.$(o.quote),
          initialChunk: this.$(o.initialChunk),
          finalChunk: this.$(o.finalChunk),
          indent: this.$(o.indent),
          double: this.$(o.double),
          heregex: this.$(o.heregex)
        });
      case 'Assign':
        const variable = this.$(o.variable);
        const operator = this.$(o.operator);
        value = this.$(o.value);
        let context = this.$(o.context);
        if (context === 'object' && variable instanceof this.ast.Value && variable.base instanceof this.ast.ThisLiteral) {
          variable.this = true;
        }
        if (operator && (operator !== '=' && operator !== '?=' && operator !== (void 0))) {
          value = new this.ast.Op(operator.slice(0, -1), variable, value);
        }
        if (operator === '?=') {
          context = operator;
        }
        let options = {};
        const ref1 = ['operatorToken', 'moduleDeclaration', 'originalContext'];
        for (let i = 0, len = ref1.length; i < len; i++) {
          const k = ref1[i];
          if (o[k] != null) {
            options[k] = this.$(o[k]);
          }
        }
        return new this.ast.Assign(variable, value, context, options);
      case 'Call':
        return new this.ast.Call(this.$(o.variable), this.$(o.args) || [], this.$(o.soak));
      case 'Op':
        const args = ((ref2 = o.args) != null ? ref2.map((arg) => {
          return this.$(arg);
        }) : void 0) || [];
        if ((o.invertOperator != null) || (o.originalOperator != null)) {
          options = {};
          if (o.invertOperator != null) {
            options.invertOperator = this.$(o.invertOperator);
          }
          if (o.originalOperator != null) {
            options.originalOperator = this.$(o.originalOperator);
          }
          args.push(options);
        }
        return new this.ast.Op(...args);
      case 'Access':
        let name = this.$(o.name);
        if (name instanceof this.ast.IdentifierLiteral) {
          name = new this.ast.PropertyName(name.value);
        }
        return new this.ast.Access(name, {
          soak: this.$(o.soak),
          shorthand: this.$(o.shorthand)
        });
      case 'Index':
        return new this.ast.Index(this.$(o.index));
      case 'PropertyName':
        return new this.ast.PropertyName(this.$(o.value));
      case 'Block':
        const expressions = this.$(o.expressions);
        return new this.ast.Block((expressions instanceof this.ast.Block ? expressions.expressions : expressions) || []);
      case 'Root':
        let body = this.ast.Block.wrap(this.$(o.body));
        if (this.options.makeReturn) {
          body.makeReturn();
        }
        return new this.ast.Root(body);
      case 'If':
        const ifNode = new this.ast.If(this.$(o.condition), this.ast.Block.wrap(this.$(o.body)), {
          type: (this.$(o.invert) ? 'unless' : this.$(o.type)),
          postfix: this.$(o.postfix)
        });
        if (o.elseBody != null) {
          ifNode.addElse(this.ast.Block.wrap(this.$(o.elseBody)));
        }
        return ifNode;
      case 'While':
        const whileNode = new this.ast.While(this.$(o.condition), {
          invert: this.$(o.invert),
          guard: this.$(o.guard),
          isLoop: this.$(o.isLoop)
        });
        whileNode.body = this.ast.Block.wrap(this.$(o.body));
        return whileNode;
      case 'For':
        body = this.ast.Block.wrap(this.$(o.body));
        const forNode = new this.ast.For(body, {
          name: this.$(o.name),
          index: this.$(o.index),
          source: this.$(o.source)
        });
        const ref3 = ['await', 'awaitTag', 'own', 'ownTag', 'step', 'from', 'object', 'guard'];
        for (let j = 0, len1 = ref3.length; j < len1; j++) {
          const k = ref3[j];
          if (o[k] != null) {
            forNode[k] = this.$(o[k]);
          }
        }
        return forNode;
      case 'Return':
        return new this.ast.Return(this.$(o.expression));
      case 'Code':
        return new this.ast.Code(this.$(o.params) || [], this.ast.Block.wrap(this.$(o.body)), this.$(o.funcGlyph), this.$(o.paramStart));
      case 'FuncGlyph':
        return new this.ast.FuncGlyph(this.$(o.glyph) || this.$(o.value) || '->');
      case 'Class':
        return new this.ast.Class(this.$(o.variable), this.$(o.parent), this.$(o.body));
      case 'Param':
        name = this.$(o.name);
        if (name instanceof this.ast.Value && name.base instanceof this.ast.ThisLiteral) {
          name.this = true;
        }
        return new this.ast.Param(name, this.$(o.value), this.$(o.splat));
      case 'Obj':
        return new this.ast.Obj(this.$(o.properties) || [], this.$(o.generated));
      case 'Arr':
        return new this.ast.Arr(this.$(o.objects) || []);
      case 'Range':
        return new this.ast.Range(this.$(o.from), this.$(o.to), this.$(o.exclusive) ? 'exclusive' : void 0);
      case 'Slice':
        return new this.ast.Slice(this.$(o.range));
      case 'Expansion':
        return new this.ast.Expansion();
      case 'BooleanLiteral':
        return new this.ast.BooleanLiteral(this.$(o.value), {
          originalValue: this.$(o.originalValue)
        });
      case 'ThisLiteral':
        return new this.ast.ThisLiteral();
      case 'NullLiteral':
        return new this.ast.NullLiteral();
      case 'UndefinedLiteral':
        return new this.ast.UndefinedLiteral();
      case 'RegexLiteral':
        return new this.ast.RegexLiteral(this.$(o.value), {
          delimiter: this.$(o.delimiter),
          heregexCommentTokens: this.$(o.heregexCommentTokens)
        });
      case 'PassthroughLiteral':
        return new this.ast.PassthroughLiteral(this.$(o.value), {
          here: this.$(o.here),
          generated: this.$(o.generated)
        });
      case 'StatementLiteral':
        return new this.ast.StatementLiteral(this.$(o.value));
      case 'ComputedPropertyName':
        return new this.ast.ComputedPropertyName(this.$(o.expression) || this.$(o.name) || this.$(o.value));
      case 'StringWithInterpolations':
        return new this.ast.StringWithInterpolations(this.ast.Block.wrap(this.$(o.body)));
      case 'Interpolation':
        const expression = this.$(o.expression);
        if (expression != null) {
          return new this.ast.Interpolation(expression);
        } else {
          return new this.ast.EmptyInterpolation();
        }
        break;
      case 'Switch':
        return new this.ast.Switch(this.$(o.subject), this.$(o.cases) || [], this.$(o.otherwise));
      case 'SwitchWhen':
        return new this.ast.SwitchWhen([].concat(this.$(o.conditions)), this.$(o.body));
      case 'Super':
        return new this.ast.Super(this.$(o.accessor), this.$(o.superLiteral));
      case 'SuperCall':
        return new this.ast.SuperCall(this.$(o.variable), this.$(o.args) || [], this.$(o.soak));
      case 'Existence':
        return new this.ast.Existence(this.$(o.expression));
      case 'Parens':
        return new this.ast.Parens(this.$(o.body));
      case 'Splat':
        return new this.ast.Splat(this.$(o.name), {
          postfix: this.$(o.postfix)
        });
      case 'Try':
        return new this.ast.Try(this.$(o.attempt), this.$(o.catch), this.$(o.ensure), {
          finallyTag: this.$(o.finallyTag)
        });
      case 'Catch':
        return new this.ast.Catch(this.$(o.recovery) || this.$(o.body), this.$(o.variable) || this.$(o.errorVariable));
      case 'Throw':
        return new this.ast.Throw(this.$(o.expression));
      case 'ImportDeclaration':
        return new this.ast.ImportDeclaration(this.$(o.clause), this.$(o.source));
      case 'ImportClause':
        return new this.ast.ImportClause(this.$(o.defaultBinding), this.$(o.namedImports));
      case 'ImportSpecifierList':
        return new this.ast.ImportSpecifierList(this.$(o.specifiers) || []);
      case 'ImportSpecifier':
        return new this.ast.ImportSpecifier(this.$(o.imported), this.$(o.local));
      case 'ImportDefaultSpecifier':
        return new this.ast.ImportDefaultSpecifier(this.$(o.name) || this.$(o.value) || this.$(o));
      case 'ImportNamespaceSpecifier':
        return new this.ast.ImportNamespaceSpecifier(this.$(o.star), this.$(o.local));
      case 'ExportNamedDeclaration':
        return new this.ast.ExportNamedDeclaration(this.$(o.clause), this.$(o.source), this.$(o.assertions));
      case 'ExportDefaultDeclaration':
        return new this.ast.ExportDefaultDeclaration(this.$(o.declaration) || this.$(o.value));
      case 'ExportAllDeclaration':
        return new this.ast.ExportAllDeclaration(this.$(o.exported), this.$(o.source), this.$(o.assertions));
      case 'ExportSpecifierList':
        return new this.ast.ExportSpecifierList(this.$(o.specifiers) || []);
      case 'ExportSpecifier':
        return new this.ast.ExportSpecifier(this.$(o.value || o.local), this.$(o.exported));
      case 'InfinityLiteral':
        return new this.ast.InfinityLiteral();
      case 'NaNLiteral':
        return new this.ast.NaNLiteral();
      case 'DefaultLiteral':
        return new this.ast.DefaultLiteral(this.$(o.value) || 'default');
      case 'YieldReturn':
        return new this.ast.YieldReturn(this.$(o.expression), {
          returnKeyword: this.$(o.returnKeyword)
        });
      case 'AwaitReturn':
        return new this.ast.AwaitReturn(this.$(o.expression), {
          returnKeyword: this.$(o.returnKeyword)
        });
      case 'DynamicImportCall':
        return new this.ast.DynamicImportCall(this.$(o.variable), this.$(o.args) || []);
      case 'DynamicImport':
        return new this.ast.DynamicImport();
      case 'TaggedTemplateCall':
        return new this.ast.TaggedTemplateCall(this.$(o.variable), this.$(o.template), this.$(o.soak));
      case 'MetaProperty':
        return new this.ast.MetaProperty(this.$(o.identifier), this.$(o.accessor));
      case 'RegexWithInterpolations':
        return new this.ast.RegexWithInterpolations(this.$(o.invocation), {
          heregexCommentTokens: this.$(o.heregexCommentTokens)
        });
      case 'Elision':
        return new this.ast.Elision();
      default:
        console.warn("Unknown $ast type:", o.$ast);
        return new this.ast.Literal(`# Missing AST node: ${o.$ast}`);
    }
  }

};
