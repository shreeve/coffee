# ==============================================================================
# ES6 Backend - Solar Directive Processor for CoffeeScript
# ==============================================================================
#
# Converts Solar directives (pure data) to CoffeeScript AST node instances
# 
# Solar directives are generated by the parser from Solar syntax.coffee rules:
#   o 'IDENTIFIER', $ast: 'IdentifierLiteral', value: 1
# 
# This backend converts those directives into actual CoffeeScript AST nodes:
#   new nodes.IdentifierLiteral(tokenValue)
#
# The resulting AST nodes use the existing CoffeeScript compiler pipeline.
# ==============================================================================

class ES6Backend
  constructor: (@options = {}) ->
    # Future: compilation options, analysis settings, etc.
    @compileOptions =
      bare: @options.bare ? true
      header: @options.header ? false

  # Main entry point called by r() function in generated parser
  # Converts Solar directives to CoffeeScript AST node instances
  reduce: (values, positions, stackTop, symbolCount, directive) ->
    # Build frame from parser stacks (same pattern as working implementation)
    frame = []
    for i in [0...symbolCount]
      offset = stackTop - symbolCount + i + 1
      frame.push {
        value: values[offset]
        pos: positions[offset]
      }

    # Evaluate Solar directive and return AST node
    @evaluateDirective directive, frame

  # Core Solar directive evaluator
  evaluateDirective: (directive, frame) ->
    # Import nodes on demand to avoid circular dependencies
    nodes = require './nodes'

    # Handle position references (1, 2, 3, ...) 
    if typeof directive is 'number'
      return frame[directive - 1]?.value  # 1-based â†’ 0-based

    # Handle primitives
    return directive if typeof directive in ['string', 'boolean']

    # Handle arrays
    if Array.isArray directive
      return directive.map (item) => @evaluateDirective item, frame

    # Handle Solar directives (objects with special properties)
    if directive? and typeof directive is 'object'

      # $ast directive - create AST node
      if directive.$ast?
        nodeType = directive.$ast
        
        switch nodeType
          when 'Root'
            body = @evaluateDirective directive.body, frame
            bodyArray = if Array.isArray(body) then body else [body]
            filteredBody = bodyArray.filter (item) -> item?
            new nodes.Root new nodes.Block filteredBody

          when 'IdentifierLiteral'
            value = @evaluateDirective directive.value, frame
            new nodes.IdentifierLiteral value

          when 'Literal'
            value = @evaluateDirective directive.value, frame  
            new nodes.Literal value
            
          else
            # Fallback for unimplemented node types
            console.warn "ES6Backend: Unimplemented AST node type:", nodeType
            new nodes.Literal "/* Unimplemented: #{nodeType} */"

      # $ary directive - return array
      else if directive.$ary?
        items = @evaluateDirective directive.$ary, frame
        if Array.isArray(items) then items else [items]

      # $use directive - use existing value
      else if directive.$use?
        @evaluateDirective directive.$use, frame

      # $ops directive - operation (array append, etc.)
      else if directive.$ops?
        console.warn "ES6Backend: $ops not yet implemented:", directive.$ops
        new nodes.Literal "/* $ops: #{directive.$ops} */"

      else
        # Unknown directive
        console.warn "ES6Backend: Unknown directive:", directive
        new nodes.Literal "/* Unknown directive */"

    else
      # Fallback for unexpected input
      new nodes.Literal "/* Unexpected input */"

module.exports = ES6Backend
