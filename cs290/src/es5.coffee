# ==============================================================================
# ES5 Backend - Solar Directive Processor for CoffeeScript
# ==============================================================================
#
# Converts Solar directives (pure data) to CoffeeScript AST node instances
#
# Solar directives are generated by the parser from Solar syntax.coffee rules:
#   o 'IDENTIFIER', $ast: 'IdentifierLiteral', value: 1
#
# This backend converts those directives into actual CoffeeScript AST nodes:
#   new nodes.IdentifierLiteral(tokenValue)
#
# The resulting AST nodes use the existing CoffeeScript compiler pipeline.
# ==============================================================================

class ES5Backend
  constructor: (@options = {}, @ast = {}) ->
    # @ast contains AST node class definitions (constructors)
    # @options contains compilation options, analysis settings, etc.
    @compileOptions =
      bare: @options.bare ? true
      header: @options.header ? false

  # Main entry point called by r() function in generated parser
  # Converts Solar directives to CoffeeScript AST node instances
  reduce: (values, positions, stackTop, symbolCount, directive) ->
    console.log "üîç REDUCE:", JSON.stringify(directive), "symbolCount:", symbolCount

    # For $ast directives, build hybrid function-object
    if directive.$ast?
      # Make o BOTH a function and an object:
      console.log "üîç STACK INFO: stackTop:", stackTop, "symbolCount:", symbolCount, "values.length:", values.length
      console.log "üîç VALUES:", values?.slice(Math.max(0, stackTop - 5), stackTop + 2)
      $ = o = (index) ->
        pos = stackTop - symbolCount + 1 + index  # ‚Üê Add +1 offset
        console.log "üîç o(#{index}) ‚Üí values[#{pos}] =", values[pos]
        values[pos]
      for prop, value of directive
        if typeof value is 'number'
          resolved = o(value - 1)
          console.log "üîç RESOLVING #{prop}:#{value} ‚Üí o(#{value - 1}) =", resolved
          o[prop] = resolved
        else
          o[prop] = value
      console.log "üîç BUILT o:", typeof o, "isFunction:", typeof o is 'function', "o.$ast:", o.$ast
      @resolve o
    else
      # Simple directives: just resolve directly
      @resolve directive

  # Core Solar directive resolver
  resolve: (o) ->
    console.log "üîç RESOLVE START:", typeof o, "isFunction:", typeof o is 'function', JSON.stringify(o)?[0..50]
    return o if typeof o is 'number'
    return o if typeof o in ['string', 'boolean']

    # Handle arrays
    if Array.isArray o
      return o.map (item) => @resolve item

    # Handle Solar directives (objects with special properties)
    if o? and (typeof o is 'object' or typeof o is 'function')
      console.log "üîç RESOLVE:", "type:", typeof o, "isFunction:", typeof o is 'function', "hasAst:", !!o.$ast

      # $ast directive - create AST node
      if o.$ast?
        console.log "üîç $ast directive:", o.$ast
        nodeType = o.$ast

        switch nodeType
          when 'Root'
            console.log "üîç Root processing, o.body:", o.body
            body = @resolve o.body
            console.log "üîç Root body resolved:", body
            bodyArray = if Array.isArray(body) then body else [body]
            filteredBody = bodyArray.filter (item) -> item?
            console.log "üîç Root filtered body:", filteredBody
            block = new @ast.Block filteredBody
            block.makeReturn() if filteredBody.length > 0  # Make final expression return
            result = new @ast.Root block
            console.log "üîç Root result:", result
            result

          when 'IdentifierLiteral' then new @ast.IdentifierLiteral o(0)
          when 'NumberLiteral'     then new @ast.NumberLiteral     o(0)
          when 'Value'             then new @ast.Value             o(0)
          when 'Assign'            then new @ast.Assign            o.variable, o.value
          when 'Op'                then new @ast.Op                o.operator, o(1), o(2)
          when 'Literal'           then new @ast.Literal           o(0)

          else
            # Fallback for unimplemented node types
            console.warn "ES5Backend: Unimplemented AST node type:", nodeType
            new @ast.Literal "/* Unimplemented: #{nodeType} */"

      # $ary directive - return array
      else if o.$ary?
        console.log "üîç $ary directive:", o.$ary
        items = @resolve o.$ary
        if Array.isArray(items) then items else [items]

      # $use directive - use existing value
      # TODO: This isn't enough, see: {$use: 2, method: 'toString'}
      else if o.$use?
        console.log "üîç $use directive:", o.$use
        @resolve o.$use

      # $ops directive - operation (array append, etc.)
      else if o.$ops?
        console.log "üîç $ops directive:", o.$ops
        console.warn "ES5Backend: $ops not yet implemented:", o.$ops
        new @ast.Literal "/* $ops: #{o.$ops} */"

      else
        # Unknown directive
        console.log "üîç Unknown directive:", JSON.stringify(o)
        console.warn "ES5Backend: Unknown directive:", o
        new @ast.Literal "/* Unknown directive */"

    else
      # Fallback for unexpected input
      new @ast.Literal "/* Unexpected input */"

module.exports = ES5Backend
