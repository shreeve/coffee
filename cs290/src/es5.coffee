# ==============================================================================
# ES5 Backend - Solar Directive Processor for CoffeeScript
# ==============================================================================
#
# Converts Solar directives (pure data) to CoffeeScript AST node instances
#
# Solar directives are generated by the parser from Solar syntax.coffee rules:
#   o 'IDENTIFIER', $ast: 'IdentifierLiteral', value: 1
#
# This backend converts those directives into actual CoffeeScript AST nodes:
#   new nodes.IdentifierLiteral(tokenValue)
#
# The resulting AST nodes use the existing CoffeeScript compiler pipeline.
# ==============================================================================

class ES5Backend
  constructor: (@options = {}, @ast = {}) ->
    # Use Object.create(null) to avoid prototype pollution in options
    @compileOptions = Object.create null
    @compileOptions.bare = @options.bare ? true
    @compileOptions.header = @options.header ? false

  # ----------------------------------------------------------------------------
  # Helpers
  # ----------------------------------------------------------------------------

  # Add minimal location data to node to avoid errors in AST operations
  _addLocationData: (node) ->
    return node unless node?
    # Only add location data to objects, not primitives
    if typeof node is 'object' and node isnt null
      node.locationData ?= {first_line: 0, first_column: 0, last_line: 0, last_column: 0, range: [0, 0]}
    node

  # Ensure a node is a Value; if already a Value, return as-is
  _asValue: (node) ->
    return null unless node?
    return node if node instanceof @ast.Value
    new @ast.Value node

  # Append an Access (with optional soak) to a value-ish LHS
  _appendAccess: (lhs, name, soak) ->
    return null unless name?
    # Normalize name into a PropertyName when needed
    if typeof name is 'string'
      name = new @ast.PropertyName name
    else if name? and not (name instanceof @ast.PropertyName) and name?.value?
      name = new @ast.PropertyName String(name.value)
    node = new @ast.Access name, {soak}
    if lhs?
      lhs = @_asValue(lhs) unless lhs instanceof @ast.Value
      lhs.properties.push node
      lhs
    else
      node

  # Append an Index to a value-ish LHS
  _appendIndex: (lhs, indexExpr) ->
    return null unless indexExpr?
    node = new @ast.Index indexExpr
    if lhs?
      lhs = @_asValue(lhs) unless lhs instanceof @ast.Value
      lhs.properties.push node
      lhs
    else
      node

  # Build a Value from base + properties array (already resolved)
  _buildValue: (base, properties) ->
    if base instanceof @ast.Value
      props = @_filterNodes (if Array.isArray(properties) then properties else [])
      if props.length then base.add props
      return base
    base = @_ensureNode(base) if base? and not (base instanceof @ast.Base)
    props = @_filterNodes (if Array.isArray(properties) then properties else [])
    if props.length then new @ast.Value base, props else new @ast.Value base

  # Helper to ensure value is a proper node
  _ensureNode: (value) ->
    return null unless value?
    return value if value?.compileToFragments or value instanceof @ast.Base
    # Handle primitives
    if typeof value in ['string', 'number', 'boolean']
      return new @ast.Literal String(value)
    # Handle objects with .value property
    if value?.value?
      return new @ast.PropertyName value.value
    null

  # Helper to filter and ensure all items are nodes
  _filterNodes: (array) ->
    return [] unless array?
    result = []
    for item in array
      node = if item instanceof @ast.Base then item else @_ensureNode(item)
      result.push node if node?
    result

  # Normalize an array-like into AST nodes (ensures array, resolves and filters)
  _nodes: (xs) ->
    xs = if Array.isArray(xs) then xs else (if xs? then [xs] else [])
    @_filterNodes xs

  # Helper to check if value is a plain object
  _isPlainObject: (x) ->
    return false unless x? and typeof x is 'object'
    p = Object.getPrototypeOf x
    p is Object.prototype or p is null

  # Strip surrounding quotes from a string literal
  _stripQuotes: (value) ->
    return value unless value?.length >= 2 and typeof value is 'string'
    if (value[0] is '"' and value[value.length-1] is '"') or (value[0] is "'" and value[value.length-1] is "'")
      value.slice(1, -1)
    else
      value

  # Convert value to a Block node
  _toBlock: (value) ->
    block =
      if Array.isArray(value)
        nodes = @_filterNodes(value)
        # Ensure all nodes in block have location data
        nodes = nodes.map (n) => @_addLocationData(n)
        new @ast.Block nodes
      else if value instanceof @ast.Block
        # Ensure existing block expressions have location data
        if value.expressions?
          value.expressions = value.expressions.map (n) => @_addLocationData(n)
        value
      else if value?
        node = @_ensureNode(value)
        @_addLocationData node if node?
        new @ast.Block [node].filter (n) -> n?
      else
        new @ast.Block []
    @_addLocationData block

  # Unimplemented marker
  _unimplemented: (type, context = "") ->
    console.warn "ES5Backend: Unimplemented#{if context then " #{context}" else ""}:", type
    new @ast.Literal "/* Unimplemented: #{type} */"

  # ----------------------------------------------------------------------------
  # Entry points
  # ----------------------------------------------------------------------------

  reduce: (values, positions, stackTop, symbolCount, directive) ->
    lookup = (index) -> values[stackTop - symbolCount + 1 + index]
    util = null

    # Debug directives when SOLAR_DEBUG is set
    if process?.env?.SOLAR_DEBUG
      util = require 'util'
      rhs = (values[stackTop - symbolCount + 1 + i] for i in [0...symbolCount])
      console.log "\n[Solar] directive:", util.inspect(directive, {depth: 4, colors: true})
      console.log "[Solar] rhs:", util.inspect(rhs, {depth: 1, colors: true})

    # Use Object.create(null) to avoid pollution and JS property conflicts
    store = Object.create null

    handler =
      apply: (target, thisArg, args) -> target.apply thisArg, args
      get: (target, prop, receiver) ->
        return store[prop] if Object.prototype.hasOwnProperty.call(store, prop)
        # Avoid leaking function/meta props from the Proxy target
        return undefined if prop in ['name', 'length', 'prototype', 'caller', 'arguments', 'constructor', 'toString', 'valueOf']
        Reflect.get target, prop, receiver
      set: (target, prop, value) -> store[prop] = value; true
      has: (target, prop) -> Object.prototype.hasOwnProperty.call(store, prop) or prop of target
      ownKeys: (target) -> Reflect.ownKeys(store).concat Reflect.ownKeys(target)
      getOwnPropertyDescriptor: (target, prop) ->
        if Object.prototype.hasOwnProperty.call(store, prop)
          value: store[prop]
          configurable: true
          enumerable: true
          writable: true
        else
          Object.getOwnPropertyDescriptor target, prop

    # Copy directive props, resolving positional references now
    o = new Proxy lookup, handler
    for own prop, value of directive
      o[prop] = if typeof value is 'number' then lookup(value - 1) else value

    res = @resolve o
    if process?.env?.SOLAR_DEBUG
      util = util or require 'util'
      outName = res?.constructor?.name ? typeof res
      console.log "[Solar] result:", outName, util.inspect(res, {depth: 3, colors: true})
    res

  resolve: (o, lookup = o) ->
    return o unless o?  # null/undefined

    type = typeof o

    # Numbers: do 1-based lookup for positive integers only
    if type is 'number'
      if Number.isInteger(o) and o > 0 and typeof lookup is 'function'
        result = lookup(o - 1)
        return result
      return o

    # Strings and booleans return as-is
    return o if type is 'string' or type is 'boolean'

    # Arrays: resolve items and skip nullish
    if Array.isArray o
      result = []
      for val in o
        resolved = @resolve val, lookup
        result.push resolved if resolved?
      return result

    # Bare functions without directive markers are terminals
    if type is 'function' and not (o.$ast? or o.$use? or o.$ary? or o.$ops?)
      return o

    # Objects and directive-bearing functions
    if type is 'object' or type is 'function'
      return o if o.constructor? and o.constructor not in [Object, Function]

      $ = (val) => @resolve val, lookup  # local resolver

      if o.$ast?
        nodeType = o.$ast

        switch nodeType
          when 'Root'               then new @ast.Root ((b) -> b.makeReturn(); b)(new @ast.Block $(o.body))
          when 'IdentifierLiteral'  then new @ast.IdentifierLiteral  $(o.value)
          when 'NumberLiteral'      then new @ast.NumberLiteral      $(o.value)
          when 'StringLiteral'      then new @ast.StringLiteral      @_stripQuotes($(o.value))
          when 'BooleanLiteral'     then new @ast.BooleanLiteral     $(o.value)
          when 'ThisLiteral'        then new @ast.ThisLiteral()
          when 'NullLiteral'        then new @ast.NullLiteral
          when 'UndefinedLiteral'   then new @ast.UndefinedLiteral
          when 'InfinityLiteral'    then new @ast.InfinityLiteral
          when 'NaNLiteral'         then new @ast.NaNLiteral

          # ---- Refactored to helpers ----------------------------------------
          when 'Value'
            base = $(o.value) ? $(o.val)
            props = $(o.properties) ? []
            @_buildValue base, props

          when 'Access'
            @_appendAccess $(o.variable), $(o.name), $(o.soak)

          when 'Index'
            @_appendIndex ($(o.variable) or $(o.val) or $(o.base)), ($(o.index) or $(o.object))
          # -------------------------------------------------------------------

          when 'Call'
            callee = @_asValue($(o.variable))
            args = $(o.args) ? []
            args = (a for a in args when a?)
            new @ast.Call callee, args, $(o.soak), $(o.token)
          when 'Obj'                then new @ast.Obj          $(o.properties), $(o.generated)
          when 'Arr'                then new @ast.Arr          $(o.objects)
          when 'Range'              then new @ast.Range        $(o.from), $(o.to), (if $(o.exclusive) then 'exclusive' else null)
          when 'Block'              then new @ast.Block        $(o.expressions)
          when 'Return'             then new @ast.Return       $(o.expression)
          when 'Op'
            args = o.args.map (arg) -> $(arg)
            if o.invertOperator? or o.originalOperator?
              args.push {
                invertOperator: $(o.invertOperator) if o.invertOperator?
                originalOperator: $(o.originalOperator) if o.originalOperator?
              }
            new @ast.Op args...
          when 'Parens'             then new @ast.Parens       (@_toBlock($(o.body)) ? new @ast.Block [new @ast.Literal ''])
          when 'PropertyName'       then new @ast.PropertyName $(o.value)
          when 'Slice'              then new @ast.Slice        $(o.range)
          when 'If'
            condition = $(o.condition)
            body = @_toBlock($(o.body))
            elseBody = if o.elseBody? then @_toBlock($(o.elseBody)) else null
            tmp = if $(o.type)?.toString?() is 'unless' then 'unless' else 'if'
            ifNode = new @ast.If condition, body, {type: tmp}
            @_addLocationData ifNode
            if elseBody?.expressions?.length > 0
              @_addLocationData elseBody
              ifNode.addElse elseBody
            ifNode
          when 'While'
            condition = $(o.condition)
            opts = {}
            opts.guard = $(o.guard) if o.guard?
            opts.isLoop = $(o.isLoop) if o.isLoop?
            opts.invert = $(o.invert) if o.invert?
            whileNode = new @ast.While condition, opts
            # Body will be added later via $ops: 'loop' addBody
            # But if body is provided directly (e.g., from Loop rule), use it
            if o.body?
              whileNode.body = @_toBlock($(o.body))
            else
              # Initialize with empty block to avoid undefined errors
              whileNode.body = new @ast.Block []
            @_addLocationData whileNode
            whileNode
          when 'For'
            # Create For node with initial source properties
            body = @_toBlock($(o.body)) || new @ast.Block []
            source = {}

            # Handle name and index - they may come from $use directives
            name = $(o.name)
            index = $(o.index)

            # Ensure name and index are proper nodes if they exist
            if name?
              source.name = @_ensureNode(name)
            if index?
              source.index = @_ensureNode(index)

            # Add other properties
            source.await = $(o.await) if o.await?
            source.awaitTag = $(o.awaitTag) if o.awaitTag?
            source.own = $(o.own) if o.own?
            source.ownTag = $(o.ownTag) if o.ownTag?
            source.step = $(o.step) if o.step?
            source.source = $(o.source) if o.source?

            new @ast.For body, source
          when 'Switch'               then new @ast.Switch               $(o.subject), @_nodes($(o.cases)), @_toBlock($(o.otherwise))
          when 'SwitchWhen'           then new @ast.SwitchWhen           @_nodes($(o.conditions)), @_toBlock($(o.body))
          when 'ComputedPropertyName' then new @ast.ComputedPropertyName $(o.value)
          when 'DefaultLiteral'       then new @ast.DefaultLiteral       $(o.value)
          when 'Elision'              then new @ast.Elision
          when 'Expansion'            then new @ast.Expansion
          when 'Try'                  then new @ast.Try                  @_toBlock($(o.attempt)), $(o.catch), @_toBlock($(o.ensure))
          when 'Class'                then new @ast.Class                $(o.variable), $(o.parent), $(o.body)
          when 'FuncGlyph'            then new @ast.FuncGlyph            $(o.glyph)
          when 'Param'                then new @ast.Param                $(o.name), $(o.value), $(o.splat)
          when 'Code'                 then new @ast.Code                 ($(p) for p in $(o.params) ? [] when $(p)?), @_toBlock($(o.body)), $(o.funcGlyph), $(o.paramStart)
          when 'Splat'                then new @ast.Splat                $(o.name)
          when 'Existence'            then new @ast.Existence            $(o.expression)
          when 'RegexLiteral'         then new @ast.RegexLiteral         $(o.value)
          when 'StatementLiteral'     then new @ast.StatementLiteral     $(o.value)
          when 'PassthroughLiteral'   then new @ast.PassthroughLiteral   $(o.value)
          when 'Interpolation'
            expression = $(o.expression)
            actualExpression = if Array.isArray(expression) and expression.length > 0 then expression[0] else expression
            expressionNode =
              if actualExpression instanceof @ast.Base then actualExpression
              else if actualExpression? then @_ensureNode(actualExpression)
              else new @ast.Literal '""' # avoid ${} syntax error
            new @ast.Interpolation expressionNode
          when 'StringWithInterpolations'
            body = $(o.body)
            quote = $(o.quote)
            bodyNode =
              if Array.isArray(body)
                bodyNodes = body.map (b) => if b instanceof @ast.Base then b else @_ensureNode(b)
                new @ast.Block @_filterNodes(bodyNodes)
              else if body instanceof @ast.Block then body
              else if body? then new @ast.Block [@_ensureNode(body)]
              else new @ast.Block []
            new @ast.StringWithInterpolations bodyNode, {quote}
          when 'Catch'                then new @ast.Catch              @_toBlock($(o.recovery) or $(o.body)), $(o.variable) or $(o.errorVariable)
          when 'Throw'                then new @ast.Throw              $(o.expression)
          when 'Literal'              then new @ast.Literal            $(o.value)
          when 'Assign'
            variable = $(o.variable)
            value = $(o.value)
            context = $(o.context)
            operator = $(o.operator)
            if context is 'object' and o.expression?
              # In object context, 'value' is the property name, 'expression' is the actual value
              variable = $(o.value)
              value = $(o.expression)
              variable = @_asValue variable
            return null unless variable? and value?
            # Pass operator for compound assignments like +=, -=, etc.
            new @ast.Assign variable, value, operator || context
          else
            @_unimplemented nodeType, "AST node type"

      else if o.$ary?
        items = $(o.$ary)
        items = if Array.isArray(items) then items else [items]
        items.filter (item) -> item?

      else if o.$use?
        # $use supports 'token' or nested directive
        if o.$use is 'token'
          if typeof lookup is 'function' and lookup.value?
            resolvedValue = lookup.value
          else
            resolvedValue = lookup(0)?.value ? 'unknown_token'
        else
          resolvedValue = $(o.$use)
        if o.method?
          resolvedValue = resolvedValue[o.method]?() ? resolvedValue
        else if o.prop?
          resolvedValue = resolvedValue[o.prop] ? resolvedValue
        else if o.index?
          resolvedValue = resolvedValue[o.index] ? resolvedValue
        resolvedValue

      else if o.$ops?
        switch o.$ops
          when 'value'
            # Add accessor/property to Value node
            if o.add?
              target = $(o.add[0])
              accessor = $(o.add[1])
              target = @_asValue target
              target.add [accessor] if accessor?.traverseChildren?
              target
            else
              @_unimplemented "$ops value without add", "$ops"

          when 'array'
            if o.append?
              target = $(o.append[0])
              target = [] unless Array.isArray target
              for item in o.append[1..] when item?
                resolved = $(item)
                if Array.isArray(resolved) then target = target.concat resolved else target.push resolved
              target
            else if o.gather?
              result = []
              for item in o.gather when item?
                resolved = $(item)
                if Array.isArray(resolved) then result = result.concat resolved
                else if resolved? then result.push resolved
              result
            else
              @_unimplemented "$ops array without append/gather", "$ops"

          when 'if'
            if o.addElse?
              ifNode = $(o.addElse[0])
              elseBody = $(o.addElse[1])
              if ifNode instanceof @ast.If and elseBody?
                @_addLocationData ifNode
                @_addLocationData elseBody
                ifNode.addElse elseBody
              ifNode
            else
              @_unimplemented "$ops if without addElse", "$ops"

          when 'loop'
            if o.addSource?
              loopNode = $(o.addSource[0])
              sourceInfo = $(o.addSource[1])
              if loopNode
                @_addLocationData loopNode
                @_addLocationData sourceInfo if sourceInfo
                loopNode.addSource sourceInfo
              loopNode
            else if o.addBody?
              loopNode = $(o.addBody[0])
              bodyArg = o.addBody[1]

              # Handle "Body $N" placeholder strings
              if typeof bodyArg is 'string' and bodyArg.startsWith('Body $')
                position = parseInt(bodyArg.slice(6))
                body = $(position)  # Evaluate position reference
              else
                body = $(bodyArg)

              if loopNode
                # Convert body to proper Block if needed
                bodyBlock = if body?
                  if Array.isArray(body)
                    new @ast.Block @_filterNodes(body)
                  else if body instanceof @ast.Block
                    body
                  else
                    new @ast.Block [@_ensureNode(body)].filter (n) -> n?
                else
                  new @ast.Block []

                @_addLocationData loopNode
                @_addLocationData bodyBlock
                loopNode.addBody bodyBlock
              loopNode
            else
              @_unimplemented "$ops loop without addSource/addBody", "$ops"

          when 'prop'
            if o.set?
              target = $(o.set.target)
              if o.set.property? and target? then target[o.set.property] = $(o.set.value)
              target
            else if o.addProp?
              target = $(o.addProp[0])
              property = $(o.addProp[1])
              target.add [property] if target instanceof @ast.Value
              target
            else
              @_unimplemented "$ops prop without set/addProp", "$ops"

          else
            @_unimplemented o.$ops, "$ops type"

      else
        if @_isPlainObject o
          return null unless Object.keys(o).length
          out = Object.create null
          out[k] = $(v) for [k, v] in Object.entries o
          return out

        # Finally, give up...
        @_unimplemented o, "directive"

    else
      new @ast.Literal "/* Unexpected input */"

module.exports = ES5Backend
