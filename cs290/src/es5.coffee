# ==============================================================================
# ES5 Backend - Solar Directive Processor for CoffeeScript
# ==============================================================================
#
# Converts Solar directives (pure data) to CoffeeScript AST node instances
#
# Solar directives are generated by the parser from Solar syntax.coffee rules:
#   o 'IDENTIFIER', $ast: 'IdentifierLiteral', value: 1
#
# This backend converts those directives into actual CoffeeScript AST nodes:
#   new nodes.IdentifierLiteral(tokenValue)
#
# The resulting AST nodes use the existing CoffeeScript compiler pipeline.
# ==============================================================================

class ES5Backend
  constructor: (@options = {}, @ast = {}) ->
    @compileOptions =
      bare: @options.bare ? true
      header: @options.header ? false

  reduce: (values, positions, stackTop, symbolCount, directive) ->
    $ = o = (index) -> values[stackTop - symbolCount + 1 + index]
    for own prop, value of directive
      continue if prop in ['name', 'length', 'prototype']
      o[prop] = value
    @resolve o

  resolve: (value, lookup = value) ->
    return lookup(value - 1) if typeof value is 'number' and lookup?
    return value if typeof value is 'number'
    return value if typeof value in ['string', 'boolean']
    if Array.isArray value
      return value.map (item) => @resolve item, lookup

    if value? and (typeof value is 'object' or typeof value is 'function')
      o = value
      return o if o.constructor?.name and o.constructor.name not in ['Object', 'Function'] # AST nodes
      useLookup = if typeof value is 'function' then value else lookup

      if o.$ast?
        nodeType = o.$ast

        switch nodeType
          when 'Root'
            body = @resolve o.body, useLookup
            bodyArray = if Array.isArray(body) then body else [body]
            filteredBody = bodyArray.filter (item) -> item?
            block = new @ast.Block filteredBody
            block.makeReturn() if filteredBody.length > 0  # Make final expression return
            new @ast.Root block
          when 'IdentifierLiteral'
            resolvedValue = @resolve o.value, useLookup
            new @ast.IdentifierLiteral resolvedValue
          when 'NumberLiteral'
            resolvedValue = @resolve o.value, useLookup
            new @ast.NumberLiteral resolvedValue
          when 'Value'
            val = @resolve o.val, useLookup
            new @ast.Value val
          when 'Assign'
            variable = @resolve o.variable, useLookup
            resolvedValue = @resolve o.value, useLookup
            new @ast.Assign variable, resolvedValue
          when 'Op'
            operator = @resolve o.operator, useLookup
            first = @resolve o.first, useLookup
            second = @resolve o.second, useLookup
            new @ast.Op operator, first, second
          when 'Literal'
            resolvedValue = @resolve o.value, useLookup
            new @ast.Literal resolvedValue
          else
            console.warn "ES5Backend: Unimplemented AST node type:", nodeType
            new @ast.Literal "/* Unimplemented: #{nodeType} */"

      else if o.$ary?
        items = @resolve o.$ary, useLookup
        if Array.isArray(items) then items else [items]

      else if o.$use?
        resolvedValue = @resolve o.$use, useLookup
        resolvedValue = resolvedValue[o.method]?() ? resolvedValue if o.method?
        resolvedValue

      else if o.$ops?
        console.warn "ES5Backend: $ops not yet implemented:", o.$ops
        new @ast.Literal "/* $ops: #{o.$ops} */"

      else
        console.warn "ES5Backend: Unknown directive:", o
        new @ast.Literal "/* Unknown directive */"

    else
      new @ast.Literal "/* Unexpected input */"

module.exports = ES5Backend
