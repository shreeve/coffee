# ==============================================================================
# ES5 Backend - Solar Directive Processor for CoffeeScript
# ==============================================================================
#
# Converts Solar directives (pure data) to CoffeeScript AST node instances
#
# Solar directives are generated by the parser from Solar syntax.coffee rules:
#   o 'IDENTIFIER', $ast: 'IdentifierLiteral', value: 1
#
# This backend converts those directives into actual CoffeeScript AST nodes:
#   new nodes.IdentifierLiteral(tokenValue)
#
# The resulting AST nodes use the existing CoffeeScript compiler pipeline.
# ==============================================================================

class ES5Backend
  constructor: (@options = {}, @ast = {}) ->
    @compileOptions =
      bare: @options.bare ? true
      header: @options.header ? false

  # Helper methods
  _stripQuotes: (value) ->
    return value unless value?.length >= 2 and typeof value is 'string'
    if (value[0] is '"' and value[value.length-1] is '"') or (value[0] is "'" and value[value.length-1] is "'")
      value.slice(1, -1)
    else
      value

  reduce: (values, positions, stackTop, symbolCount, directive) ->
    o = (index) -> values[stackTop - symbolCount + 1 + index]
    for own prop, value of directive
      continue if prop in ['name', 'length', 'prototype']
      o[prop] = value
    @resolve o

  resolve: (value, lookup = value) ->
    return lookup(value - 1) if typeof value is 'number' and lookup?
    return value if typeof value is 'number'
    return value if typeof value in ['string', 'boolean']
    return(value.map (item) => @resolve item, lookup) if Array.isArray value

    if value? and (typeof value is 'object' or typeof value is 'function')
      o = value
      return o if o.constructor?.name and o.constructor.name not in ['Object', 'Function'] # AST nodes
      useLookup = if typeof value is 'function' then value else lookup
      $ = (val) => @resolve val, useLookup  # Local resolver

      if o.$ast?
        nodeType = o.$ast

        switch nodeType
          when 'Root'              then new @ast.Root ((b) -> b.makeReturn(); b)(new @ast.Block $(o.body))
          when 'IdentifierLiteral' then new @ast.IdentifierLiteral $(o.value)
          when 'NumberLiteral'     then new @ast.NumberLiteral     $(o.value)
          when 'StringLiteral'     then new @ast.StringLiteral     @_stripQuotes($(o.value))
          when 'BooleanLiteral'    then new @ast.BooleanLiteral    $(o.value)
          when 'ThisLiteral'       then new @ast.ThisLiteral
          when 'NullLiteral'       then new @ast.NullLiteral
          when 'UndefinedLiteral'  then new @ast.UndefinedLiteral
          when 'InfinityLiteral'   then new @ast.InfinityLiteral
          when 'NaNLiteral'        then new @ast.NaNLiteral
          when 'Value'             then new @ast.Value             $(o.val)
          when 'Assign'            then new @ast.Assign            $(o.variable), $(o.value)
          when 'Op'                then new @ast.Op                $(o.args[0]), $(o.args[1]), (if o.args[2]? then $(o.args[2]))
          when 'PropertyName'      then new @ast.PropertyName      $(o.value)
          when 'Access'            then new @ast.Access            $(o.name), soak: o.soak
          when 'Call'              then new @ast.Call              $(o.variable), $(o.args)
          when 'Obj'               then new @ast.Obj               $(o.properties), $(o.generated)
          when 'Arr'               then new @ast.Arr               $(o.objects)
          when 'Range'             then new @ast.Range             $(o.from), $(o.to), $(o.exclusive)
          when 'Block'             then new @ast.Block             $(o.expressions)
          when 'Return'            then new @ast.Return            $(o.expression)
          when 'Parens'            then new @ast.Parens            $(o.body)
          when 'Index'             then new @ast.Index             $(o.index)
          when 'Slice'             then new @ast.Slice             $(o.range)
          when 'If'                then new @ast.If                $(o.condition), $(o.body), $(o.elseBody)
          when 'While'             then new @ast.While             $(o.condition), $(o.body)
          when 'For'               then new @ast.For               $(o.body), $(o.source)
          when 'Switch'            then new @ast.Switch            $(o.subject), $(o.cases), $(o.otherwise)
          when 'Try'               then new @ast.Try               $(o.attempt), $(o.recovery), $(o.ensure)
          when 'Class'             then new @ast.Class             $(o.variable), $(o.parent), $(o.body)
          when 'Code'              then new @ast.Code              $(o.params), $(o.body)
          when 'Splat'             then new @ast.Splat             $(o.name)
          when 'Existence'         then new @ast.Existence         $(o.expression)
          when 'RegexLiteral'      then new @ast.RegexLiteral      $(o.value)
          when 'StatementLiteral'  then new @ast.StatementLiteral  $(o.value)
          when 'PassthroughLiteral' then new @ast.PassthroughLiteral $(o.value)
          when 'Literal'           then new @ast.Literal           $(o.value)
          else
            console.warn "ES5Backend: Unimplemented AST node type:", nodeType
            new @ast.Literal "/* Unimplemented: #{nodeType} */"

      else if o.$ary?
        items = $(o.$ary)
        if Array.isArray(items) then items else [items]

      else if o.$use?
        resolvedValue = $(o.$use)
        resolvedValue = resolvedValue[o.method]?() ? resolvedValue if o.method?
        resolvedValue

      else if o.$ops?
        switch o.$ops
          when 'value'
            # Add accessor/property to Value node
            if o.add?
              target = $(o.add[0])
              accessor = $(o.add[1])
              target = new @ast.Value target unless target instanceof @ast.Value
              target.add [accessor] if accessor?.traverseChildren?
              target
            else
              console.warn "ES5Backend: $ops value without add:", o
              new @ast.Literal "/* $ops: value */"
          when 'array'
            # Array operations
            if o.append?
              target = $(o.append[0])
              items = ($(item) for item in o.append[1..] when item?)
              target = [] unless Array.isArray target
              target.concat items
            else if o.gather?
              result = []
              for item in o.gather when item?
                resolved = $(item)
                if Array.isArray resolved then result = result.concat resolved else result.push resolved
              result
            else
              console.warn "ES5Backend: $ops array without append/gather:", o
              new @ast.Literal "/* $ops: array */"
          else
            console.warn "ES5Backend: $ops not yet implemented:", o.$ops
            new @ast.Literal "/* $ops: #{o.$ops} */"

      else
        console.warn "ES5Backend: Unknown directive:", o
        new @ast.Literal "/* Unknown directive */"

    else
      new @ast.Literal "/* Unexpected input */"

module.exports = ES5Backend
