# ==============================================================================
# ES5 Backend - Solar Directive Processor for CoffeeScript
# ==============================================================================
#
# Converts Solar directives (pure data) to CoffeeScript AST node instances
#
# Solar directives are generated by the parser from Solar syntax.coffee rules:
#   o 'IDENTIFIER', $ast: 'IdentifierLiteral', value: 1
#
# This backend converts those directives into actual CoffeeScript AST nodes:
#   new nodes.IdentifierLiteral(tokenValue)
#
# The resulting AST nodes use the existing CoffeeScript compiler pipeline.
# ==============================================================================

class ES5Backend
  constructor: (@options = {}, @ast = {}) ->
    @compileOptions =
      bare: @options.bare ? true
      header: @options.header ? false

  # Helper methods
  _stripQuotes: (value) ->
    return value unless value?.length >= 2 and typeof value is 'string'
    if (value[0] is '"' and value[value.length-1] is '"') or (value[0] is "'" and value[value.length-1] is "'")
      value.slice(1, -1)
    else
      value

  reduce: (values, positions, stackTop, symbolCount, directive) ->
    lookup = (index) -> values[stackTop - symbolCount + 1 + index]
    store = Object.create null

    handler =
      apply: (target, thisArg, args) -> target.apply thisArg, args
      get: (target, prop, receiver) ->
        return store[prop] if Object.prototype.hasOwnProperty.call(store, prop)
        return undefined if prop in ['name', 'length', 'prototype', 'caller', 'arguments']
        Reflect.get target, prop, receiver
      set: (target, prop, value) ->
        store[prop] = value
        true
      has: (target, prop) -> Object.prototype.hasOwnProperty.call(store, prop) or prop of target
      ownKeys: (target) -> Reflect.ownKeys(store).concat Reflect.ownKeys(target)
      getOwnPropertyDescriptor: (target, prop) ->
        if Object.prototype.hasOwnProperty.call(store, prop)
          value: store[prop]
          configurable: true
          enumerable: true
          writable: true
        else
          Object.getOwnPropertyDescriptor target, prop

    o = new Proxy lookup, handler

    o[prop] = value for own prop, value of directive

    @resolve o

  resolve: (o, lookup = o) ->

    # Null/undefined early return
    return o unless o?  # null/undefined early return

    type = typeof o

    # Numbers: only do 1-based lookup for positive integers
    if type is 'number'
      return lookup(o - 1) if Number.isInteger(o) and o > 0 and typeof lookup is 'function'
      return o

    # Strings and booleans return as-is, arrays are resolved recursively
    return o if type is 'string' or type is 'boolean'
    return(o.map (val) => @resolve val, lookup) if Array.isArray o

    # Functions without directive markers are terminals (key fix!)
    if type is 'function' and not (o.$ast? or o.$use? or o.$ary? or o.$ops?)
      return o

    # Objects and functions
    if type is 'object' or type is 'function'
      return o if o.constructor? and o.constructor not in [Object, Function]

      $ = (val) => @resolve val, lookup  # Local resolver

      if o.$ast?
        nodeType = o.$ast

        switch nodeType
          when 'Root'               then new @ast.Root ((b) -> b.makeReturn(); b)(new @ast.Block $(o.body))
          when 'IdentifierLiteral'  then new @ast.IdentifierLiteral  $(o.value)
          when 'NumberLiteral'      then new @ast.NumberLiteral      $(o.value)
          when 'StringLiteral'      then new @ast.StringLiteral      @_stripQuotes($(o.value))
          when 'BooleanLiteral'     then new @ast.BooleanLiteral     $(o.value)
          when 'ThisLiteral'        then new @ast.ThisLiteral
          when 'NullLiteral'        then new @ast.NullLiteral
          when 'UndefinedLiteral'   then new @ast.UndefinedLiteral
          when 'InfinityLiteral'    then new @ast.InfinityLiteral
          when 'NaNLiteral'         then new @ast.NaNLiteral
          when 'Value'              then new @ast.Value              $(o.val)
          when 'Assign'
            variable = $(o.variable)
            value = $(o.value)
            context = $(o.context)
            # Skip if variable or value is null/undefined (from empty {} placeholders)
            return null unless variable? and value?
            new @ast.Assign variable, value, context
          when 'Op'                 then new @ast.Op                 $(o.args[0]), $(o.args[1]), (if o.args[2]? then $(o.args[2]))
          when 'PropertyName'       then new @ast.PropertyName       $(o.value)
          when 'Access'             then new @ast.Access             $(o.name), soak: o.soak
          when 'Call'               then new @ast.Call               $(o.variable), $(o.args)
          when 'Obj'                then new @ast.Obj ((prop for prop in $(o.properties) ? [] when prop?)), $(o.generated)
          when 'Arr'                then new @ast.Arr ((obj for obj in $(o.objects) ? [] when obj?))
          when 'Range'              then new @ast.Range              $(o.from), $(o.to), $(o.exclusive)
          when 'Block'              then new @ast.Block ((expr for expr in $(o.expressions) ? [] when expr?))
          when 'Return'             then new @ast.Return             $(o.expression)
          when 'Parens'             then new @ast.Parens(if (b = $(o.body)) instanceof @ast.Block then b else new @ast.Block [b])
          when 'Index'              then new @ast.Index              $(o.index)
          when 'Slice'              then new @ast.Slice              $(o.range)
          when 'If'                 then new @ast.If $(o.condition), (if (b = $(o.body)) instanceof @ast.Block or not b? then b else new @ast.Block [b]), (if (e = $(o.elseBody))? and not (e instanceof @ast.Block) then new @ast.Block [e] else e)
          when 'While'              then new @ast.While $(o.condition), (if (b = $(o.body)) instanceof @ast.Block or not b? then b else new @ast.Block [b])
          when 'For'                then new @ast.For                $(o.body), $(o.source)
          when 'Switch'             then new @ast.Switch             $(o.subject), $(o.cases), $(o.otherwise)
          when 'SwitchWhen'         then new @ast.SwitchWhen         $(o.conditions), $(o.block)
          when 'Elision'            then new @ast.Elision
          when 'Expansion'          then new @ast.Expansion
          when 'Try'                then new @ast.Try (if (a = $(o.attempt)) instanceof @ast.Block or not a? then a else new @ast.Block [a]), $(o.recovery), $(o.ensure)
          when 'Class'              then new @ast.Class              $(o.variable), $(o.parent), $(o.body)
          when 'FuncGlyph'          then new @ast.FuncGlyph          $(o.glyph)
          when 'Param'              then new @ast.Param              $(o.name), $(o.value), $(o.splat)
          when 'Code'               then new @ast.Code ((p for p in $(o.params) ? [] when p?)), (if (b = $(o.body)) instanceof @ast.Block then b else new @ast.Block [b]), $(o.funcGlyph), $(o.paramStart)
          when 'Splat'              then new @ast.Splat              $(o.name)
          when 'Existence'          then new @ast.Existence          $(o.expression)
          when 'RegexLiteral'       then new @ast.RegexLiteral       $(o.value)
          when 'StatementLiteral'   then new @ast.StatementLiteral   $(o.value)
          when 'PassthroughLiteral' then new @ast.PassthroughLiteral $(o.value)
          when 'Interpolation'      then new @ast.Interpolation      $(o.expression)
          when 'StringWithInterpolations'
            # Body should contain Value-wrapped StringLiterals and Interpolation nodes
            body = $(o.body)
            # Ensure body is an array
            body = if Array.isArray(body) then body else [body]
            # Wrap elements properly
            wrappedBody = for item in body
              # Skip undefined/null items
              continue unless item?
              # If it's already properly formed, use it
              if item instanceof @ast.Value or item instanceof @ast.Interpolation
                item
              # If it's a StringLiteral, wrap in Value
              else if item instanceof @ast.StringLiteral
                new @ast.Value(item)
              # If it's a plain object with $ast, resolve it
              else if item.$ast?
                resolved = $(item)
                if resolved instanceof @ast.StringLiteral
                  new @ast.Value(resolved)
                else
                  resolved
              else
                item
            # Filter out undefined items from continue statements
            wrappedBody = (item for item in wrappedBody when item?)
            new @ast.StringWithInterpolations new @ast.Block(wrappedBody), quote: $(o.quote)
          when 'Catch'              then new @ast.Catch              $(o.body), $(o.errorVariable)
          when 'Throw'              then new @ast.Throw              $(o.expression)
          when 'Literal'            then new @ast.Literal            $(o.value)
          else
            console.warn "ES5Backend: Unimplemented AST node type:", nodeType
            new @ast.Literal "/* Unimplemented: #{nodeType} */"

      else if o.$ary?
        items = $(o.$ary)
        # Ensure we always return an array
        items = if Array.isArray(items) then items else [items]
        # Important: filter out undefined/null items (common from optional grammar rules)
        items.filter (item) -> item?

      else if o.$use?
        resolvedValue = $(o.$use)
        resolvedValue = resolvedValue[o.method]?() ? resolvedValue if o.method?
        resolvedValue

      else if o.$ops?
        switch o.$ops
          when 'value'
            # Add accessor/property to Value node
            if o.add?
              target = $(o.add[0])
              accessor = $(o.add[1])
              target = new @ast.Value target unless target instanceof @ast.Value
              target.add [accessor] if accessor?.traverseChildren?
              target
            else
              console.warn "ES5Backend: $ops value without add:", o
              new @ast.Literal "/* $ops: value */"
          when 'array'
            # Array operations - ensure all items are resolved
            if o.append?
              target = $(o.append[0])
              target = [] unless Array.isArray target
              for item in o.append[1..] when item?
                resolved = $(item)
                # Handle arrays properly - flatten if needed
                if Array.isArray(resolved)
                  for subItem in resolved
                    # Ensure each subItem is fully resolved
                    target.push if subItem? then $(subItem) else subItem
                else if resolved?
                  target.push resolved
              target
            else if o.gather?
              result = []
              for item in o.gather when item?
                resolved = $(item)
                if Array.isArray(resolved)
                  for subItem in resolved
                    # Ensure each subItem is fully resolved
                    result.push if subItem? then $(subItem) else subItem
                else if resolved?
                  result.push resolved
              result
            else
              console.warn "ES5Backend: $ops array without append/gather:", o
              new @ast.Literal "/* $ops: array */"
          when 'if'
            # If operations for adding else clauses
            if o.addElse?
              ifNode = $(o.addElse[0])
              elseBody = $(o.addElse[1])
              ifNode.addElse elseBody if ifNode instanceof @ast.If
              ifNode
            else
              console.warn "ES5Backend: $ops if without addElse:", o
              new @ast.Literal "/* $ops: if */"
          when 'loop'
            # Loop operations
            if o.addSource?
              loopNode = $(o.addSource[0])
              sourceInfo = $(o.addSource[1])
              loopNode.addSource sourceInfo if loopNode
              loopNode
            else if o.addBody?
              loopNode = $(o.addBody[0])
              bodyNode = $(o.addBody[1])
              loopNode.addBody bodyNode if loopNode
              loopNode
            else
              console.warn "ES5Backend: $ops loop without addSource/addBody:", o
              new @ast.Literal "/* $ops: loop */"
          else
            console.warn "ES5Backend: $ops not yet implemented:", o.$ops
            new @ast.Literal "/* $ops: #{o.$ops} */"

      else
        # Empty objects {} are grammar placeholders - return null to signal "no value"
        if typeof o is 'object' and o.constructor is Object and Object.keys(o).length is 0
          return null
        console.warn "ES5Backend: Unknown directive:", o
        new @ast.Literal "/* Unknown directive */"

    else
      new @ast.Literal "/* Unexpected input */"

module.exports = ES5Backend
