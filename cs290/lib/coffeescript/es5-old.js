// Generated by CoffeeScript 2.7.0
(function() {
  // ==============================================================================
  // ES5 Backend - Solar Directive Processor for CoffeeScript
  // ==============================================================================

  // Converts Solar directives (pure data) to CoffeeScript AST node instances

  // Solar directives are generated by the parser from Solar syntax.coffee rules:
  //   o 'IDENTIFIER', $ast: 'IdentifierLiteral', value: 1

  // This backend converts those directives into actual CoffeeScript AST nodes:
  //   new nodes.IdentifierLiteral(tokenValue)

  // The resulting AST nodes use the existing CoffeeScript compiler pipeline.
  // ==============================================================================
  var ES5Backend,
    hasProp = {}.hasOwnProperty;

  ES5Backend = class ES5Backend {
    constructor(options = {}, ast = {}) {
      var ref, ref1;
      this.options = options;
      this.ast = ast;
      // Use Object.create(null) to avoid prototype pollution in options
      this.compileOptions = Object.create(null);
      this.compileOptions.bare = (ref = this.options.bare) != null ? ref : true;
      this.compileOptions.header = (ref1 = this.options.header) != null ? ref1 : false;
    }

    // ----------------------------------------------------------------------------
    // Helpers
    // ----------------------------------------------------------------------------

      // Add minimal location data to node to avoid errors in AST operations
    _addLocationData(node) {
      if (node == null) {
        return node;
      }
      // Only add location data to objects, not primitives
      if (typeof node === 'object' && node !== null) {
        if (node.locationData == null) {
          node.locationData = {
            first_line: 0,
            first_column: 0,
            last_line: 0,
            last_column: 0,
            range: [0, 0]
          };
        }
      }
      return node;
    }

    // Ensure a node is a Value; if already a Value, return as-is
    _asValue(node) {
      if (node == null) {
        return null;
      }
      if (node instanceof this.ast.Value) {
        return node;
      }
      return new this.ast.Value(node);
    }

    // Append an Access (with optional soak) to a value-ish LHS
    _appendAccess(lhs, name, soak) {
      var node;
      if (name == null) {
        return null;
      }
      // Normalize name into a PropertyName when needed
      if (typeof name === 'string') {
        name = new this.ast.PropertyName(name);
      } else if ((name != null) && !(name instanceof this.ast.PropertyName) && ((name != null ? name.value : void 0) != null)) {
        name = new this.ast.PropertyName(String(name.value));
      }
      node = new this.ast.Access(name, {soak});
      if (lhs != null) {
        if (!(lhs instanceof this.ast.Value)) {
          lhs = this._asValue(lhs);
        }
        lhs.properties.push(node);
        return lhs;
      } else {
        return node;
      }
    }

    // Append an Index to a value-ish LHS
    _appendIndex(lhs, indexExpr) {
      var node;
      if (indexExpr == null) {
        return null;
      }
      node = new this.ast.Index(indexExpr);
      if (lhs != null) {
        if (!(lhs instanceof this.ast.Value)) {
          lhs = this._asValue(lhs);
        }
        lhs.properties.push(node);
        return lhs;
      } else {
        return node;
      }
    }

    // Build a Value from base + properties array (already resolved)
    _buildValue(base, properties) {
      var props;
      if (base instanceof this.ast.Value) {
        props = this._filterNodes((Array.isArray(properties) ? properties : []));
        if (props.length) {
          base.add(props);
        }
        return base;
      }
      if ((base != null) && !(base instanceof this.ast.Base)) {
        base = this._ensureNode(base);
      }
      props = this._filterNodes((Array.isArray(properties) ? properties : []));
      if (props.length) {
        return new this.ast.Value(base, props);
      } else {
        return new this.ast.Value(base);
      }
    }

    // Helper to ensure value is a proper node
    _ensureNode(value) {
      var ref;
      if (value == null) {
        return null;
      }
      if ((value != null ? value.compileToFragments : void 0) || value instanceof this.ast.Base) {
        return value;
      }
      // Handle primitives
      if ((ref = typeof value) === 'string' || ref === 'number' || ref === 'boolean') {
        return new this.ast.Literal(String(value));
      }
      // Handle objects with .value property
      if ((value != null ? value.value : void 0) != null) {
        return new this.ast.PropertyName(value.value);
      }
      return null;
    }

    // Helper to filter and ensure all items are nodes
    _filterNodes(array) {
      var item, j, len, node, result;
      if (array == null) {
        return [];
      }
      result = [];
      for (j = 0, len = array.length; j < len; j++) {
        item = array[j];
        node = item instanceof this.ast.Base ? item : this._ensureNode(item);
        if (node != null) {
          result.push(node);
        }
      }
      return result;
    }

    // Normalize an array-like into AST nodes (ensures array, resolves and filters)
    _nodes(xs) {
      xs = Array.isArray(xs) ? xs : (xs != null ? [xs] : []);
      return this._filterNodes(xs);
    }

    // Helper to check if value is a plain object
    _isPlainObject(x) {
      var p;
      if (!((x != null) && typeof x === 'object')) {
        return false;
      }
      p = Object.getPrototypeOf(x);
      return p === Object.prototype || p === null;
    }

    // Strip surrounding quotes from a string literal
    _stripQuotes(value) {
      if (!((value != null ? value.length : void 0) >= 2 && typeof value === 'string')) {
        return value;
      }
      if ((value[0] === '"' && value[value.length - 1] === '"') || (value[0] === "'" && value[value.length - 1] === "'")) {
        return value.slice(1, -1);
      } else {
        return value;
      }
    }

    // Convert value to a Block node
    _toBlock(value) {
      var block, node, nodes;
      // Ensure all nodes in block have location data
      block = Array.isArray(value) ? (nodes = this._filterNodes(value), nodes = nodes.map((n) => {
        return this._addLocationData(n);
      // Ensure existing block expressions have location data
      }), new this.ast.Block(nodes)) : value instanceof this.ast.Block ? (value.expressions != null ? value.expressions = value.expressions.map((n) => {
        return this._addLocationData(n);
      }) : void 0, value) : value != null ? (node = this._ensureNode(value), node != null ? this._addLocationData(node) : void 0, new this.ast.Block([node].filter(function(n) {
        return n != null;
      }))) : new this.ast.Block([]);
      return this._addLocationData(block);
    }

    // Unimplemented marker
    _unimplemented(type, context = "") {
      console.warn(`ES5Backend: Unimplemented${context ? ` ${context}` : ""}:`, type);
      return new this.ast.Literal(`/* Unimplemented: ${type} */`);
    }

    // ----------------------------------------------------------------------------
    // Entry points
    // ----------------------------------------------------------------------------
    reduce(values, positions, stackTop, symbolCount, directive) {
      var handler, i, lookup, o, outName, prop, ref, ref1, ref2, ref3, res, rhs, store, util, value;
      lookup = function(index) {
        return values[stackTop - symbolCount + 1 + index];
      };
      util = null;
      // Debug directives when SOLAR_DEBUG is set
      if (typeof process !== "undefined" && process !== null ? (ref = process.env) != null ? ref.SOLAR_DEBUG : void 0 : void 0) {
        util = require('util');
        rhs = (function() {
          var j, ref1, results;
          results = [];
          for (i = j = 0, ref1 = symbolCount; (0 <= ref1 ? j < ref1 : j > ref1); i = 0 <= ref1 ? ++j : --j) {
            results.push(values[stackTop - symbolCount + 1 + i]);
          }
          return results;
        })();
        console.log("\n[Solar] directive:", util.inspect(directive, {
          depth: 4,
          colors: true
        }));
        console.log("[Solar] rhs:", util.inspect(rhs, {
          depth: 1,
          colors: true
        }));
      }
      // Use Object.create(null) to avoid pollution and JS property conflicts
      store = Object.create(null);
      handler = {
        apply: function(target, thisArg, args) {
          return target.apply(thisArg, args);
        },
        get: function(target, prop, receiver) {
          if (Object.prototype.hasOwnProperty.call(store, prop)) {
            return store[prop];
          }
          if (prop === 'name' || prop === 'length' || prop === 'prototype' || prop === 'caller' || prop === 'arguments' || prop === 'constructor' || prop === 'toString' || prop === 'valueOf') {
            // Avoid leaking function/meta props from the Proxy target
            return void 0;
          }
          return Reflect.get(target, prop, receiver);
        },
        set: function(target, prop, value) {
          store[prop] = value;
          return true;
        },
        has: function(target, prop) {
          return Object.prototype.hasOwnProperty.call(store, prop) || prop in target;
        },
        ownKeys: function(target) {
          return Reflect.ownKeys(store).concat(Reflect.ownKeys(target));
        },
        getOwnPropertyDescriptor: function(target, prop) {
          if (Object.prototype.hasOwnProperty.call(store, prop)) {
            return {
              value: store[prop],
              configurable: true,
              enumerable: true,
              writable: true
            };
          } else {
            return Object.getOwnPropertyDescriptor(target, prop);
          }
        }
      };
      // Copy directive props, resolving positional references now
      o = new Proxy(lookup, handler);
      for (prop in directive) {
        if (!hasProp.call(directive, prop)) continue;
        value = directive[prop];
        o[prop] = typeof value === 'number' ? lookup(value - 1) : value;
      }
      res = this.resolve(o);
      if (typeof process !== "undefined" && process !== null ? (ref1 = process.env) != null ? ref1.SOLAR_DEBUG : void 0 : void 0) {
        util = util || require('util');
        outName = (ref2 = res != null ? (ref3 = res.constructor) != null ? ref3.name : void 0 : void 0) != null ? ref2 : typeof res;
        console.log("[Solar] result:", outName, util.inspect(res, {
          depth: 3,
          colors: true
        }));
      }
      return res;
    }

    resolve(o, lookup = o) {
      var $, a, accessor, actualExpression, args, base, body, bodyArg, bodyBlock, bodyNode, bodyNodes, callee, condition, context, elseBody, expression, expressionNode, ifNode, item, items, j, k, l, len, len1, len2, len3, loopNode, m, name1, nodeType, opts, out, p, position, property, props, q, quote, ref, ref1, ref10, ref11, ref12, ref13, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, resolved, resolvedValue, result, sourceInfo, target, tmp, type, v, val, value, variable, whileNode;
      if (o == null) {
        return o; // null/undefined
      }
      type = typeof o;
      // Numbers: do 1-based lookup for positive integers only
      if (type === 'number') {
        if (Number.isInteger(o) && o > 0 && typeof lookup === 'function') {
          result = lookup(o - 1);
          return result;
        }
        return o;
      }
      if (type === 'string' || type === 'boolean') {
        // Strings and booleans return as-is
        return o;
      }
      // Arrays: resolve items and skip nullish
      if (Array.isArray(o)) {
        result = [];
        for (j = 0, len = o.length; j < len; j++) {
          val = o[j];
          resolved = this.resolve(val, lookup);
          if (resolved != null) {
            result.push(resolved);
          }
        }
        return result;
      }
      // Bare functions without directive markers are terminals
      if (type === 'function' && !((o.$ast != null) || (o.$use != null) || (o.$ary != null) || (o.$ops != null))) {
        return o;
      }
      // Objects and directive-bearing functions
      if (type === 'object' || type === 'function') {
        if ((o.constructor != null) && ((ref = o.constructor) !== Object && ref !== Function)) {
          return o;
        }
        $ = (val) => {
          return this.resolve(val, lookup); // local resolver
        };
        if (o.$ast != null) {
          nodeType = o.$ast;
          switch (nodeType) {
            case 'Root':
              return new this.ast.Root((function(b) {
                b.makeReturn();
                return b;
              })(new this.ast.Block($(o.body))));
            case 'IdentifierLiteral':
              return new this.ast.IdentifierLiteral($(o.value));
            case 'NumberLiteral':
              return new this.ast.NumberLiteral($(o.value));
            case 'StringLiteral':
              return new this.ast.StringLiteral(this._stripQuotes($(o.value)));
            case 'BooleanLiteral':
              return new this.ast.BooleanLiteral($(o.value));
            case 'ThisLiteral':
              return new this.ast.ThisLiteral();
            case 'NullLiteral':
              return new this.ast.NullLiteral();
            case 'UndefinedLiteral':
              return new this.ast.UndefinedLiteral();
            case 'InfinityLiteral':
              return new this.ast.InfinityLiteral();
            case 'NaNLiteral':
              return new this.ast.NaNLiteral();
            // ---- Refactored to helpers ----------------------------------------
            case 'Value':
              base = (ref1 = $(o.value)) != null ? ref1 : $(o.val);
              props = (ref2 = $(o.properties)) != null ? ref2 : [];
              return this._buildValue(base, props);
            case 'Access':
              return this._appendAccess($(o.variable), $(o.name), $(o.soak));
            case 'Index':
              return this._appendIndex($(o.variable) || $(o.val) || $(o.base), $(o.index) || $(o.object));
            // -------------------------------------------------------------------
            case 'Call':
              callee = this._asValue($(o.variable));
              args = (ref3 = $(o.args)) != null ? ref3 : [];
              args = (function() {
                var l, len1, results;
                results = [];
                for (l = 0, len1 = args.length; l < len1; l++) {
                  a = args[l];
                  if (a != null) {
                    results.push(a);
                  }
                }
                return results;
              })();
              return new this.ast.Call(callee, args, $(o.soak), $(o.token));
            case 'Obj':
              return new this.ast.Obj($(o.properties), $(o.generated));
            case 'Arr':
              return new this.ast.Arr($(o.objects));
            case 'Range':
              return new this.ast.Range($(o.from), $(o.to), ($(o.exclusive) ? 'exclusive' : null));
            case 'Block':
              return new this.ast.Block($(o.expressions));
            case 'Return':
              return new this.ast.Return($(o.expression));
            case 'Op':
              return new this.ast.Op($(o.args[0]), $(o.args[1]), (o.args[2] != null ? $(o.args[2]) : void 0));
            case 'Parens':
              return new this.ast.Parens((ref4 = this._toBlock($(o.body))) != null ? ref4 : new this.ast.Block([new this.ast.Literal('')]));
            case 'PropertyName':
              return new this.ast.PropertyName($(o.value));
            case 'Slice':
              return new this.ast.Slice($(o.range));
            case 'If':
              condition = $(o.condition);
              body = this._toBlock($(o.body));
              elseBody = o.elseBody != null ? this._toBlock($(o.elseBody)) : null;
              tmp = ((ref5 = $(o.type)) != null ? typeof ref5.toString === "function" ? ref5.toString() : void 0 : void 0) === 'unless' ? 'unless' : 'if';
              ifNode = new this.ast.If(condition, body, {
                type: tmp
              });
              this._addLocationData(ifNode);
              if ((elseBody != null ? (ref6 = elseBody.expressions) != null ? ref6.length : void 0 : void 0) > 0) {
                this._addLocationData(elseBody);
                ifNode.addElse(elseBody);
              }
              return ifNode;
            case 'While':
              condition = $(o.condition);
              opts = {};
              if (o.guard != null) {
                opts.guard = $(o.guard);
              }
              if (o.isLoop != null) {
                opts.isLoop = $(o.isLoop);
              }
              if (o.invert != null) {
                opts.invert = $(o.invert);
              }
              whileNode = new this.ast.While(condition, opts);
              // Body will be added later via $ops: 'loop' addBody
              // But if body is provided directly (e.g., from Loop rule), use it
              if (o.body != null) {
                whileNode.body = this._toBlock($(o.body));
              } else {
                // Initialize with empty block to avoid undefined errors
                whileNode.body = new this.ast.Block([]);
              }
              this._addLocationData(whileNode);
              return whileNode;
            case 'For':
              return new this.ast.For($(o.body), {}); // created now; $ops: 'loop' will addSource
            case 'Switch':
              return new this.ast.Switch($(o.subject), this._nodes($(o.cases)), this._toBlock($(o.otherwise)));
            case 'SwitchWhen':
              return new this.ast.SwitchWhen(this._nodes($(o.conditions)), this._toBlock($(o.body)));
            case 'ComputedPropertyName':
              return new this.ast.ComputedPropertyName($(o.value));
            case 'DefaultLiteral':
              return new this.ast.DefaultLiteral($(o.value));
            case 'Elision':
              return new this.ast.Elision();
            case 'Expansion':
              return new this.ast.Expansion();
            case 'Try':
              return new this.ast.Try(this._toBlock($(o.attempt)), $(o.catch), this._toBlock($(o.ensure)));
            case 'Class':
              return new this.ast.Class($(o.variable), $(o.parent), $(o.body));
            case 'FuncGlyph':
              return new this.ast.FuncGlyph($(o.glyph));
            case 'Param':
              return new this.ast.Param($(o.name), $(o.value), $(o.splat));
            case 'Code':
              return new this.ast.Code((function() {
                var l, len1, ref7, ref8, results;
                ref8 = (ref7 = $(o.params)) != null ? ref7 : [];
                results = [];
                for (l = 0, len1 = ref8.length; l < len1; l++) {
                  p = ref8[l];
                  if ($(p) != null) {
                    results.push($(p));
                  }
                }
                return results;
              })(), this._toBlock($(o.body)), $(o.funcGlyph), $(o.paramStart));
            case 'Splat':
              return new this.ast.Splat($(o.name));
            case 'Existence':
              return new this.ast.Existence($(o.expression));
            case 'RegexLiteral':
              return new this.ast.RegexLiteral($(o.value));
            case 'StatementLiteral':
              return new this.ast.StatementLiteral($(o.value));
            case 'PassthroughLiteral':
              return new this.ast.PassthroughLiteral($(o.value));
            case 'Interpolation':
              expression = $(o.expression);
              actualExpression = Array.isArray(expression) && expression.length > 0 ? expression[0] : expression;
              expressionNode = actualExpression instanceof this.ast.Base ? actualExpression : actualExpression != null ? this._ensureNode(actualExpression) : new this.ast.Literal('""'); // avoid ${} syntax error
              return new this.ast.Interpolation(expressionNode);
            case 'StringWithInterpolations':
              body = $(o.body);
              quote = $(o.quote);
              bodyNode = Array.isArray(body) ? (bodyNodes = body.map((b) => {
                if (b instanceof this.ast.Base) {
                  return b;
                } else {
                  return this._ensureNode(b);
                }
              }), new this.ast.Block(this._filterNodes(bodyNodes))) : body instanceof this.ast.Block ? body : body != null ? new this.ast.Block([this._ensureNode(body)]) : new this.ast.Block([]);
              return new this.ast.StringWithInterpolations(bodyNode, {quote});
            case 'Catch':
              return new this.ast.Catch(this._toBlock($(o.recovery) || $(o.body)), $(o.variable) || $(o.errorVariable));
            case 'Throw':
              return new this.ast.Throw($(o.expression));
            case 'Literal':
              return new this.ast.Literal($(o.value));
            case 'Assign':
              variable = $(o.variable);
              value = $(o.value);
              context = $(o.context);
              if (context === 'object' && (o.expression != null)) {
                // In object context, 'value' is the property name, 'expression' is the actual value
                variable = $(o.value);
                value = $(o.expression);
                variable = this._asValue(variable);
              }
              if (!((variable != null) && (value != null))) {
                return null;
              }
              return new this.ast.Assign(variable, value, context);
            default:
              return this._unimplemented(nodeType, "AST node type");
          }
        } else if (o.$ary != null) {
          items = $(o.$ary);
          items = Array.isArray(items) ? items : [items];
          return items.filter(function(item) {
            return item != null;
          });
        } else if (o.$use != null) {
          // $use supports 'token' or nested directive
          if (o.$use === 'token') {
            if (typeof lookup === 'function' && (lookup.value != null)) {
              resolvedValue = lookup.value;
            } else {
              resolvedValue = (ref7 = (ref8 = lookup(0)) != null ? ref8.value : void 0) != null ? ref7 : 'unknown_token';
            }
          } else {
            resolvedValue = $(o.$use);
          }
          if (o.method != null) {
            resolvedValue = (ref9 = typeof resolvedValue[name1 = o.method] === "function" ? resolvedValue[name1]() : void 0) != null ? ref9 : resolvedValue;
          } else if (o.prop != null) {
            resolvedValue = (ref10 = resolvedValue[o.prop]) != null ? ref10 : resolvedValue;
          }
          return resolvedValue;
        } else if (o.$ops != null) {
          switch (o.$ops) {
            case 'value':
              // Add accessor/property to Value node
              if (o.add != null) {
                target = $(o.add[0]);
                accessor = $(o.add[1]);
                target = this._asValue(target);
                if ((accessor != null ? accessor.traverseChildren : void 0) != null) {
                  target.add([accessor]);
                }
                return target;
              } else {
                return this._unimplemented("$ops value without add", "$ops");
              }
              break;
            case 'array':
              if (o.append != null) {
                target = $(o.append[0]);
                if (!Array.isArray(target)) {
                  target = [];
                }
                ref11 = o.append.slice(1);
                for (l = 0, len1 = ref11.length; l < len1; l++) {
                  item = ref11[l];
                  if (!(item != null)) {
                    continue;
                  }
                  resolved = $(item);
                  if (Array.isArray(resolved)) {
                    target = target.concat(resolved);
                  } else {
                    target.push(resolved);
                  }
                }
                return target;
              } else if (o.gather != null) {
                result = [];
                ref12 = o.gather;
                for (m = 0, len2 = ref12.length; m < len2; m++) {
                  item = ref12[m];
                  if (!(item != null)) {
                    continue;
                  }
                  resolved = $(item);
                  if (Array.isArray(resolved)) {
                    result = result.concat(resolved);
                  } else if (resolved != null) {
                    result.push(resolved);
                  }
                }
                return result;
              } else {
                return this._unimplemented("$ops array without append/gather", "$ops");
              }
              break;
            case 'if':
              if (o.addElse != null) {
                ifNode = $(o.addElse[0]);
                elseBody = $(o.addElse[1]);
                if (ifNode instanceof this.ast.If && (elseBody != null)) {
                  this._addLocationData(ifNode);
                  this._addLocationData(elseBody);
                  ifNode.addElse(elseBody);
                }
                return ifNode;
              } else {
                return this._unimplemented("$ops if without addElse", "$ops");
              }
              break;
            case 'loop':
              if (o.addSource != null) {
                loopNode = $(o.addSource[0]);
                sourceInfo = $(o.addSource[1]);
                if (loopNode) {
                  this._addLocationData(loopNode);
                  if (sourceInfo) {
                    this._addLocationData(sourceInfo);
                  }
                  loopNode.addSource(sourceInfo);
                }
                return loopNode;
              } else if (o.addBody != null) {
                loopNode = $(o.addBody[0]);
                bodyArg = o.addBody[1];
                // Handle "Body $N" placeholder strings
                if (typeof bodyArg === 'string' && bodyArg.startsWith('Body $')) {
                  position = parseInt(bodyArg.slice(6));
                  body = $(position); // Evaluate position reference
                } else {
                  body = $(bodyArg);
                }
                if (loopNode) {
                  // Convert body to proper Block if needed
                  bodyBlock = body != null ? Array.isArray(body) ? new this.ast.Block(this._filterNodes(body)) : body instanceof this.ast.Block ? body : new this.ast.Block([this._ensureNode(body)].filter(function(n) {
                    return n != null;
                  })) : new this.ast.Block([]);
                  this._addLocationData(loopNode);
                  this._addLocationData(bodyBlock);
                  loopNode.addBody(bodyBlock);
                }
                return loopNode;
              } else {
                return this._unimplemented("$ops loop without addSource/addBody", "$ops");
              }
              break;
            case 'prop':
              if (o.set != null) {
                target = $(o.set.target);
                if ((o.set.property != null) && (target != null)) {
                  target[o.set.property] = $(o.set.value);
                }
                return target;
              } else if (o.addProp != null) {
                target = $(o.addProp[0]);
                property = $(o.addProp[1]);
                if (target instanceof this.ast.Value) {
                  target.add([property]);
                }
                return target;
              } else {
                return this._unimplemented("$ops prop without set/addProp", "$ops");
              }
              break;
            default:
              return this._unimplemented(o.$ops, "$ops type");
          }
        } else {
          if (this._isPlainObject(o)) {
            if (!Object.keys(o).length) {
              return null;
            }
            out = Object.create(null);
            ref13 = Object.entries(o);
            for (q = 0, len3 = ref13.length; q < len3; q++) {
              [k, v] = ref13[q];
              out[k] = $(v);
            }
            return out;
          }
          // Finally, give up...
          return this._unimplemented(o, "directive");
        }
      } else {
        return new this.ast.Literal("/* Unexpected input */");
      }
    }

  };

  module.exports = ES5Backend;

}).call(this);
