// Generated by CoffeeScript 2.7.0
(function() {
  // ==============================================================================
  // ES5 Backend - Solar Directive Processor for CoffeeScript
  // ==============================================================================

  // Converts Solar directives (pure data) to CoffeeScript AST node instances

  // Solar directives are generated by the parser from Solar syntax.coffee rules:
  //   o 'IDENTIFIER', $ast: 'IdentifierLiteral', value: 1

  // This backend converts those directives into actual CoffeeScript AST nodes:
  //   new nodes.IdentifierLiteral(tokenValue)

  // The resulting AST nodes use the existing CoffeeScript compiler pipeline.
  // ==============================================================================
  var ES5Backend,
    hasProp = {}.hasOwnProperty;

  ES5Backend = class ES5Backend {
    constructor(options = {}, ast = {}) {
      var ref, ref1;
      this.options = options;
      this.ast = ast;
      this.compileOptions = {
        bare: (ref = this.options.bare) != null ? ref : true,
        header: (ref1 = this.options.header) != null ? ref1 : false
      };
    }

    // Helper methods
    _stripQuotes(value) {
      if (!((value != null ? value.length : void 0) >= 2 && typeof value === 'string')) {
        return value;
      }
      if ((value[0] === '"' && value[value.length - 1] === '"') || (value[0] === "'" && value[value.length - 1] === "'")) {
        return value.slice(1, -1);
      } else {
        return value;
      }
    }

    reduce(values, positions, stackTop, symbolCount, directive) {
      var handler, lookup, o, prop, store, value;
      lookup = function(index) {
        return values[stackTop - symbolCount + 1 + index];
      };
      store = Object.create(null);
      handler = {
        apply: function(target, thisArg, args) {
          return target.apply(thisArg, args);
        },
        get: function(target, prop, receiver) {
          if (Object.prototype.hasOwnProperty.call(store, prop)) {
            return store[prop];
          }
          if (prop === 'name' || prop === 'length' || prop === 'prototype' || prop === 'caller' || prop === 'arguments') {
            return void 0;
          }
          return Reflect.get(target, prop, receiver);
        },
        set: function(target, prop, value) {
          store[prop] = value;
          return true;
        },
        has: function(target, prop) {
          return Object.prototype.hasOwnProperty.call(store, prop) || prop in target;
        },
        ownKeys: function(target) {
          return Reflect.ownKeys(store).concat(Reflect.ownKeys(target));
        },
        getOwnPropertyDescriptor: function(target, prop) {
          if (Object.prototype.hasOwnProperty.call(store, prop)) {
            return {
              value: store[prop],
              configurable: true,
              enumerable: true,
              writable: true
            };
          } else {
            return Object.getOwnPropertyDescriptor(target, prop);
          }
        }
      };
      o = new Proxy(lookup, handler);
      for (prop in directive) {
        if (!hasProp.call(directive, prop)) continue;
        value = directive[prop];
        o[prop] = value;
      }
      return this.resolve(o);
    }

    resolve(o, lookup = o) {
      var $, accessor, body, bodyNode, context, elseBody, expr, expressions, i, ifNode, item, items, j, k, l, len, len1, len2, len3, loopNode, name, nodeType, obj, objects, param, params, prop, properties, ref, ref1, ref2, ref3, resolved, resolvedValue, result, sourceInfo, subItem, target, type, validProperties, value, variable, wrappedBody;
      if (o == null) {
        // Null/undefined early return
        return o; // null/undefined early return
      }
      type = typeof o;
      // Numbers: only do 1-based lookup for positive integers
      if (type === 'number') {
        if (Number.isInteger(o) && o > 0 && typeof lookup === 'function') {
          return lookup(o - 1);
        }
        return o;
      }
      if (type === 'string' || type === 'boolean') {
        // Strings and booleans return as-is, arrays are resolved recursively
        return o;
      }
      if (Array.isArray(o)) {
        return o.map((val) => {
          return this.resolve(val, lookup);
        });
      }
      // Functions without directive markers are terminals (key fix!)
      if (type === 'function' && !((o.$ast != null) || (o.$use != null) || (o.$ary != null) || (o.$ops != null))) {
        return o;
      }
      // Objects and functions
      if (type === 'object' || type === 'function') {
        if ((o.constructor != null) && ((ref = o.constructor) !== Object && ref !== Function)) {
          return o;
        }
        $ = (val) => {
          return this.resolve(val, lookup); // Local resolver
        };
        if (o.$ast != null) {
          nodeType = o.$ast;
          switch (nodeType) {
            case 'Root':
              return new this.ast.Root((function(b) {
                b.makeReturn();
                return b;
              })(new this.ast.Block($(o.body))));
            case 'IdentifierLiteral':
              return new this.ast.IdentifierLiteral($(o.value));
            case 'NumberLiteral':
              return new this.ast.NumberLiteral($(o.value));
            case 'StringLiteral':
              return new this.ast.StringLiteral(this._stripQuotes($(o.value)));
            case 'BooleanLiteral':
              return new this.ast.BooleanLiteral($(o.value));
            case 'ThisLiteral':
              return new this.ast.ThisLiteral();
            case 'NullLiteral':
              return new this.ast.NullLiteral();
            case 'UndefinedLiteral':
              return new this.ast.UndefinedLiteral();
            case 'InfinityLiteral':
              return new this.ast.InfinityLiteral();
            case 'NaNLiteral':
              return new this.ast.NaNLiteral();
            case 'Value':
              return new this.ast.Value($(o.val));
            case 'Assign':
              variable = $(o.variable);
              value = $(o.value);
              context = $(o.context);
              if (!((variable != null) && (value != null))) {
                // Skip if variable or value is null/undefined (from empty {} placeholders)
                return null;
              }
              return new this.ast.Assign(variable, value, context);
            case 'Op':
              return new this.ast.Op($(o.args[0]), $(o.args[1]), (o.args[2] != null ? $(o.args[2]) : void 0));
            case 'PropertyName':
              return new this.ast.PropertyName($(o.value));
            case 'Access':
              return new this.ast.Access($(o.name), {
                soak: o.soak
              });
            case 'Call':
              return new this.ast.Call($(o.variable), $(o.args));
            case 'Obj':
              properties = $(o.properties);
              if (properties == null) {
                // Empty objects have no properties
                properties = [];
              }
              // Ensure properties is an array
              properties = Array.isArray(properties) ? properties : [properties];
              // Filter out null/undefined items (from empty {} placeholders)
              validProperties = (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = properties.length; i < len; i++) {
                  prop = properties[i];
                  if (prop != null) {
                    results.push(prop);
                  }
                }
                return results;
              })();
              return new this.ast.Obj(validProperties, $(o.generated));
            case 'Arr':
              objects = $(o.objects);
              if (Array.isArray(objects)) {
                // Filter out undefined/null objects
                objects = (function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = objects.length; i < len; i++) {
                    obj = objects[i];
                    if (obj != null) {
                      results.push(obj);
                    }
                  }
                  return results;
                })();
              }
              return new this.ast.Arr(objects);
            case 'Range':
              return new this.ast.Range($(o.from), $(o.to), $(o.exclusive));
            case 'Block':
              expressions = $(o.expressions);
              if (Array.isArray(expressions)) {
                // Filter out undefined/null expressions
                expressions = (function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = expressions.length; i < len; i++) {
                    expr = expressions[i];
                    if (expr != null) {
                      results.push(expr);
                    }
                  }
                  return results;
                })();
              }
              return new this.ast.Block(expressions);
            case 'Return':
              return new this.ast.Return($(o.expression));
            case 'Parens':
              return new this.ast.Parens($(o.body));
            case 'Index':
              return new this.ast.Index($(o.index));
            case 'Slice':
              return new this.ast.Slice($(o.range));
            case 'If':
              return new this.ast.If($(o.condition), $(o.body), $(o.elseBody));
            case 'While':
              return new this.ast.While($(o.condition), $(o.body));
            case 'For':
              return new this.ast.For($(o.body), $(o.source));
            case 'Switch':
              return new this.ast.Switch($(o.subject), $(o.cases), $(o.otherwise));
            case 'Try':
              return new this.ast.Try($(o.attempt), $(o.recovery), $(o.ensure));
            case 'Class':
              return new this.ast.Class($(o.variable), $(o.parent), $(o.body));
            case 'FuncGlyph':
              return new this.ast.FuncGlyph($(o.glyph));
            case 'Param':
              return new this.ast.Param($(o.name), $(o.value), $(o.splat));
            case 'Code':
              params = $(o.params);
              if (Array.isArray(params)) {
                // Filter out undefined/null params
                params = (function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = params.length; i < len; i++) {
                    param = params[i];
                    if (param != null) {
                      results.push(param);
                    }
                  }
                  return results;
                })();
              }
              return new this.ast.Code(params, $(o.body), $(o.funcGlyph), $(o.paramStart));
            case 'Splat':
              return new this.ast.Splat($(o.name));
            case 'Existence':
              return new this.ast.Existence($(o.expression));
            case 'RegexLiteral':
              return new this.ast.RegexLiteral($(o.value));
            case 'StatementLiteral':
              return new this.ast.StatementLiteral($(o.value));
            case 'PassthroughLiteral':
              return new this.ast.PassthroughLiteral($(o.value));
            case 'Interpolation':
              return new this.ast.Interpolation($(o.expression));
            case 'StringWithInterpolations':
              // Body should contain Value-wrapped StringLiterals and Interpolation nodes
              body = $(o.body);
              // Ensure body is an array
              body = Array.isArray(body) ? body : [body];
              // Wrap elements properly
              wrappedBody = (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = body.length; i < len; i++) {
                  item = body[i];
                  if (item == null) {
                    // Skip undefined/null items
                    continue;
                  }
                  // If it's already properly formed, use it
                  if (item instanceof this.ast.Value || item instanceof this.ast.Interpolation) {
                    results.push(item);
                  // If it's a StringLiteral, wrap in Value
                  } else if (item instanceof this.ast.StringLiteral) {
                    results.push(new this.ast.Value(item));
                  // If it's a plain object with $ast, resolve it
                  } else if (item.$ast != null) {
                    resolved = $(item);
                    if (resolved instanceof this.ast.StringLiteral) {
                      results.push(new this.ast.Value(resolved));
                    } else {
                      results.push(resolved);
                    }
                  } else {
                    results.push(item);
                  }
                }
                return results;
              }).call(this);
              // Filter out undefined items from continue statements
              wrappedBody = (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = wrappedBody.length; i < len; i++) {
                  item = wrappedBody[i];
                  if (item != null) {
                    results.push(item);
                  }
                }
                return results;
              })();
              return new this.ast.StringWithInterpolations(new this.ast.Block(wrappedBody), {
                quote: $(o.quote)
              });
            case 'Catch':
              return new this.ast.Catch($(o.body), $(o.errorVariable));
            case 'Throw':
              return new this.ast.Throw($(o.expression));
            case 'Literal':
              return new this.ast.Literal($(o.value));
            default:
              console.warn("ES5Backend: Unimplemented AST node type:", nodeType);
              return new this.ast.Literal(`/* Unimplemented: ${nodeType} */`);
          }
        } else if (o.$ary != null) {
          items = $(o.$ary);
          // Ensure we always return an array
          items = Array.isArray(items) ? items : [items];
          // Important: filter out undefined/null items (common from optional grammar rules)
          return items.filter(function(item) {
            return item != null;
          });
        } else if (o.$use != null) {
          resolvedValue = $(o.$use);
          if (o.method != null) {
            resolvedValue = (ref1 = typeof resolvedValue[name = o.method] === "function" ? resolvedValue[name]() : void 0) != null ? ref1 : resolvedValue;
          }
          return resolvedValue;
        } else if (o.$ops != null) {
          switch (o.$ops) {
            case 'value':
              // Add accessor/property to Value node
              if (o.add != null) {
                target = $(o.add[0]);
                accessor = $(o.add[1]);
                if (!(target instanceof this.ast.Value)) {
                  target = new this.ast.Value(target);
                }
                if ((accessor != null ? accessor.traverseChildren : void 0) != null) {
                  target.add([accessor]);
                }
                return target;
              } else {
                console.warn("ES5Backend: $ops value without add:", o);
                return new this.ast.Literal("/* $ops: value */");
              }
              break;
            case 'array':
              // Array operations - ensure all items are resolved
              if (o.append != null) {
                target = $(o.append[0]);
                if (!Array.isArray(target)) {
                  target = [];
                }
                ref2 = o.append.slice(1);
                for (i = 0, len = ref2.length; i < len; i++) {
                  item = ref2[i];
                  if (!(item != null)) {
                    continue;
                  }
                  resolved = $(item);
                  // Handle arrays properly - flatten if needed
                  if (Array.isArray(resolved)) {
                    for (j = 0, len1 = resolved.length; j < len1; j++) {
                      subItem = resolved[j];
                      // Ensure each subItem is fully resolved
                      target.push(subItem != null ? $(subItem) : subItem);
                    }
                  } else if (resolved != null) {
                    target.push(resolved);
                  }
                }
                return target;
              } else if (o.gather != null) {
                result = [];
                ref3 = o.gather;
                for (k = 0, len2 = ref3.length; k < len2; k++) {
                  item = ref3[k];
                  if (!(item != null)) {
                    continue;
                  }
                  resolved = $(item);
                  if (Array.isArray(resolved)) {
                    for (l = 0, len3 = resolved.length; l < len3; l++) {
                      subItem = resolved[l];
                      // Ensure each subItem is fully resolved
                      result.push(subItem != null ? $(subItem) : subItem);
                    }
                  } else if (resolved != null) {
                    result.push(resolved);
                  }
                }
                return result;
              } else {
                console.warn("ES5Backend: $ops array without append/gather:", o);
                return new this.ast.Literal("/* $ops: array */");
              }
              break;
            case 'if':
              // If operations for adding else clauses
              if (o.addElse != null) {
                ifNode = $(o.addElse[0]);
                elseBody = $(o.addElse[1]);
                if (ifNode instanceof this.ast.If) {
                  ifNode.addElse(elseBody);
                }
                return ifNode;
              } else {
                console.warn("ES5Backend: $ops if without addElse:", o);
                return new this.ast.Literal("/* $ops: if */");
              }
              break;
            case 'loop':
              // Loop operations
              if (o.addSource != null) {
                loopNode = $(o.addSource[0]);
                sourceInfo = $(o.addSource[1]);
                if (loopNode) {
                  loopNode.addSource(sourceInfo);
                }
                return loopNode;
              } else if (o.addBody != null) {
                loopNode = $(o.addBody[0]);
                bodyNode = $(o.addBody[1]);
                if (loopNode) {
                  loopNode.addBody(bodyNode);
                }
                return loopNode;
              } else {
                console.warn("ES5Backend: $ops loop without addSource/addBody:", o);
                return new this.ast.Literal("/* $ops: loop */");
              }
              break;
            default:
              console.warn("ES5Backend: $ops not yet implemented:", o.$ops);
              return new this.ast.Literal(`/* $ops: ${o.$ops} */`);
          }
        } else {
          // Empty objects {} are grammar placeholders - return null to signal "no value"
          if (typeof o === 'object' && o.constructor === Object && Object.keys(o).length === 0) {
            return null;
          }
          console.warn("ES5Backend: Unknown directive:", o);
          return new this.ast.Literal("/* Unknown directive */");
        }
      } else {
        return new this.ast.Literal("/* Unexpected input */");
      }
    }

  };

  module.exports = ES5Backend;

}).call(this);
