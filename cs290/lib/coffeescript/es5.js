// Generated by CoffeeScript 2.7.0
(function() {
  // ==============================================================================
  // ES5 Backend - Solar Directive Processor for CoffeeScript
  // ==============================================================================

  // Converts Solar directives (pure data) to CoffeeScript AST node instances

  // Solar directives are generated by the parser from Solar syntax.coffee rules:
  //   o 'IDENTIFIER', $ast: 'IdentifierLiteral', value: 1

  // This backend converts those directives into actual CoffeeScript AST nodes:
  //   new nodes.IdentifierLiteral(tokenValue)

  // The resulting AST nodes use the existing CoffeeScript compiler pipeline.
  // ==============================================================================
  var ES5Backend,
    hasProp = {}.hasOwnProperty;

  ES5Backend = class ES5Backend {
    constructor(options = {}, ast = {}) {
      var ref, ref1;
      this.options = options;
      this.ast = ast;
      this.compileOptions = {
        bare: (ref = this.options.bare) != null ? ref : true,
        header: (ref1 = this.options.header) != null ? ref1 : false
      };
    }

    // Helper methods
    _stripQuotes(value) {
      if (!((value != null ? value.length : void 0) >= 2 && typeof value === 'string')) {
        return value;
      }
      if ((value[0] === '"' && value[value.length - 1] === '"') || (value[0] === "'" && value[value.length - 1] === "'")) {
        return value.slice(1, -1);
      } else {
        return value;
      }
    }

    reduce(values, positions, stackTop, symbolCount, directive) {
      var o, prop, value;
      o = function(index) {
        return values[stackTop - symbolCount + 1 + index];
      };
      for (prop in directive) {
        if (!hasProp.call(directive, prop)) continue;
        value = directive[prop];
        if (prop === 'name' || prop === 'length' || prop === 'prototype') {
          continue;
        }
        o[prop] = value;
      }
      return this.resolve(o);
    }

    resolve(value, lookup = value) {
      var $, items, name, nodeType, o, ref, ref1, ref2, ref3, resolvedValue, useLookup;
      if (typeof value === 'number' && (lookup != null)) {
        return lookup(value - 1);
      }
      if (typeof value === 'number') {
        return value;
      }
      if ((ref = typeof value) === 'string' || ref === 'boolean') {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map((item) => {
          return this.resolve(item, lookup);
        });
      }
      if ((value != null) && (typeof value === 'object' || typeof value === 'function')) {
        o = value;
        if (((ref1 = o.constructor) != null ? ref1.name : void 0) && ((ref2 = o.constructor.name) !== 'Object' && ref2 !== 'Function')) { // AST nodes
          return o;
        }
        useLookup = typeof value === 'function' ? value : lookup;
        $ = (val) => {
          return this.resolve(val, useLookup); // Local resolver
        };
        if (o.$ast != null) {
          nodeType = o.$ast;
          switch (nodeType) {
            case 'Root':
              return new this.ast.Root((function(b) {
                b.makeReturn();
                return b;
              })(new this.ast.Block($(o.body))));
            case 'IdentifierLiteral':
              return new this.ast.IdentifierLiteral($(o.value));
            case 'NumberLiteral':
              return new this.ast.NumberLiteral($(o.value));
            case 'StringLiteral':
              return new this.ast.StringLiteral(this._stripQuotes($(o.value)));
            case 'Value':
              return new this.ast.Value($(o.val));
            case 'Assign':
              return new this.ast.Assign($(o.variable), $(o.value));
            case 'Op':
              return new this.ast.Op($(o.args[0]), $(o.args[1]), (o.args[2] != null ? $(o.args[2]) : void 0));
            case 'Literal':
              return new this.ast.Literal($(o.value));
            default:
              console.warn("ES5Backend: Unimplemented AST node type:", nodeType);
              return new this.ast.Literal(`/* Unimplemented: ${nodeType} */`);
          }
        } else if (o.$ary != null) {
          items = $(o.$ary);
          if (Array.isArray(items)) {
            return items;
          } else {
            return [items];
          }
        } else if (o.$use != null) {
          resolvedValue = $(o.$use);
          if (o.method != null) {
            resolvedValue = (ref3 = typeof resolvedValue[name = o.method] === "function" ? resolvedValue[name]() : void 0) != null ? ref3 : resolvedValue;
          }
          return resolvedValue;
        } else if (o.$ops != null) {
          console.warn("ES5Backend: $ops not yet implemented:", o.$ops);
          return new this.ast.Literal(`/* $ops: ${o.$ops} */`);
        } else {
          console.warn("ES5Backend: Unknown directive:", o);
          return new this.ast.Literal("/* Unknown directive */");
        }
      } else {
        return new this.ast.Literal("/* Unexpected input */");
      }
    }

  };

  module.exports = ES5Backend;

}).call(this);
