// Generated by CoffeeScript 2.7.0
(function() {
  // ==============================================================================
  // ES5 Backend - Converts Solar directives (pure data) to CoffeeScript AST nodes
  // ==============================================================================
  var ES5Backend,
    hasProp = {}.hasOwnProperty;

  ES5Backend = class ES5Backend {
    constructor(options1 = {}, ast = {}) {
      this.options = options1;
      this.ast = ast;
      this.cache = new Map();
      this.currentDirective = null;
      this.currentType = null;
      this.currentRule = null;
    }

    // Add minimal location data to node to avoid errors in AST operations
    _addLocationData(node) {
      if (typeof node === 'object' && node !== null) {
        if (node.locationData == null) {
          node.locationData = {
            first_line: 0,
            first_column: 0,
            last_line: 0,
            last_column: 0,
            range: [0, 0]
          };
        }
        if (typeof node.updateLocationDataIfMissing === "function") {
          node.updateLocationDataIfMissing(node.locationData);
        }
      }
      return node;
    }

    // Filter null/undefined nodes from an array
    _filterNodes(nodes) {
      if (nodes == null) {
        return [];
      }
      return nodes.filter(function(n) {
        if (Array.isArray(nodes)) {
          return n != null;
        }
      });
      return [nodes];
    }

    // Main entry point (called by parser as 'reduce')
    reduce(values, positions, stackTop, symbolCount, directive) {
      var handler, lookup, o, outName, ref, ref1, ref2, result, util;
      // Create lookup function to access stack values
      lookup = function(index) {
        return values[stackTop - symbolCount + 1 + index];
      };
      this.currentDirective = directive;
      this.currentType = directive != null ? directive.$ast : void 0;
      this.currentRule = directive;
      this.currentLookup = lookup; // Store lookup for use in $()
      
      // Create smart proxy that auto-resolves properties
      handler = {
        get: function(target, prop) {
          var idx;
          if (prop in target) {
            // Return directive properties first
            return target[prop];
          }
          // Handle numeric indices for stack access
          if (typeof prop === 'string' && /^\d+$/.test(prop)) {
            idx = parseInt(prop, 10) - 1; // Convert to 0-based
            if (idx >= 0) {
              return lookup(idx);
            }
          }
          // Handle $N syntax
          if (typeof prop === 'string' && prop[0] === '$') {
            idx = parseInt(prop.slice(1), 10) - 1; // Convert to 0-based
            if (idx >= 0) {
              return lookup(idx);
            }
          }
          return void 0;
        }
      };
      // Create smart directive object
      o = new Proxy(directive, handler);
      // Process the directive
      result = this.process(o);
      if (typeof process !== "undefined" && process !== null ? (ref = process.env) != null ? ref.SOLAR_DEBUG : void 0 : void 0) {
        util = require('util');
        outName = (ref1 = result != null ? (ref2 = result.constructor) != null ? ref2.name : void 0 : void 0) != null ? ref1 : typeof result;
        console.log("[Solar] result:", outName, util.inspect(result, {
          depth: 3,
          colors: true
        }));
      }
      return result;
    }

    // Process a directive with smart resolution
    process(o) {
      if (o.$ast != null) {
        return this.processAst(o); // AST first (most common)
      }
      if (o.$ops != null) {
        return this.processOps(o); // Operations second
      }
      if (o.$use != null) {
        return this.processUse(o); // Use is third
      }
      if (o.$ary != null) {
        return this.processAry(o); // Array last (simplest)
      }
      return this.$(o);
    }

    // Smart resolver - handles all types of references
    $(value) {
      var key, result, val;
      if (value == null) {
        return value;
      }
      // Numbers are stack positions (1-based)
      if (typeof value === 'number') {
        if (this.currentLookup) {
          return this.currentLookup(value - 1);
        }
        return value;
      }
      // Arrays - resolve each item
      if (Array.isArray(value)) {
        return value.map((item) => {
          return this.$(item);
        });
      }
      // Objects with directives - process them
      if (typeof value === 'object') {
        if (value.$ast || value.$ops || value.$use || value.$ary) {
          return this.process(value);
        }
        // Regular objects - resolve properties
        result = {};
        for (key in value) {
          if (!hasProp.call(value, key)) continue;
          val = value[key];
          result[key] = this.$(val);
        }
        return result;
      }
      // Everything else passes through
      return value;
    }

    // Process $ary directives
    processAry(o) {
      var items;
      items = this.$(o.$ary);
      if (Array.isArray(items)) {
        return items;
      } else {
        return [items];
      }
    }

    // Process $use directives
    processUse(o) {
      var name1, ref, ref1, target;
      target = this.$(o.$use);
      if (o.method != null) {
        return (ref = target != null ? typeof target[name1 = o.method] === "function" ? target[name1]() : void 0 : void 0) != null ? ref : target;
      }
      if (o.prop != null) {
        return (ref1 = target != null ? target[o.prop] : void 0) != null ? ref1 : target;
      }
      if (o.index != null) {
        if (target != null) {
          return target != null ? target[this.$(o.index)] : void 0;
        }
      }
      return target;
    }

    // Process $ops directives
    processOps(o) {
      var body, elseBody, i, idx, ifNode, item, len, loopNode, ref, resolved, result, sourceInfo;
      switch (o.$ops) {
        case 'array':
          result = [];
          if (o.append != null) {
            ref = o.append;
            for (i = 0, len = ref.length; i < len; i++) {
              item = ref[i];
              resolved = this.$(item);
              if (Array.isArray(resolved)) {
                result.push(...resolved);
              } else if (resolved != null) {
                result.push(resolved);
              }
            }
          }
          return result;
        case 'if':
          ifNode = new this.ast.If(this.$(o.condition), this.$(o.body), {
            soak: this.$(o.soak),
            postfix: this.$(o.postfix)
          });
          if (o.elseBody != null) {
            elseBody = this.$(o.elseBody);
            this._addLocationData(ifNode);
            this._addLocationData(elseBody);
            ifNode.addElse(elseBody);
          }
          return ifNode;
        case 'loop':
          switch (o.type) {
            case 'addSource':
              loopNode = this.$(o.loop);
              sourceInfo = this.$(o.source);
              this._addLocationData(loopNode);
              this._addLocationData(sourceInfo);
              loopNode.addSource(sourceInfo);
              return loopNode;
            case 'addBody':
              loopNode = this.$(o.loop);
              body = this.$(o.body);
              // Handle "Body $N" placeholder strings
              if (typeof body === 'string' && body.startsWith('Body $')) {
                idx = parseInt(body.slice(6)) - 1;
                if (idx >= 0) {
                  body = this.currentDirective[idx + 1];
                }
              }
              // Ensure body is a Block
              if (!(body instanceof this.ast.Block)) {
                body = new this.ast.Block(this._filterNodes(Array.isArray(body) ? body : [body]));
              }
              this._addLocationData(loopNode);
              this._addLocationData(body);
              loopNode.addBody(body);
              return loopNode;
            default:
              console.warn("Unknown loop operation:", o.type);
              return null;
          }
          break;
        default:
          console.warn("Unknown $ops:", o.$ops);
          return null;
      }
    }

    // Process $ast directives - the main AST node creation
    processAst(o) {
      var args, body, elseBody, exclusive, expression, ifNode, index, name, options, ref, ref1, whileNode;
      switch (o.$ast) {
        case '@':
          // Pass-through directives that use the node type from context
          switch (this.currentType) {
            case 'Root':
              body = this.$(o.body);
              if (Array.isArray(body)) {
                // Wrap array in Block if needed
                body = new this.ast.Block(body);
              }
              return new this.ast.Root(body);
            case 'Block':
              return new this.ast.Block(this.$(o.expressions) || []);
            case 'Splat':
              return new this.ast.Splat(this.$(o.name), {
                postfix: this.$(o.postfix)
              });
            default:
              console.warn("Unknown @ node type:", this.currentType);
              return null;
          }
          break;
        // Literals
        case 'Literal':
          return new this.ast.Literal(this.$(o.value));
        case 'NumberLiteral':
          return new this.ast.NumberLiteral(this.$(o.value));
        case 'StringLiteral':
          return new this.ast.StringLiteral(this.$(o.value));
        case 'StringWithInterpolations':
          return new this.ast.StringWithInterpolations(this.$(o.body));
        case 'BooleanLiteral':
          return new this.ast.BooleanLiteral(this.$(o.value));
        case 'IdentifierLiteral':
          return new this.ast.IdentifierLiteral(this.$(o.value));
        case 'PropertyName':
          return new this.ast.PropertyName(this.$(o.value));
        case 'StatementLiteral':
          return new this.ast.StatementLiteral(this.$(o.value));
        case 'ThisLiteral':
          return new this.ast.ThisLiteral();
        case 'UndefinedLiteral':
          return new this.ast.UndefinedLiteral();
        case 'NullLiteral':
          return new this.ast.NullLiteral();
        case 'InfinityLiteral':
          return new this.ast.InfinityLiteral();
        case 'NaNLiteral':
          return new this.ast.NaNLiteral();
        // Value and Access
        case 'Value':
          return this._buildValue(this.$(o.base), (ref = this.$(o.properties)) != null ? ref : []);
        case 'Access':
          name = this.$(o.name);
          if (name instanceof this.ast.IdentifierLiteral) {
            name = new this.ast.PropertyName(name.value);
          }
          return new this.ast.Access(name, this.$(o.soak));
        case 'Index':
          return new this.ast.Index(this.$(o.index));
        // Operations
        case 'Op':
          args = o.args.map((arg) => {
            return this.$(arg);
          });
          if ((o.invertOperator != null) || (o.originalOperator != null)) {
            options = {};
            if (o.invertOperator != null) {
              options.invertOperator = this.$(o.invertOperator);
            }
            if (o.originalOperator != null) {
              options.originalOperator = this.$(o.originalOperator);
            }
            args.push(options);
          }
          return new this.ast.Op(...args);
        case 'Assign':
          return new this.ast.Assign(this.$(o.variable), this.$(o.value), this.$(o.operator));
        // Control Flow
        case 'If':
          ifNode = new this.ast.If(this.$(o.condition), this.$(o.body), {
            soak: this.$(o.soak),
            postfix: this.$(o.postfix)
          });
          if (o.elseBody != null) {
            elseBody = this.$(o.elseBody);
            this._addLocationData(ifNode);
            this._addLocationData(elseBody);
            ifNode.addElse(elseBody);
          }
          return ifNode;
        case 'While':
          whileNode = new this.ast.While(this.$(o.condition), {
            invert: this.$(o.invert),
            guard: this.$(o.guard)
          });
          if (whileNode.body == null) {
            whileNode.body = new this.ast.Block([]);
          }
          return whileNode;
        case 'For':
          name = this._ensureNode(this.$(o.name));
          if (o.index != null) {
            index = this._ensureNode(this.$(o.index));
          }
          return new this.ast.For(name, this.$(o.source), index);
        case 'Switch':
          return new this.ast.Switch(this.$(o.subject), this.$(o.cases) || [], this.$(o.otherwise));
        case 'When':
          return new this.ast.When(this.$(o.conditions), this.$(o.body));
        // Collections
        case 'Obj':
          return new this.ast.Obj(this.$(o.properties) || [], this.$(o.generated));
        case 'Arr':
          return new this.ast.Arr(this.$(o.objects) || []);
        case 'Range':
          exclusive = this.$(o.exclusive) ? 'exclusive' : null;
          return new this.ast.Range(this.$(o.from), this.$(o.to), exclusive);
        // Functions
        case 'Code':
          return new this.ast.Code(this.$(o.params) || [], this.$(o.body));
        case 'Param':
          return new this.ast.Param(this.$(o.name), this.$(o.value), this.$(o.splat));
        case 'Call':
          return new this.ast.Call(this.$(o.variable), this.$(o.args) || [], this.$(o.soak));
        case 'Return':
          return new this.ast.Return(this.$(o.expression));
        case 'Yield':
          expression = this.$(o.expression);
          if (expression == null) {
            expression = new this.ast.Value(new this.ast.Literal(''));
          }
          return new this.ast.Yield(expression);
        // Root and Block
        case 'Root':
          body = this.$(o.body);
          if (Array.isArray(body)) {
            // Wrap array in Block if needed
            body = new this.ast.Block(body);
          }
          return new this.ast.Root(body);
        case 'Block':
          return new this.ast.Block((ref1 = this.$(o.expressions)) != null ? ref1 : []);
        // Classes
        case 'Class':
          return new this.ast.Class(this.$(o.variable), this.$(o.parent), this.$(o.body));
        case 'ClassProtoAssignOp':
          return new this.ast.ClassProtoAssignOp(this.$(o.variable), this.$(o.value));
        // Try/Catch
        case 'Try':
          return new this.ast.Try(this.$(o.attempt), this.$(o.errorVariable), this.$(o.recovery), this.$(o.ensure));
        // Other
        case 'Existence':
          return new this.ast.Existence(this.$(o.expression));
        case 'Parens':
          return new this.ast.Parens(this.$(o.body));
        case 'Expansion':
          return new this.ast.Expansion();
        case 'ImportDeclaration':
          return new this.ast.ImportDeclaration(this.$(o.clause), this.$(o.source));
        case 'ExportDeclaration':
          return new this.ast.ExportDeclaration(this.$(o.clause), this.$(o.source), this.$(o.default));
        default:
          console.warn("Unknown $ast type:", o.$ast);
          return null;
      }
    }

    // Build a Value from base + properties
    _buildValue(base, properties) {
      var props;
      if (base instanceof this.ast.Value) {
        props = this._filterNodes((Array.isArray(properties) ? properties : []));
        if (props.length) {
          base.add(props);
        }
        return base;
      }
      if ((base != null) && !(base instanceof this.ast.Base)) {
        base = this._ensureNode(base);
      }
      props = this._filterNodes((Array.isArray(properties) ? properties : []));
      if (props.length) {
        return new this.ast.Value(base, props);
      } else {
        return new this.ast.Value(base);
      }
    }

    // Helper to ensure value is a proper node
    _ensureNode(value) {
      if (value instanceof this.ast.Base) {
        return value;
      }
      if (typeof value === 'string') {
        return new this.ast.IdentifierLiteral(value);
      }
      if (typeof value === 'number') {
        return new this.ast.NumberLiteral(value);
      }
      if (typeof value === 'boolean') {
        return new this.ast.BooleanLiteral(value);
      }
      return value;
    }

  };

  module.exports = ES5Backend;

}).call(this);
