// Generated by CoffeeScript 2.7.0
(function() {
  // ==============================================================================
  // ES5 Backend - Solar Directive Processor for CoffeeScript
  // ==============================================================================

  // Converts Solar directives (pure data) to CoffeeScript AST node instances

  // Solar directives are generated by the parser from Solar syntax.coffee rules:
  //   o 'IDENTIFIER', $ast: 'IdentifierLiteral', value: 1

  // This backend converts those directives into actual CoffeeScript AST nodes:
  //   new nodes.IdentifierLiteral(tokenValue)

  // The resulting AST nodes use the existing CoffeeScript compiler pipeline.
  // ==============================================================================
  var ES5Backend;

  ES5Backend = class ES5Backend {
    constructor(options = {}, ast = {}) {
      var ref, ref1;
      this.options = options;
      this.ast = ast;
      // @ast contains AST node class definitions (constructors)
      // @options contains compilation options, analysis settings, etc.
      this.compileOptions = {
        bare: (ref = this.options.bare) != null ? ref : true,
        header: (ref1 = this.options.header) != null ? ref1 : false
      };
    }

    // Main entry point called by r() function in generated parser
    // Converts Solar directives to CoffeeScript AST node instances
    reduce(values, positions, stackTop, symbolCount, directive) {
      var frame, i, j, offset, ref;
      // Build frame from parser stacks (same pattern as working implementation)
      frame = [];
      for (i = j = 0, ref = symbolCount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        offset = stackTop - symbolCount + i + 1;
        frame.push({
          value: values[offset],
          pos: positions[offset]
        });
      }
      // Evaluate Solar directive and return AST node
      return this.evaluateDirective(directive, frame);
    }

    // Core Solar directive evaluator
    evaluateDirective(directive, frame) {
      var block, body, bodyArray, filteredBody, items, nodeType, ref, ref1, val, value;
      // Handle position references (1, 2, 3, ...)
      if (typeof directive === 'number') {
        return (ref = frame[directive - 1]) != null ? ref.value : void 0; // 1-based â†’ 0-based
      }
      if ((ref1 = typeof directive) === 'string' || ref1 === 'boolean') {
        
        // Handle primitives
        return directive;
      }
      // Handle arrays
      if (Array.isArray(directive)) {
        return directive.map((item) => {
          return this.evaluateDirective(item, frame);
        });
      }
      // Handle Solar directives (objects with special properties)
      if ((directive != null) && typeof directive === 'object') {
        // $ast directive - create AST node
        if (directive.$ast != null) {
          nodeType = directive.$ast;
          switch (nodeType) {
            case 'Root':
              body = this.evaluateDirective(directive.body, frame);
              bodyArray = Array.isArray(body) ? body : [body];
              filteredBody = bodyArray.filter(function(item) {
                return item != null;
              });
              block = new this.ast.Block(filteredBody);
              if (filteredBody.length > 0) { // Make final expression return
                block.makeReturn();
              }
              return new this.ast.Root(block);
            case 'IdentifierLiteral':
              value = this.evaluateDirective(directive.value, frame);
              return new this.ast.IdentifierLiteral(value);
            case 'NumberLiteral':
              value = this.evaluateDirective(directive.value, frame);
              return new this.ast.NumberLiteral(value);
            case 'Value':
              val = this.evaluateDirective(directive.val, frame);
              return new this.ast.Value(val);
            case 'Literal':
              value = this.evaluateDirective(directive.value, frame);
              return new this.ast.Literal(value);
            default:
              // Fallback for unimplemented node types
              console.warn("ES5Backend: Unimplemented AST node type:", nodeType);
              return new this.ast.Literal(`/* Unimplemented: ${nodeType} */`);
          }
        // $ary directive - return array
        } else if (directive.$ary != null) {
          items = this.evaluateDirective(directive.$ary, frame);
          if (Array.isArray(items)) {
            return items;
          } else {
            return [items];
          }
        // $use directive - use existing value
        } else if (directive.$use != null) {
          return this.evaluateDirective(directive.$use, frame);
        // $ops directive - operation (array append, etc.)
        } else if (directive.$ops != null) {
          console.warn("ES5Backend: $ops not yet implemented:", directive.$ops);
          return new this.ast.Literal(`/* $ops: ${directive.$ops} */`);
        } else {
          // Unknown directive
          console.warn("ES5Backend: Unknown directive:", directive);
          return new this.ast.Literal("/* Unknown directive */");
        }
      } else {
        // Fallback for unexpected input
        return new this.ast.Literal("/* Unexpected input */");
      }
    }

  };

  module.exports = ES5Backend;

}).call(this);
