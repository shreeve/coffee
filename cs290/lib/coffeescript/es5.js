// Generated by CoffeeScript 2.7.0
(function() {
  // ==============================================================================
  // ES5 Backend - Converts Solar directives (pure data) to CoffeeScript AST nodes
  // ==============================================================================
  var ES5Backend,
    hasProp = {}.hasOwnProperty;

  ES5Backend = class ES5Backend {
    constructor(options1 = {}, ast = {}) {
      this.options = options1;
      this.ast = ast;
      this.cache = new Map();
      this.currentDirective = null;
      this.currentRule = null;
    }

    // Helper to strip quotes from string literals
    _stripQuotes(str) {
      var ref;
      if (str == null) {
        return str;
      }
      // Remove surrounding quotes if present
      if (((ref = str[0]) === '"' || ref === "'") && str[0] === str[str.length - 1]) {
        return str.slice(1, -1);
      } else {
        return str;
      }
    }

    // Helper to ensure node has location data to avoid errors in AST operations
    _ensureLocationData(node) {
      if (typeof node === 'object' && node !== null) {
        if (node.locationData == null) {
          node.locationData = {
            first_line: 0,
            first_column: 0,
            last_line: 0,
            last_column: 0,
            range: [0, 0]
          };
        }
        if (typeof node.updateLocationDataIfMissing === "function") {
          node.updateLocationDataIfMissing(node.locationData);
        }
      }
      return node;
    }

    // Helper to convert primitive values to AST nodes
    _toNode(value) {
      if (value instanceof this.ast.Base) {
        return value;
      }
      if (typeof value === 'string') {
        return new this.ast.IdentifierLiteral(value);
      }
      if (typeof value === 'number') {
        return new this.ast.NumberLiteral(value);
      }
      if (typeof value === 'boolean') {
        return new this.ast.BooleanLiteral(value);
      }
      return value;
    }

    // Helper to convert base + properties to Value node
    _toValue(base, properties) {
      var props;
      props = Array.isArray(properties) ? properties : [];
      // Handle existing Value
      if (base instanceof this.ast.Value) {
        if (props.length) {
          base.add(props);
        }
        return base;
      }
      if ((base != null) && !(base instanceof this.ast.Base)) {
        // Ensure base is a node
        base = this._toNode(base);
      }
      return new this.ast.Value(base, props);
    }

    // Main entry point (called by parser as 'reduce')
    reduce(values, positions, stackTop, symbolCount, directive) {
      var handler, lookup, o, outName, ref, ref1, ref2, ref3, result, util;
      // Create lookup function to access stack values
      lookup = function(index) {
        return values[stackTop - symbolCount + 1 + index];
      };
      this.currentDirective = directive;
      this.currentRule = directive;
      this.currentLookup = lookup; // Store lookup for use in $()
      
      // Create smart proxy that auto-resolves properties
      handler = {
        get: function(target, prop) {
          var idx;
          if (prop in target) {
            // Return directive properties first
            return target[prop];
          }
          // Handle numeric indices for stack access
          if (typeof prop === 'string' && /^\d+$/.test(prop)) {
            idx = parseInt(prop, 10) - 1; // Convert to 0-based
            if (idx >= 0) {
              return lookup(idx);
            }
          }
          // Handle $N syntax
          if (typeof prop === 'string' && prop[0] === '$') {
            idx = parseInt(prop.slice(1), 10) - 1; // Convert to 0-based
            if (idx >= 0) {
              return lookup(idx);
            }
          }
          return void 0;
        }
      };
      // Create smart directive object
      o = new Proxy(directive, handler);
      // Process the directive
      result = this.process(o);
      if ((ref = global.process) != null ? (ref1 = ref.env) != null ? ref1.SOLAR_DEBUG : void 0 : void 0) {
        util = require('util');
        outName = (ref2 = result != null ? (ref3 = result.constructor) != null ? ref3.name : void 0 : void 0) != null ? ref2 : typeof result;
        console.log("[Solar] result:", outName, util.inspect(result, {
          depth: 3,
          colors: true
        }));
      }
      return result;
    }

    // Process a directive with smart resolution, ordered by most common to least
    process(o) {
      if (o.$ast != null) {
        return this.processAst(o);
      }
      if (o.$use != null) {
        return this.processUse(o);
      }
      if (o.$ops != null) {
        return this.processOps(o);
      }
      if (o.$arr != null) {
        return this.processArr(o);
      }
      return this.$(o);
    }

    // Smart resolver - handles all types of references
    $(value) {
      var key, result, val;
      if (value == null) {
        return value;
      }
      // Numbers are stack positions (1-based)
      if (typeof value === 'number') {
        if (this.currentLookup) {
          return this.currentLookup(value - 1);
        }
        return value;
      }
      // Arrays - resolve each item
      if (Array.isArray(value)) {
        return value.map((item) => {
          return this.$(item);
        });
      }
      // Objects with directives - process them
      if (typeof value === 'object') {
        if (value.$ast || value.$ops || value.$use || value.$arr) {
          return this.process(value);
        }
        // Regular objects - resolve properties
        result = {};
        for (key in value) {
          if (!hasProp.call(value, key)) continue;
          val = value[key];
          result[key] = this.$(val);
        }
        return result;
      }
      // Everything else passes through
      return value;
    }

    // Process $arr directives
    processArr(o) {
      var items;
      items = this.$(o.$arr);
      if (Array.isArray(items)) {
        return items;
      } else {
        return [items];
      }
    }

    // Process $use directives
    processUse(o) {
      var name1, target;
      target = this.$(o.$use);
      if (o.method != null) {
        return target != null ? typeof target[name1 = o.method] === "function" ? target[name1]() : void 0 : void 0;
      }
      if (o.prop != null) {
        return target != null ? target[o.prop] : void 0;
      }
      if (o.index != null) {
        return target != null ? target[o.index] : void 0;
      }
      return target;
    }

    // Process $ops directives
    processOps(o) {
      var accessor, body, elseBody, i, ifNode, item, len, loopNode, ref, ref1, ref2, ref3, ref4, ref5, resolved, result, sourceInfo, util, value;
      switch (o.$ops) {
        case 'array':
          result = [];
          if (o.append != null) {
            ref = o.append;
            for (i = 0, len = ref.length; i < len; i++) {
              item = ref[i];
              resolved = this.$(item);
              if (Array.isArray(resolved)) {
                result.push(...resolved);
              } else if (resolved != null) {
                result.push(resolved);
              }
            }
          }
          return result;
        case 'if':
          // Handle addElse operation for if-else chains
          if (o.addElse != null) {
            [ifNode, elseBody] = o.addElse.map((item) => {
              return this.$(item);
            });
            this._ensureLocationData(ifNode);
            this._ensureLocationData(elseBody);
            ifNode.addElse(elseBody);
            return ifNode;
          }
          break;
        case 'value':
          // Handle adding accessors to Values
          if (o.add != null) {
            [value, accessor] = o.add.map((item) => {
              return this.$(item);
            });
            if (value instanceof this.ast.Value) {
              return value.add(accessor);
            } else {
              return this._toValue(value, [accessor]);
            }
          }
          break;
        case 'loop':
          // Handle different loop operations
          if (o.addSource != null) {
            // addSource: [1, 2] means ForStart is at position 1, ForSource at position 2
            [loopNode, sourceInfo] = o.addSource.map((item) => {
              return this.$(item);
            });
            this._ensureLocationData(loopNode);
            if (sourceInfo != null) {
              this._ensureLocationData(sourceInfo);
            }
            if ((loopNode != null ? loopNode.addSource : void 0) != null) {
              loopNode.addSource(sourceInfo);
            }
            return loopNode;
          }
          if (o.addBody != null) {
            if ((ref1 = global.process) != null ? (ref2 = ref1.env) != null ? ref2.SOLAR_DEBUG : void 0 : void 0) {
              console.log("[Solar] loop.addBody operation:", o.addBody);
            }
            // addBody: [1, 2] means loop is at position 1, body at position 2
            [loopNode, body] = o.addBody.map((item) => {
              return this.$(item);
            });
            // Ensure body is a Block
            if (!(body instanceof this.ast.Block)) {
              body = new this.ast.Block((Array.isArray(body) ? body : [body]));
            }
            if ((ref3 = global.process) != null ? (ref4 = ref3.env) != null ? ref4.SOLAR_DEBUG : void 0 : void 0) {
              util = require('util');
              console.log("[Solar] loop.addBody loopNode:", loopNode != null ? (ref5 = loopNode.constructor) != null ? ref5.name : void 0 : void 0);
              console.log("[Solar] loop.addBody body:", util.inspect(body, {
                depth: 2,
                colors: true
              }));
            }
            this._ensureLocationData(loopNode);
            this._ensureLocationData(body);
            loopNode.addBody(body);
            return loopNode;
          }
      }
      // Catchall for any missing $ops directive handlers
      console.warn("Missing $ops directive handler:", o);
      return new this.ast.Literal(`# Missing $ops directive handler for: ${JSON.stringify(o)}`);
    }

    // Process $ast directives - the main AST node creation
    processAst(o) {
      var args, body, catchClause, condition, context, elseBody, errorVariable, exclusive, expression, expressions, forNode, ifNode, index, invert, name, opValue, operator, options, params, recovery, ref, ref1, tag, type, value, variable, whileNode;
      switch (o.$ast) {
        // Root, Block, and Splat
        case 'Root':
          body = this.$(o.body);
          if (!(body instanceof this.ast.Block)) {
            // Ensure body is a Block
            body = new this.ast.Block([body]);
          }
          body.makeReturn();
          return new this.ast.Root(body);
        case 'Block':
          expressions = this.$(o.expressions);
          if (expressions instanceof this.ast.Block) {
            // Flatten if expressions is already a Block (from Body)
            expressions = expressions.expressions;
          }
          return new this.ast.Block(expressions != null ? expressions : []);
        case 'Splat':
          return new this.ast.Splat(this.$(o.name), {
            postfix: this.$(o.postfix)
          });
        // Literals
        case 'Literal':
          return new this.ast.Literal(this.$(o.value));
        case 'NumberLiteral':
          return new this.ast.NumberLiteral(this.$(o.value));
        case 'StringLiteral':
          return new this.ast.StringLiteral(this._stripQuotes(this.$(o.value)));
        case 'StringWithInterpolations':
          body = this.$(o.body);
          return new this.ast.StringWithInterpolations((function() {
            switch (false) {
              case !Array.isArray(body):
                return new this.ast.Block(body);
              case !(body instanceof this.ast.Block):
                return body;
              case body == null:
                return new this.ast.Block([body]);
              default:
                return new this.ast.Block([]);
            }
          }).call(this));
        case 'BooleanLiteral':
          return new this.ast.BooleanLiteral(this.$(o.value));
        case 'IdentifierLiteral':
          return new this.ast.IdentifierLiteral(this.$(o.value));
        case 'PropertyName':
          return new this.ast.PropertyName(this.$(o.value));
        case 'StatementLiteral':
          return new this.ast.StatementLiteral(this.$(o.value));
        case 'ThisLiteral':
          return new this.ast.ThisLiteral();
        case 'UndefinedLiteral':
          return new this.ast.UndefinedLiteral();
        case 'NullLiteral':
          return new this.ast.NullLiteral();
        case 'InfinityLiteral':
          return new this.ast.InfinityLiteral();
        case 'NaNLiteral':
          return new this.ast.NaNLiteral();
        // Value, Access, and Index
        case 'Value':
          return this._toValue(this.$(o.base), (ref = this.$(o.properties)) != null ? ref : []);
        case 'Access':
          name = this.$(o.name);
          if (name instanceof this.ast.IdentifierLiteral) {
            name = new this.ast.PropertyName(name.value);
          }
          return new this.ast.Access(name, this.$(o.soak));
        case 'Index':
          return new this.ast.Index(this.$(o.index));
        case 'Slice':
          return new this.ast.Slice(this.$(o.range));
        // Operations
        case 'Op':
          // Process args - preserve undefineds for proper positioning
          args = ((ref1 = o.args) != null ? ref1.map((arg) => {
            return this.$(arg);
          }) : void 0) || [];
          if ((o.invertOperator != null) || (o.originalOperator != null)) {
            options = {};
            if (o.invertOperator != null) {
              options.invertOperator = this.$(o.invertOperator);
            }
            if (o.originalOperator != null) {
              options.originalOperator = this.$(o.originalOperator);
            }
            args.push(options);
          }
          return new this.ast.Op(...args);
        case 'Assign':
          // Handle both simple and compound assignments
          variable = this.$(o.variable);
          value = this.$(o.value);
          context = this.$(o.context);
          // Check for compound assignment (+=, -=, etc.)
          if (o.operator != null) {
            operator = this.$(o.operator);
            if (operator && operator !== '=') {
              // Create an Op node for compound assignment
              // e.g., x += 1 becomes x = x + 1
              opValue = new this.ast.Op(operator.replace('=', ''), variable, value);
              return new this.ast.Assign(variable, opValue, context);
            } else {
              return new this.ast.Assign(variable, value, context);
            }
          } else {
            // Simple assignment
            options = {};
            if (o.operatorToken) {
              options.operatorToken = this.$(o.operatorToken);
            }
            return new this.ast.Assign(variable, value, context, options);
          }
          break;
        // Control Flow
        case 'If':
          condition = this._ensureLocationData(this.$(o.condition));
          body = this._ensureLocationData(this.$(o.body));
          // Handle `unless` by checking invert flag from lexer
          invert = this.$(o.invert);
          type = invert ? 'unless' : this.$(o.type);
          ifNode = new this.ast.If(condition, body, {
            type,
            postfix: this.$(o.postfix)
          });
          if (o.elseBody != null) {
            elseBody = this._ensureLocationData(this.$(o.elseBody));
            ifNode.addElse(elseBody);
          }
          return ifNode;
        case 'While':
          whileNode = new this.ast.While(this.$(o.condition), {
            invert: this.$(o.invert),
            guard: this.$(o.guard)
          });
          if (whileNode.body == null) {
            whileNode.body = new this.ast.Block([]);
          }
          return whileNode;
        case 'For':
          // For loops are created with empty body and source, then extended via $ops: 'loop'
          body = this.$(o.body) || [];
          // Filter out empty objects from body (similar to Call args fix)
          if (Array.isArray(body)) {
            body = body.filter((item) => {
              if ((item != null) && typeof item === 'object' && !(item instanceof this.ast.Base) && Object.keys(item).length === 0) {
                return false;
              }
              return true;
            });
          }
          if (!(body instanceof this.ast.Block)) {
            // Ensure body is a Block with location data
            body = new this.ast.Block(body);
          }
          this._ensureLocationData(body);
          // Get name and index for the loop variable
          name = this.$(o.name);
          index = this.$(o.index);
          // Create the For node - source will be added via addSource in loop operation
          // Pass initial source info with name/index
          forNode = new this.ast.For(body, {
            name,
            index,
            source: this.$(o.source)
          });
          if (o.await != null) {
            forNode.await = this.$(o.await);
          }
          if (o.own != null) {
            forNode.own = this.$(o.own);
          }
          return forNode;
        case 'Switch':
          return new this.ast.Switch(this.$(o.subject), this.$(o.cases) || [], this.$(o.otherwise));
        case 'When':
          return new this.ast.SwitchWhen(this.$(o.conditions), this.$(o.body));
        case 'SwitchWhen':
          return new this.ast.SwitchWhen(this.$(o.conditions), this.$(o.body));
        // Collections
        case 'Obj':
          return new this.ast.Obj(this.$(o.properties) || [], this.$(o.generated));
        case 'Arr':
          return new this.ast.Arr(this.$(o.objects) || []);
        case 'Range':
          exclusive = this.$(o.exclusive);
          // Range constructor expects string 'exclusive' or nothing
          tag = exclusive ? 'exclusive' : void 0;
          return new this.ast.Range(this.$(o.from), this.$(o.to), tag);
        // Functions
        case 'Code':
          params = this.$(o.params) || [];
          body = this.$(o.body);
          if (!(body instanceof this.ast.Block)) {
            // Wrap body in Block if needed
            body = new this.ast.Block(Array.isArray(body) ? body : [body]);
          }
          return new this.ast.Code(params, body);
        case 'Param':
          return new this.ast.Param(this.$(o.name), this.$(o.value), this.$(o.splat));
        case 'Call':
          args = this.$(o.args) || [];
          // Filter out empty objects from Arguments rule (CALL_START CALL_END produces [{}])
          args = args.filter((arg) => {
            if ((arg != null) && typeof arg === 'object' && !(arg instanceof this.ast.Base) && Object.keys(arg).length === 0) {
              return false;
            }
            return true;
          });
          return new this.ast.Call(this.$(o.variable), args, this.$(o.soak));
        case 'Return':
          return new this.ast.Return(this.$(o.expression));
        case 'Yield':
          return new this.ast.Yield(this.$(o.expression) || new this.ast.Value(new this.ast.Literal('')));
        // Classes
        case 'Class':
          return new this.ast.Class(this.$(o.variable), this.$(o.parent), this.$(o.body));
        case 'ClassProtoAssignOp':
          return new this.ast.ClassProtoAssignOp(this.$(o.variable), this.$(o.value));
        // Try/Catch/Throw
        case 'Try':
          
          // The catch directive points to a Catch node which has the variable and recovery
          catchClause = this.$(o.catch);
          errorVariable = catchClause != null ? catchClause.variable : void 0;
          recovery = (catchClause != null ? catchClause.recovery : void 0) || (catchClause != null ? catchClause.body : void 0);
          return new this.ast.Try(this.$(o.attempt), errorVariable, recovery, this.$(o.ensure));
        case 'Catch':
          return {
            // Catch node with variable and recovery block
            // Return a structure that the Try node can use
            variable: this.$(o.variable),
            errorVariable: this.$(o.errorVariable),
            recovery: this.$(o.recovery),
            body: this.$(o.body)
          };
        case 'Throw':
          return new this.ast.Throw(this.$(o.expression));
        // Other
        case 'Existence':
          return new this.ast.Existence(this.$(o.expression));
        case 'Parens':
          return new this.ast.Parens(this.$(o.body));
        case 'Expansion':
          return new this.ast.Expansion();
        case 'ImportDeclaration':
          return new this.ast.ImportDeclaration(this.$(o.clause), this.$(o.source));
        case 'ExportDeclaration':
          return new this.ast.ExportDeclaration(this.$(o.clause), this.$(o.source), this.$(o.default));
        // Additional types (temporary implementations)
        case 'PassthroughLiteral':
          return new this.ast.Literal(this.$(o.value));
        case 'FuncGlyph':
          return new this.ast.Literal(this.$(o.value) || '->');
        case 'RegexLiteral':
          return new this.ast.Literal(this.$(o.value));
        case 'Interpolation':
          // Create an actual Interpolation node for use in StringWithInterpolations
          expression = this.$(o.expression);
          if (expression != null) {
            // Expression might be a Block with multiple statements
            return new this.ast.Interpolation(expression);
          } else {
            // Empty interpolation - use EmptyInterpolation class
            return new this.ast.EmptyInterpolation();
          }
          break;
        default:
          console.warn("Unknown $ast type:", o.$ast);
          return new this.ast.Literal(`# Missing AST node: ${o.$ast}`);
      }
    }

  };

  module.exports = ES5Backend;

}).call(this);
