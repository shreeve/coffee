// Generated by CoffeeScript 2.8.0

let UNICODE_CODE_POINT_ESCAPE, buildLocationData, buildLocationHash, syntaxErrorToString, unicodeCodePointToUnicodeEscapes,
  indexOf = [].indexOf;

export let starts = (string, literal, start) => literal === string.substr(start, literal.length);

export let ends = (string, literal, back) => {
  let len;
  len = literal.length;
  return literal === string.substr(string.length - len - (back || 0), len);
};

export let repeat = (str, n) => {
  let res;
  res = '';
  while (n > 0) {
    if (n & 1) {
      res += str;
    }
    n >>>= 1;
    str += str;
  }
  return res;
};

export let compact = (array) => {
  let item, results;
array.filter((item) => item)
};

export let count = (string, substr) => {
  let num, pos;
  num = pos = 0;
  if (!substr.length) {
    return 1 / 0;
  }
  while (pos = 1 + string.indexOf(substr, pos)) {
    num++;
  }
  return num;
};

export let merge = (options, overrides) => extend(extend({}, options), overrides);

export let extend = (object, properties) => {
  let key, val;
  for (key in properties) {
    val = properties[key];
    object[key] = val;
  }
  return object;
};

export let flatten = (array) => array.flat(2e308);

export let del = (obj, key) => {
  let val;
  val = obj[key];
  delete obj[key];
  return val;
};

export let some = Array.prototype.some ?? function(fn) {
  let e, i, len1, ref;
  ref = this;
  for (i = 0, len1 = ref.length; i < len1; i++) {
    e = ref[i];
    if (fn(e)) {
      return true;
    }
  }
  return false;
};

buildLocationData = (first, last) => {
  if (!last) {
    return first;
  } else {
    return {
      first_line: first.first_line,
      first_column: first.first_column,
      last_line: last.last_line,
      last_column: last.last_column,
      last_line_exclusive: last.last_line_exclusive,
      last_column_exclusive: last.last_column_exclusive,
      range: [first.range[0], last.range[1]]
    };
  }
};

export let extractAllCommentTokens = (tokens) => {
  let allCommentsObj, comment, commentKey, i, j, key, len1, len2, ref, results, sortedKeys, token;
  allCommentsObj = {};
  for (i = 0, len1 = tokens.length; i < len1; i++) {
    token = tokens[i];
    if (token.comments) {
      ref = token.comments;
      for (j = 0, len2 = ref.length; j < len2; j++) {
        comment = ref[j];
        commentKey = comment.locationData.range[0];
        allCommentsObj[commentKey] = comment;
      }
    }
  }
  sortedKeys = Object.keys(allCommentsObj).sort((a, b) => a - b);
sortedKeys.map((key) => allCommentsObj[key])
};

buildLocationHash = (loc) => `${loc.range[0]}-${loc.range[1]}`;

export let buildTokenDataDictionary = (tokens) => {
  let base1, i, len1, token, tokenData, tokenHash;
  tokenData = {};
  for (i = 0, len1 = tokens.length; i < len1; i++) {
    token = tokens[i];
    if (!token.comments) {
      continue;
    }
    tokenHash = buildLocationHash(token[2]);
    if (tokenData[tokenHash] == null) {
      tokenData[tokenHash] = {};
    }
    if (token.comments) {
      ((base1 = tokenData[tokenHash]).comments != null ? base1.comments : base1.comments = []).push(...token.comments);
    }
  }
  return tokenData;
};

export let addDataToNode = (parserState, firstLocationData, firstValue, lastLocationData, lastValue, forceUpdateLocation = true) => (obj) => {
    let locationData, objHash, ref;
    locationData = buildLocationData((firstValue != null ? firstValue.locationData : void 0) ?? firstLocationData, (lastValue != null ? lastValue.locationData : void 0) ?? lastLocationData);
    if (((obj != null ? obj.updateLocationDataIfMissing : void 0) != null) && (firstLocationData != null)) {
      obj.updateLocationDataIfMissing(locationData, forceUpdateLocation);
    } else {
      obj.locationData = locationData;
    }
    if (parserState.tokenData == null) {
      parserState.tokenData = buildTokenDataDictionary(parserState.parser.tokens);
    }
    if (obj.locationData != null) {
      objHash = buildLocationHash(obj.locationData);
      if (((ref = parserState.tokenData[objHash]) != null ? ref.comments : void 0) != null) {
        attachCommentsToNode(parserState.tokenData[objHash].comments, obj);
      }
    }
    return obj;
  };

export let attachCommentsToNode = (comments, node) => {
  if ((comments == null) || comments.length === 0) {
    return;
  }
  if (node.comments == null) {
    node.comments = [];
  }
  return node.comments.push(...comments);
};

export let locationDataToString = (obj) => {
  let locationData;
  if (("2" in obj) && ("first_line" in obj[2])) {
    locationData = obj[2];
  } else if ("first_line" in obj) {
    locationData = obj;
  }
  if (locationData) {
    return `${locationData.first_line + 1}:${locationData.first_column + 1}-` + `${locationData.last_line + 1}:${locationData.last_column + 1}`;
  } else {
    return "No location data";
  }
};

export let anonymousFileName = (() => {
  let n;
  n = 0;
  return () => `<anonymous-${n++}>`;
})();

export let baseFileName = (file, stripExt = false, useWinPathSep = false) => {
  let parts, pathSep;
  pathSep = useWinPathSep ? /\\|\// : /\//;
  parts = file.split(pathSep);
  file = parts[parts.length - 1];
  if (!(stripExt && file.indexOf('.') >= 0)) {
    return file;
  }
  parts = file.split('.');
  parts.pop();
  if (parts[parts.length - 1] === 'coffee' && parts.length > 1) {
    parts.pop();
  }
  return parts.join('.');
};

export let isCoffee = (file) => /\.coffee$/.test(file);

export let throwSyntaxError = (message, location) => {
  let error;
  error = new SyntaxError(message);
  error.location = location;
  error.toString = syntaxErrorToString;
  error.stack = error.toString();
  throw error;
};

export let updateSyntaxError = (error, code, filename) => {
  if (error.toString === syntaxErrorToString) {
    error.code || (error.code = code);
    error.filename || (error.filename = filename);
    error.stack = error.toString();
  }
  return error;
};

syntaxErrorToString = function() {
  let codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, ref, ref1, ref2, start;
  if (!(this.code && this.location)) {
    return Error.prototype.toString.call(this);
  }
  ({first_line, first_column, last_line, last_column} = this.location);
  if (last_line == null) {
    last_line = first_line;
  }
  if (last_column == null) {
    last_column = first_column;
  }
  if ((ref = this.filename) != null ? ref.startsWith('<anonymous') : void 0) {
    filename = '[stdin]';
  } else {
    filename = this.filename || '[stdin]';
  }
  codeLine = this.code.split('\n')[first_line];
  start = first_column;
  end = first_line === last_line ? last_column + 1 : codeLine.length;
  marker = codeLine.slice(0, start).replace(/[^\s]/g, ' ') + repeat('^', end - start);
  if (typeof process !== "undefined" && process !== null) {
    colorsEnabled = ((ref1 = process.stdout) != null ? ref1.isTTY : void 0) && !((ref2 = process.env) != null ? ref2.NODE_DISABLE_COLORS : void 0);
  }
  if (this.colorful ?? colorsEnabled) {
    colorize = (str) => `\x1B[1;31m${str}\x1B[0m`;
    codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
    marker = colorize(marker);
  }
  return `${filename}:${first_line + 1}:${first_column + 1}: error: ${this.message}
${codeLine}
${marker}`;
};

export let nameWhitespaceCharacter = (string) => {
  switch (string) {
    case ' ':
      return 'space';
    case '\n':
      return 'newline';
    case '\r':
      return 'carriage return';
    case '\t':
      return 'tab';
    default:
      return string;
  }
};

export let parseNumber = (string) => {
  let base;
  if (string == null) {
    return 0/0;
  }
  base = (() => {
    switch (string.charAt(1)) {
      case 'b':
        return 2;
      case 'o':
        return 8;
      case 'x':
        return 16;
      default:
        return null;
    }
  })();
  if (base != null) {
    return parseInt(string.slice(2).replace(/_/g, ''), base);
  } else {
    return parseFloat(string.replace(/_/g, ''));
  }
};

export let isFunction = (obj) => Object.prototype.toString.call(obj) === '[object Function]';

export let isNumber = (obj) => Object.prototype.toString.call(obj) === '[object Number]';

export let isString = (obj) => Object.prototype.toString.call(obj) === '[object String]';

export let isBoolean = (obj) => obj === true || obj === false || Object.prototype.toString.call(obj) === '[object Boolean]';

export let isPlainObject = (obj) => typeof obj === 'object' && !!obj && !Array.isArray(obj) && !isNumber(obj) && !isString(obj) && !isBoolean(obj);

unicodeCodePointToUnicodeEscapes = (codePoint) => {
  let high, low, toUnicodeEscape;
  toUnicodeEscape = (val) => {
    let str;
    str = val.toString(16);
    return `\\u${repeat('0', 4 - str.length)}${str}`;
  };
  if (codePoint < 0x10000) {
    return toUnicodeEscape(codePoint);
  }
  high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;
  low = (codePoint - 0x10000) % 0x400 + 0xDC00;
  return `${toUnicodeEscape(high)}${toUnicodeEscape(low)}`;
};

export let replaceUnicodeCodePointEscapes = (str, {flags, error, delimiter = ''} = {}) => {
  let shouldReplace;
  shouldReplace = (flags != null) && indexOf.call(flags, 'u') < 0;
  return str.replace(UNICODE_CODE_POINT_ESCAPE, (match, escapedBackslash, codePointHex, offset) => {
    let codePointDecimal;
    if (escapedBackslash) {
      return escapedBackslash;
    }
    codePointDecimal = parseInt(codePointHex, 16);
    if (codePointDecimal > 0x10ffff) {
      error("unicode code point escapes greater than \\u{10ffff} are not allowed", {
        offset: offset + delimiter.length,
        length: codePointHex.length + 4
      });
    }
    if (!shouldReplace) {
      return match;
    }
    return unicodeCodePointToUnicodeEscapes(codePointDecimal);
  });
};

UNICODE_CODE_POINT_ESCAPE = /(\\\\)|\\u\{([\da-fA-F]+)\}/g;
