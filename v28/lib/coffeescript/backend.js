// Generated by CoffeeScript 2.7.0
(function() {
  // ==============================================================================
  // Backend - Converts Solar directives (pure data) to CoffeeScript AST nodes
  // ==============================================================================
  var Backend,
    hasProp = {}.hasOwnProperty;

  Backend = class Backend {
    constructor(options1 = {}, ast = {}) {
      this.options = options1;
      this.ast = ast;
    }

    // Helper to set location data for a node
    _toLocation(pos) {
      var from, ref, ref1, ref2, ref3, ref4, ref5, till;
      if (Array.isArray(pos)) {
        from = this.pos(pos[0]);
        till = this.pos(pos[1]);
      } else if (typeof pos === 'number') {
        from = till = this.pos(pos);
      }
      if (from && till) {
        return {
          first_line: from.first_line,
          first_column: from.first_column,
          last_line_exclusive: (ref = till.last_line_exclusive) != null ? ref : till.last_line,
          last_column_exclusive: (ref1 = till.last_column_exclusive) != null ? ref1 : till.last_column + 1,
          range: [(ref2 = (ref3 = from.range) != null ? ref3[0] : void 0) != null ? ref2 : 0, (ref4 = (ref5 = till.range) != null ? ref5[1] : void 0) != null ? ref4 : 0]
        };
      }
    }

    // Helper to convert base + properties to Value node
    _toValue(base, properties, tag = null, isDefaultValue = false) {
      var props;
      props = Array.isArray(properties) ? properties : [];
      // Handle existing Value
      if (base instanceof this.ast.Value) {
        if (props.length) {
          base.add(props);
        }
        return base;
      }
      // Base should already be a node
      return new this.ast.Value(base, props, tag, isDefaultValue);
    }

    // Parser reducer: call as r(...) = reduce(values, positions, stackTop, ...)
    // Called ONCE per grammar rule match (e.g., 'TRY Block FINALLY Block'). This
    // sets @loc (current location) to span the ENTIRE rule (first to last token).
    // All AST nodes created during this call inherit this rule-wide location info
    // unless manually overridden. Without any override, a 'finally' keyword would
    // incorrectly span the entire try/finally block. This is why Literal is the
    // only AST type used to capture raw tokens by position (e.g., finallyTag,
    // operatorToken, returnKeyword).
    reduce(values, positions, stackTop, symbolCount, directive) {
      var o, outName, ref, ref1, ref2, ref3, result, util;
      this.tok = function(pos) {
        return values[stackTop - symbolCount + pos];
      };
      this.pos = function(pos) {
        return positions[stackTop - symbolCount + pos];
      };
      if (positions && symbolCount > 0) {
        this.loc = this._toLocation([1, symbolCount]);
      }
      // Create a smart directive proxy that can auto-resolve its properties
      o = new Proxy(directive, {
        get: (target, prop) => {
          if (prop in target) { // props first
            return target[prop];
          }
          if (/^\d+$/.test(prop)) { // token index
            return this.tok(parseInt(prop, 10));
          }
          if (prop[0] === '$') { // $N syntax
            return this.tok(parseInt(prop.slice(1), 10));
          }
          return void 0; // not needed, but just to be obvious
        }
      });
      
      // Process the directive
      result = this.process(o);
      // Only set if missing - don't overwrite!
      if (result instanceof this.ast.Base && !result.locationData && this.loc) {
        result.locationData = this.loc;
      }
      if ((ref = global.process) != null ? (ref1 = ref.env) != null ? ref1.SOLAR_DEBUG : void 0 : void 0) {
        util = require('util');
        outName = (ref2 = result != null ? (ref3 = result.constructor) != null ? ref3.name : void 0 : void 0) != null ? ref2 : typeof result;
        console.log("[Solar] result:", outName, util.inspect(result, {
          depth: 3,
          colors: true
        }));
      }
      return result;
    }

    // Process a directive with smart resolution, ordered by most common to least
    process(o) {
      if (o.$ast != null) {
        return this.processAst(o);
      }
      if (o.$use != null) {
        return this.processUse(o);
      }
      if (o.$ops != null) {
        return this.processOps(o);
      }
      if (o.$arr != null) {
        return this.processArr(o);
      }
      return this.$(o);
    }

    // Smart resolver - handles all types of references
    $(value) {
      var i, item, key, len, resolved, result, results, val;
      if (value == null) {
        return value;
      }
      // Numbers are token positions (1-based)
      if (typeof value === 'number') {
        return this.tok(value);
      }
      // Arrays - resolve each item, filtering out undefined/null/non-nodes
      if (Array.isArray(value)) {
        results = [];
        for (i = 0, len = value.length; i < len; i++) {
          item = value[i];
          resolved = this.$(item);
          if (resolved == null) {
            continue;
          }
          if (resolved instanceof this.ast.Base) {
            results.push(resolved);
          }
        }
        return results;
      }
      // Process objects with directives
      if (typeof value === 'object' && (value != null)) {
        if (value.$ast || value.$ops || value.$use || value.$arr) {
          return this.process(value);
        }
        result = {};
        for (key in value) {
          if (!hasProp.call(value, key)) continue;
          val = value[key];
          result[key] = this.$(val);
        }
        return result;
      }
      // Everything else passes through
      return value;
    }

    // Process $arr directives
    processArr(o) {
      var items, result;
      items = this.$(o.$arr);
      result = Array.isArray(items) ? items : [items];
      if (o.implicit != null) {
        result.implicit = !!this.$(o.implicit);
      }
      return result;
    }

    // Process $use directives
    processUse(o) {
      var name1, ref, target;
      target = this.$(o.$use);
      if (o.method != null) {
        return target != null ? typeof target[name1 = o.method] === "function" ? target[name1](...((ref = o.args) != null ? ref : [])) : void 0 : void 0;
      }
      if (o.prop != null) {
        return target != null ? target[o.prop] : void 0;
      }
      if (o.index != null) {
        return target != null ? target[o.index] : void 0;
      }
      return target;
    }

    // Process $ops directives
    processOps(o) {
      var accessor, body, elseBody, i, ifNode, item, len, loopNode, ref, resolved, result, sourceInfo, target, value;
      switch (o.$ops) {
        // Handle array operations
        case 'array':
          result = [];
          if (o.append != null) {
            ref = o.append;
            for (i = 0, len = ref.length; i < len; i++) {
              item = ref[i];
              resolved = this.$(item);
              if (Array.isArray(resolved)) {
                result.push(...resolved);
              } else if (resolved != null) {
                result.push(resolved);
              }
            }
          }
          return result;
        // Handle addElse operation for if-else chains
        case 'if':
          if (o.addElse != null) {
            [ifNode, elseBody] = o.addElse.map((item) => {
              return this.$(item);
            });
            if (elseBody && !elseBody.locationData && this.loc) {
              elseBody.locationData = this.loc;
            }
            ifNode.addElse(elseBody);
            return ifNode;
          }
          break;
        // Handle adding accessors to Values
        case 'value':
          if (o.add != null) {
            [value, accessor] = o.add.map((item) => {
              return this.$(item);
            });
            if (value instanceof this.ast.Value) {
              result = value.add(accessor);
              if (result.forceUpdateLocation) {
                // When properties are added, the Value needs its location updated to span the full rule
                result.updateLocationDataIfMissing(this.loc);
              }
              return result;
            } else {
              return this._toValue(value, [accessor]);
            }
          }
          break;
        // Handle different loop operations
        case 'loop':
          if (o.addSource != null) {
            [loopNode, sourceInfo] = o.addSource.map((item) => {
              return this.$(item);
            });
            if ((loopNode != null ? loopNode.addSource : void 0) != null) {
              loopNode.addSource(sourceInfo);
            }
            return loopNode;
          }
          if (o.addBody != null) {
            [loopNode, body] = o.addBody.map((item) => {
              return this.$(item);
            });
            loopNode.addBody(this.ast.Block.wrap(body));
            if (o.postfix != null) {
              loopNode.postfix = this.$(o.postfix);
            }
            return loopNode;
          }
          break;
        // Handle property setting operations
        case 'prop':
          if (o.set != null) {
            target = this.$(o.set.target);
            value = this.$(o.set.value);
            if (target != null) {
              target[o.set.property] = value;
            }
            return target;
          }
      }
      // Catchall for any missing $ops directive handlers
      console.warn("Missing $ops directive handler:", o);
      return new this.ast.Literal(`# Missing $ops directive handler for: ${JSON.stringify(o)}`);
    }

    // Process $ast directives - the main AST node creation
    processAst(o) {
      var args, body, context, expression, expressions, forNode, ifNode, k, loc, name, node, operator, options, pos, value, variable, whileNode;
      node = (function() {
        var i, j, len, len1, ref, ref1, ref2, ref3, ref4;
        switch (o.$ast) {
          // === CORE EXPRESSIONS (Very High Frequency) ===

            // Values and property access - the most fundamental operations
          case 'Value':
            return this._toValue(this.$(o.base), (ref = this.$(o.properties)) != null ? ref : [], o.this && 'this', (ref1 = this.$(o.isDefaultValue)) != null ? ref1 : false);
          case 'IdentifierLiteral':
            return new this.ast.IdentifierLiteral(this.$(o.value));
          case 'NumberLiteral':
            return new this.ast.NumberLiteral(this.$(o.value), {
              parsedValue: this.$(o.parsedValue)
            });
          case 'Literal': // Literal location data maps to just one token in the rule
            node = new this.ast.Literal(this.$(pos = o.value));
            if (typeof pos === 'number') {
              node.locationData = this._toLocation(pos);
            }
            return node;
          case 'StringLiteral':
            return new this.ast.StringLiteral(this.$(o.value), {
              quote: this.$(o.quote),
              initialChunk: this.$(o.initialChunk),
              finalChunk: this.$(o.finalChunk),
              indent: this.$(o.indent),
              double: this.$(o.double),
              heregex: this.$(o.heregex)
            });
          // Basic operations - assignments, calls, operators
          case 'Assign':
            variable = this.$(o.variable);
            operator = this.$(o.operator);
            value = this.$(o.value);
            context = this.$(o.context);
            if (context === 'object' && variable instanceof this.ast.Value && variable.base instanceof this.ast.ThisLiteral) {
              variable.this = true;
            }
            // Only expand special compound assignments that JS doesn't support natively
            // Standard compound assignments like +=, -=, *=, /=, etc. should be preserved
            if (operator === '//=' || operator === '%%=') {
              value = new this.ast.Op(operator.slice(0, -1), variable, value);
              context = '=';
            } else if (operator && (operator !== '=' && operator !== '?=' && operator !== (void 0))) {
              // For standard compound assignments, preserve them by setting context
              context = operator;
            } else if (operator === '?=') {
              context = operator;
            }
            options = {};
            ref2 = ['operatorToken', 'moduleDeclaration', 'originalContext'];
            for (i = 0, len = ref2.length; i < len; i++) {
              k = ref2[i];
              if (o[k] != null) {
                options[k] = this.$(o[k]);
              }
            }
            return new this.ast.Assign(variable, value, context, options);
          case 'Call':
            return new this.ast.Call(this.$(o.variable), this.$(o.args) || [], this.$(o.soak));
          case 'Op':
            args = ((ref3 = o.args) != null ? ref3.map((arg) => {
              return this.$(arg);
            }) : void 0) || [];
            if ((o.invertOperator != null) || (o.originalOperator != null)) {
              options = {};
              if (o.invertOperator != null) {
                options.invertOperator = this.$(o.invertOperator);
              }
              if (o.originalOperator != null) {
                options.originalOperator = this.$(o.originalOperator);
              }
              args.push(options);
            }
            return new this.ast.Op(...args);
          // Property access patterns
          case 'Access':
            name = this.$(o.name);
            if (name instanceof this.ast.IdentifierLiteral) {
              name = new this.ast.PropertyName(name.value);
            }
            return new this.ast.Access(name, {
              soak: this.$(o.soak),
              shorthand: this.$(o.shorthand)
            });
          case 'Index':
            return new this.ast.Index(this.$(o.index));
          case 'PropertyName':
            return new this.ast.PropertyName(this.$(o.value));
          // === CONTROL FLOW & STRUCTURE (High Frequency) ===

            // Program structure
          case 'Block':
            expressions = this.$(o.expressions);
            return new this.ast.Block((expressions instanceof this.ast.Block ? expressions.expressions : expressions) || []);
          case 'Root':
            body = this.ast.Block.wrap(this.$(o.body));
            if (this.options.makeReturn) {
              body.makeReturn();
            }
            return new this.ast.Root(body);
          // Control flow statements
          case 'If':
            ifNode = new this.ast.If(this.$(o.condition), this.ast.Block.wrap(this.$(o.body)), {
              type: (this.$(o.invert) ? 'unless' : this.$(o.type)),
              postfix: this.$(o.postfix)
            });
            if (o.elseBody != null) {
              ifNode.addElse(this.ast.Block.wrap(this.$(o.elseBody)));
            }
            return ifNode;
          case 'While':
            whileNode = new this.ast.While(this.$(o.condition), {
              invert: this.$(o.invert),
              guard: this.$(o.guard),
              isLoop: this.$(o.isLoop)
            });
            whileNode.body = this.ast.Block.wrap(this.$(o.body));
            return whileNode;
          case 'For':
            body = this.ast.Block.wrap(this.$(o.body));
            forNode = new this.ast.For(body, {
              name: this.$(o.name),
              index: this.$(o.index),
              source: this.$(o.source)
            });
            ref4 = ['await', 'awaitTag', 'own', 'ownTag', 'step', 'from', 'object', 'guard'];
            for (j = 0, len1 = ref4.length; j < len1; j++) {
              k = ref4[j];
              if (o[k] != null) {
                forNode[k] = this.$(o[k]);
              }
            }
            return forNode;
          case 'Return':
            return new this.ast.Return(this.$(o.expression));
          // === FUNCTIONS & CLASSES (Medium-High Frequency) ===
          case 'Code':
            return new this.ast.Code(this.$(o.params) || [], this.ast.Block.wrap(this.$(o.body)), this.$(o.funcGlyph), this.$(o.paramStart));
          case 'FuncGlyph':
            return new this.ast.FuncGlyph(this.$(o.glyph) || this.$(o.value) || '->');
          case 'Class':
            return new this.ast.Class(this.$(o.variable), this.$(o.parent), this.$(o.body));
          case 'Param':
            name = this.$(o.name);
            if (name instanceof this.ast.Value && name.base instanceof this.ast.ThisLiteral) {
              name.this = true;
            }
            return new this.ast.Param(name, this.$(o.value), this.$(o.splat));
          // === DATA STRUCTURES (Medium Frequency) ===
          case 'Obj':
            return new this.ast.Obj(this.$(o.properties) || [], this.$(o.generated));
          case 'Arr':
            return new this.ast.Arr(this.$(o.objects) || []);
          case 'Range':
            return new this.ast.Range(this.$(o.from), this.$(o.to), this.$(o.exclusive) ? 'exclusive' : void 0);
          case 'Slice':
            return new this.ast.Slice(this.$(o.range));
          case 'Expansion':
            return new this.ast.Expansion(); // Rest/spread operator (...)
          
            // === COMMON LITERALS (Medium Frequency) ===
          case 'BooleanLiteral':
            return new this.ast.BooleanLiteral(this.$(o.value), {
              originalValue: this.$(o.originalValue)
            });
          case 'ThisLiteral':
            return new this.ast.ThisLiteral(this.$(o.value));
          case 'NullLiteral':
            return new this.ast.NullLiteral();
          case 'UndefinedLiteral':
            return new this.ast.UndefinedLiteral();
          case 'RegexLiteral':
            return new this.ast.RegexLiteral(this.$(o.value), {
              delimiter: this.$(o.delimiter),
              heregexCommentTokens: this.$(o.heregexCommentTokens)
            });
          case 'PassthroughLiteral':
            return new this.ast.PassthroughLiteral(this.$(o.value), {
              here: this.$(o.here),
              generated: this.$(o.generated)
            });
          case 'StatementLiteral':
            return new this.ast.StatementLiteral(this.$(o.value));
          case 'ComputedPropertyName':
            return new this.ast.ComputedPropertyName(this.$(o.value));
          // === STRING INTERPOLATION (Low-Medium Frequency) ===
          case 'StringWithInterpolations':
            return new this.ast.StringWithInterpolations(this.ast.Block.wrap(this.$(o.body)), {
              quote: this.$(o.quote),
              startQuote: this.$(o.startQuote)
            });
          case 'Interpolation':
            expression = this.$(o.expression);
            if (expression != null) {
              return new this.ast.Interpolation(expression);
            } else {
              return new this.ast.EmptyInterpolation();
            }
            break;
          // === SPECIAL OPERATIONS (Low Frequency) ===

            // Switch statements
          case 'Switch':
            return new this.ast.Switch(this.$(o.subject), this.$(o.cases) || [], this.$(o.otherwise));
          case 'SwitchWhen':
            return new this.ast.SwitchWhen([].concat(this.$(o.conditions)), this.$(o.body));
          // Super calls
          case 'Super':
            return new this.ast.Super(this.$(o.accessor), this.$(o.superLiteral));
          case 'SuperCall':
            return new this.ast.SuperCall(this.$(o.variable), this.$(o.args) || [], this.$(o.soak));
          // Other operations
          case 'Existence':
            return new this.ast.Existence(this.$(o.expression));
          case 'Parens':
            return new this.ast.Parens(this.$(o.body));
          case 'Splat':
            return new this.ast.Splat(this.$(o.name), {
              postfix: this.$(o.postfix)
            });
          // === ERROR HANDLING (Low Frequency) ===
          case 'Try':
            return new this.ast.Try(this.$(o.attempt), this.$(o.catch), this.$(o.ensure), this.$(o.finallyTag));
          case 'Catch':
            return new this.ast.Catch(this.$(o.recovery), this.$(o.variable) || this.$(o.errorVariable));
          case 'Throw':
            return new this.ast.Throw(this.$(o.expression));
          // === MODULES (Low Frequency) ===

            // Import statements
          case 'ImportDeclaration':
            return new this.ast.ImportDeclaration(this.$(o.clause), this.$(o.source));
          case 'ImportClause':
            return new this.ast.ImportClause(this.$(o.defaultBinding), this.$(o.namedImports));
          case 'ImportSpecifierList':
            return new this.ast.ImportSpecifierList(this.$(o.specifiers) || []);
          case 'ImportSpecifier':
            return new this.ast.ImportSpecifier(this.$(o.imported), this.$(o.local));
          case 'ImportDefaultSpecifier':
            return new this.ast.ImportDefaultSpecifier(this.$(o.name) || this.$(o.value) || this.$(o));
          case 'ImportNamespaceSpecifier':
            return new this.ast.ImportNamespaceSpecifier(this.$(o.star), this.$(o.local));
          // Export statements
          case 'ExportNamedDeclaration':
            return new this.ast.ExportNamedDeclaration(this.$(o.clause), this.$(o.source), this.$(o.assertions));
          case 'ExportDefaultDeclaration':
            return new this.ast.ExportDefaultDeclaration(this.$(o.declaration) || this.$(o.value));
          case 'ExportAllDeclaration':
            return new this.ast.ExportAllDeclaration(this.$(o.exported), this.$(o.source), this.$(o.assertions));
          case 'ExportSpecifierList':
            return new this.ast.ExportSpecifierList(this.$(o.specifiers) || []);
          case 'ExportSpecifier':
            return new this.ast.ExportSpecifier(this.$(o.value || o.local), this.$(o.exported));
          // === ADVANCED/RARE FEATURES (Very Low Frequency) ===

            // Advanced literals
          case 'InfinityLiteral':
            return new this.ast.InfinityLiteral();
          case 'NaNLiteral':
            return new this.ast.NaNLiteral();
          case 'DefaultLiteral':
            return new this.ast.DefaultLiteral(this.$(o.value) || 'default');
          // Advanced operations
          case 'YieldReturn':
            return new this.ast.YieldReturn(this.$(o.expression), {
              returnKeyword: this.$(o.returnKeyword)
            });
          case 'AwaitReturn':
            return new this.ast.AwaitReturn(this.$(o.expression), {
              returnKeyword: this.$(o.returnKeyword)
            });
          case 'DynamicImportCall':
            return new this.ast.DynamicImportCall(this.$(o.variable), this.$(o.args) || []);
          case 'DynamicImport':
            return new this.ast.DynamicImport();
          case 'TaggedTemplateCall':
            return new this.ast.TaggedTemplateCall(this.$(o.variable), this.$(o.template), this.$(o.soak));
          case 'MetaProperty':
            return new this.ast.MetaProperty(this.$(o.identifier), this.$(o.accessor));
          case 'RegexWithInterpolations':
            return new this.ast.RegexWithInterpolations(this.$(o.invocation), {
              heregexCommentTokens: this.$(o.heregexCommentTokens)
            });
          // Rare array operation
          case 'Elision':
            return new this.ast.Elision(); // Sparse array holes
          default:
            console.warn("Unknown $ast type:", o.$ast);
            return new this.ast.Literal(`# Missing AST node: ${o.$ast}`);
        }
      }).call(this);
      // Possibly override AST node location data
      if (node instanceof this.ast.Base) {
        if (((pos = o.$pos) != null) && (loc = this._toLocation(pos))) {
          node.locationData = loc;
        } else if (!node.locationData && this.loc) {
          node.locationData = this.loc;
        }
      }
      return node;
    }

  };

  module.exports = Backend;

}).call(this);
