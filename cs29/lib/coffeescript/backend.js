// Generated by CoffeeScript 2.7.0
(function() {
  // ==============================================================================
  // Backend - Converts Solar directives (pure data) to CoffeeScript AST nodes
  // ==============================================================================
  var Backend,
    hasProp = {}.hasOwnProperty;

  Backend = class Backend {
    constructor(options1 = {}, ast = {}) {
      this.options = options1;
      this.ast = ast;
      this.currentDirective = null;
      this.currentRule = null;
      this.currentLookup = null;
    }

    // Helper to convert base + properties to Value node
    _toValue(base, properties) {
      var props;
      props = Array.isArray(properties) ? properties : [];
      // Handle existing Value
      if (base instanceof this.ast.Value) {
        if (props.length) {
          base.add(props);
        }
        return base;
      }
      // In a properly working grammar, base should always be a node already
      return new this.ast.Value(base, props);
    }

    // Main entry point (called by parser as 'reduce')
    reduce(values, positions, stackTop, symbolCount, directive) {
      var firstPos, handler, lastPos, lookup, lookupPos, o, outName, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, result, util;
      // Create lookup function to access stack values
      lookup = function(index) {
        return values[stackTop - symbolCount + 1 + index];
      };
      // Create lookup function for position data
      lookupPos = function(index) {
        return positions[stackTop - symbolCount + 1 + index];
      };
      this.currentDirective = directive;
      this.currentRule = directive;
      this.currentLookup = lookup; // Store lookup for use in $()
      this.currentLookupPos = lookupPos; // Store position lookup
      
      // Get the location data for this production (combines all positions)
      if (positions && symbolCount > 0) {
        firstPos = lookupPos(0);
        lastPos = lookupPos(symbolCount - 1);
        if (firstPos && lastPos) {
          this.currentLocationData = {
            first_line: firstPos.first_line,
            first_column: firstPos.first_column,
            last_line_exclusive: (ref = lastPos.last_line_exclusive) != null ? ref : lastPos.last_line,
            last_column_exclusive: (ref1 = lastPos.last_column_exclusive) != null ? ref1 : lastPos.last_column + 1,
            range: [(ref2 = (ref3 = firstPos.range) != null ? ref3[0] : void 0) != null ? ref2 : 0, (ref4 = (ref5 = lastPos.range) != null ? ref5[1] : void 0) != null ? ref4 : 0]
          };
        }
      } else {
        this.currentLocationData = null;
      }
      // Create smart proxy that auto-resolves properties
      handler = {
        get: function(target, prop) {
          var idx;
          if (prop in target) {
            // Return directive properties first
            return target[prop];
          }
          // Handle numeric indices for stack access
          if (typeof prop === 'string' && /^\d+$/.test(prop)) {
            idx = parseInt(prop, 10) - 1; // Convert to 0-based
            if (idx >= 0) {
              return lookup(idx);
            }
          }
          // Handle $N syntax
          if (typeof prop === 'string' && prop[0] === '$') {
            idx = parseInt(prop.slice(1), 10) - 1; // Convert to 0-based
            if (idx >= 0) {
              return lookup(idx);
            }
          }
          return void 0;
        }
      };
      // Create smart directive object
      o = new Proxy(directive, handler);
      // Process the directive
      result = this.process(o);
      // Attach location data to the result if it's an AST node
      if (result instanceof this.ast.Base && this.currentLocationData) {
        result.locationData = this.currentLocationData;
        if (typeof result.updateLocationDataIfMissing === "function") {
          result.updateLocationDataIfMissing(this.currentLocationData);
        }
      }
      if ((ref6 = global.process) != null ? (ref7 = ref6.env) != null ? ref7.SOLAR_DEBUG : void 0 : void 0) {
        util = require('util');
        outName = (ref8 = result != null ? (ref9 = result.constructor) != null ? ref9.name : void 0 : void 0) != null ? ref8 : typeof result;
        console.log("[Solar] result:", outName, util.inspect(result, {
          depth: 3,
          colors: true
        }));
      }
      return result;
    }

    // Process a directive with smart resolution, ordered by most common to least
    process(o) {
      if (o.$ast != null) {
        return this.processAst(o);
      }
      if (o.$use != null) {
        return this.processUse(o);
      }
      if (o.$ops != null) {
        return this.processOps(o);
      }
      if (o.$arr != null) {
        return this.processArr(o);
      }
      return this.$(o);
    }

    // Smart resolver - handles all types of references
    $(value) {
      var i, item, key, len, resolved, result, results, val;
      if (value == null) {
        return value;
      }
      // Numbers are stack positions (1-based)
      if (typeof value === 'number') {
        if (this.currentLookup) {
          return this.currentLookup(value - 1);
        }
        return value;
      }
      // Arrays - resolve each item, filtering out undefined/null/non-nodes
      if (Array.isArray(value)) {
        results = [];
        for (i = 0, len = value.length; i < len; i++) {
          item = value[i];
          resolved = this.$(item);
          if (resolved == null) {
            continue;
          }
          // ONLY include actual AST Base nodes
          // This prevents circular references and ensures arrays only contain proper nodes
          if (resolved instanceof this.ast.Base) {
            results.push(resolved);
          }
        }
        return results;
      }
      // Objects with directives - process them (but not null)
      if (typeof value === 'object' && (value != null)) {
        if (value.$ast || value.$ops || value.$use || value.$arr) {
          return this.process(value);
        }
        // Regular objects - resolve properties
        result = {};
        for (key in value) {
          if (!hasProp.call(value, key)) continue;
          val = value[key];
          result[key] = this.$(val);
        }
        return result;
      }
      // Everything else passes through
      return value;
    }

    // Process $arr directives
    processArr(o) {
      var items, result;
      items = this.$(o.$arr);
      result = Array.isArray(items) ? items : [items];
      if (o.implicit != null) {
        result.implicit = !!this.$(o.implicit);
      }
      return result;
    }

    // Process $use directives
    processUse(o) {
      var name1, ref, target;
      target = this.$(o.$use);
      if (o.method != null) {
        return target != null ? typeof target[name1 = o.method] === "function" ? target[name1](...((ref = o.args) != null ? ref : [])) : void 0 : void 0;
      }
      if (o.prop != null) {
        return target != null ? target[o.prop] : void 0;
      }
      if (o.index != null) {
        return target != null ? target[o.index] : void 0;
      }
      return target;
    }

    // Process $ops directives
    processOps(o) {
      var accessor, body, elseBody, i, ifNode, item, len, loopNode, property, ref, ref1, ref2, ref3, ref4, ref5, resolved, result, sourceInfo, target, util, value;
      switch (o.$ops) {
        case 'array':
          result = [];
          if (o.append != null) {
            ref = o.append;
            for (i = 0, len = ref.length; i < len; i++) {
              item = ref[i];
              resolved = this.$(item);
              if (Array.isArray(resolved)) {
                result.push(...resolved);
              } else if (resolved != null) {
                result.push(resolved);
              }
            }
          }
          return result;
        case 'if':
          // Handle addElse operation for if-else chains
          if (o.addElse != null) {
            [ifNode, elseBody] = o.addElse.map((item) => {
              return this.$(item);
            });
            // Ensure elseBody has location data
            if (elseBody && !elseBody.locationData && this.currentLocationData) {
              elseBody.locationData = this.currentLocationData;
            }
            ifNode.addElse(elseBody);
            return ifNode;
          }
          break;
        case 'value':
          // Handle adding accessors to Values
          if (o.add != null) {
            [value, accessor] = o.add.map((item) => {
              return this.$(item);
            });
            if (value instanceof this.ast.Value) {
              return value.add(accessor);
            } else {
              return this._toValue(value, [accessor]);
            }
          }
          break;
        case 'loop':
          // Handle different loop operations
          if (o.addSource != null) {
            // addSource: [1, 2] means ForStart is at position 1, ForSource at position 2
            [loopNode, sourceInfo] = o.addSource.map((item) => {
              return this.$(item);
            });
            if ((loopNode != null ? loopNode.addSource : void 0) != null) {
              loopNode.addSource(sourceInfo);
            }
            return loopNode;
          }
          if (o.addBody != null) {
            if ((ref1 = global.process) != null ? (ref2 = ref1.env) != null ? ref2.SOLAR_DEBUG : void 0 : void 0) {
              console.log("[Solar] loop.addBody operation:", o.addBody);
            }
            [loopNode, body] = o.addBody.map((item) => {
              return this.$(item);
            });
            body = this.ast.Block.wrap(body);
            if ((ref3 = global.process) != null ? (ref4 = ref3.env) != null ? ref4.SOLAR_DEBUG : void 0 : void 0) {
              util = require('util');
              console.log("[Solar] loop.addBody loopNode:", loopNode != null ? (ref5 = loopNode.constructor) != null ? ref5.name : void 0 : void 0);
              console.log("[Solar] loop.addBody body:", util.inspect(body, {
                depth: 2,
                colors: true
              }));
            }
            loopNode.addBody(body);
            if (o.postfix != null) {
              loopNode.postfix = this.$(o.postfix);
            }
            return loopNode;
          }
          break;
        case 'prop':
          // Handle property setting operations
          if (o.set != null) {
            target = this.$(o.set.target);
            property = o.set.property;
            value = this.$(o.set.value);
            if (target != null) {
              target[property] = value;
            }
            return target;
          }
      }
      // Catchall for any missing $ops directive handlers
      console.warn("Missing $ops directive handler:", o);
      return new this.ast.Literal(`# Missing $ops directive handler for: ${JSON.stringify(o)}`);
    }

    // Process $ast directives - the main AST node creation
    processAst(o) {
      var args, body, context, expression, expressions, forNode, ifNode, name, operator, options, ref, ref1, value, variable, whileNode;
      switch (o.$ast) {
        // === CORE EXPRESSIONS (Very High Frequency) ===

          // Values and property access - the most fundamental operations
        case 'Value':
          value = this._toValue(this.$(o.base), (ref = this.$(o.properties)) != null ? ref : []);
          if (o.this) {
            value.this = true;
          }
          return value;
        case 'IdentifierLiteral':
          return new this.ast.IdentifierLiteral(this.$(o.value));
        case 'Literal':
          return new this.ast.Literal(this.$(o.value));
        case 'NumberLiteral':
          return new this.ast.NumberLiteral(this.$(o.value), {
            parsedValue: this.$(o.parsedValue)
          });
        case 'StringLiteral':
          return new this.ast.StringLiteral(this.$(o.value), {
            quote: this.$(o.quote),
            initialChunk: this.$(o.initialChunk),
            finalChunk: this.$(o.finalChunk),
            indent: this.$(o.indent),
            double: this.$(o.double),
            heregex: this.$(o.heregex)
          });
        // Basic operations - assignments, calls, operators
        case 'Assign':
          variable = this.$(o.variable);
          value = this.$(o.value);
          context = this.$(o.context);
          if (context === 'object' && variable instanceof this.ast.Value && variable.base instanceof this.ast.ThisLiteral) {
            // Mark @-based object-context assignments as static (for class bodies)
            variable.this = true;
          }
          if (o.operator != null) {
            // Handle compound assignment (+=, -=, etc.)
            operator = this.$(o.operator);
          }
          if (operator && (operator !== '=' && operator !== '?=')) {
            value = new this.ast.Op(operator.slice(0, -1), variable, value);
          }
          if (operator === '?=') {
            context = operator;
          }
          options = o.operatorToken ? {
            operatorToken: this.$(o.operatorToken)
          } : {};
          if (o.moduleDeclaration != null) {
            options.moduleDeclaration = this.$(o.moduleDeclaration);
          }
          if (o.originalContext != null) {
            options.originalContext = this.$(o.originalContext);
          }
          return new this.ast.Assign(variable, value, context, options);
        case 'Call':
          return new this.ast.Call(this.$(o.variable), this.$(o.args) || [], this.$(o.soak));
        case 'Op':
          // Process args - preserve undefineds for proper positioning
          args = ((ref1 = o.args) != null ? ref1.map((arg) => {
            return this.$(arg);
          }) : void 0) || [];
          if ((o.invertOperator != null) || (o.originalOperator != null)) {
            options = {};
            if (o.invertOperator != null) {
              options.invertOperator = this.$(o.invertOperator);
            }
            if (o.originalOperator != null) {
              options.originalOperator = this.$(o.originalOperator);
            }
            args.push(options);
          }
          return new this.ast.Op(...args);
        // Property access patterns
        case 'Access':
          name = this.$(o.name);
          if (name instanceof this.ast.IdentifierLiteral) {
            name = new this.ast.PropertyName(name.value);
          }
          return new this.ast.Access(name, {
            soak: this.$(o.soak),
            shorthand: this.$(o.shorthand)
          });
        case 'Index':
          return new this.ast.Index(this.$(o.index));
        case 'PropertyName':
          return new this.ast.PropertyName(this.$(o.value));
        // === CONTROL FLOW & STRUCTURE (High Frequency) ===

          // Program structure
        case 'Block':
          expressions = this.$(o.expressions);
          return new this.ast.Block((expressions instanceof this.ast.Block ? expressions.expressions : expressions) || []);
        case 'Root':
          body = this.ast.Block.wrap(this.$(o.body));
          if (this.options.makeReturn) {
            body.makeReturn();
          }
          return new this.ast.Root(body);
        // Control flow statements
        case 'If':
          ifNode = new this.ast.If(this.$(o.condition), this.ast.Block.wrap(this.$(o.body)), {
            type: (this.$(o.invert) ? 'unless' : this.$(o.type)),
            postfix: this.$(o.postfix)
          });
          if (o.elseBody != null) {
            ifNode.addElse(this.ast.Block.wrap(this.$(o.elseBody)));
          }
          return ifNode;
        case 'While':
          whileNode = new this.ast.While(this.$(o.condition), {
            invert: this.$(o.invert),
            guard: this.$(o.guard),
            isLoop: this.$(o.isLoop)
          });
          whileNode.body = this.ast.Block.wrap(this.$(o.body));
          return whileNode;
        case 'For':
          body = this.ast.Block.wrap(this.$(o.body));
          forNode = new this.ast.For(body, {
            name: this.$(o.name),
            index: this.$(o.index),
            source: this.$(o.source)
          });
          if (o.await != null) {
            forNode.await = this.$(o.await);
          }
          if (o.awaitTag != null) {
            forNode.awaitTag = this.$(o.awaitTag);
          }
          if (o.own != null) {
            forNode.own = this.$(o.own);
          }
          if (o.ownTag != null) {
            forNode.ownTag = this.$(o.ownTag);
          }
          if (o.step != null) {
            forNode.step = this.$(o.step);
          }
          if (o.from != null) {
            forNode.from = this.$(o.from);
          }
          if (o.object != null) {
            forNode.object = this.$(o.object);
          }
          if (o.guard != null) {
            forNode.guard = this.$(o.guard);
          }
          return forNode;
        case 'Return':
          return new this.ast.Return(this.$(o.expression));
        // === FUNCTIONS & CLASSES (Medium-High Frequency) ===
        case 'Code':
          return new this.ast.Code(this.$(o.params) || [], this.ast.Block.wrap(this.$(o.body)), this.$(o.funcGlyph), this.$(o.paramStart));
        case 'FuncGlyph':
          return new this.ast.FuncGlyph(this.$(o.glyph) || this.$(o.value) || '->');
        case 'Class':
          return new this.ast.Class(this.$(o.variable), this.$(o.parent), this.$(o.body));
        case 'Param':
          name = this.$(o.name);
          if (name instanceof this.ast.Value && name.base instanceof this.ast.ThisLiteral) {
            name.this = true;
          }
          return new this.ast.Param(name, this.$(o.value), this.$(o.splat));
        // === DATA STRUCTURES (Medium Frequency) ===
        case 'Obj':
          return new this.ast.Obj(this.$(o.properties) || [], this.$(o.generated));
        case 'Arr':
          return new this.ast.Arr(this.$(o.objects) || []);
        case 'Range':
          return new this.ast.Range(this.$(o.from), this.$(o.to), this.$(o.exclusive) ? 'exclusive' : void 0);
        case 'Slice':
          return new this.ast.Slice(this.$(o.range));
        case 'Expansion':
          return new this.ast.Expansion(); // Rest/spread operator (...)
        
          // === COMMON LITERALS (Medium Frequency) ===
        case 'BooleanLiteral':
          return new this.ast.BooleanLiteral(this.$(o.value), {
            originalValue: this.$(o.originalValue)
          });
        case 'ThisLiteral':
          return new this.ast.ThisLiteral();
        case 'NullLiteral':
          return new this.ast.NullLiteral();
        case 'UndefinedLiteral':
          return new this.ast.UndefinedLiteral();
        case 'RegexLiteral':
          return new this.ast.RegexLiteral(this.$(o.value), {
            delimiter: this.$(o.delimiter),
            heregexCommentTokens: this.$(o.heregexCommentTokens)
          });
        case 'PassthroughLiteral':
          return new this.ast.PassthroughLiteral(this.$(o.value), {
            here: this.$(o.here),
            generated: this.$(o.generated)
          });
        case 'StatementLiteral':
          return new this.ast.StatementLiteral(this.$(o.value));
        case 'ComputedPropertyName':
          return new this.ast.ComputedPropertyName(this.$(o.expression) || this.$(o.name) || this.$(o.value));
        // === STRING INTERPOLATION (Low-Medium Frequency) ===
        case 'StringWithInterpolations':
          return new this.ast.StringWithInterpolations(this.ast.Block.wrap(this.$(o.body)));
        case 'Interpolation':
          expression = this.$(o.expression);
          if (expression != null) {
            return new this.ast.Interpolation(expression);
          } else {
            return new this.ast.EmptyInterpolation();
          }
          break;
        // === SPECIAL OPERATIONS (Low Frequency) ===

          // Switch statements
        case 'Switch':
          return new this.ast.Switch(this.$(o.subject), this.$(o.cases) || [], this.$(o.otherwise));
        case 'SwitchWhen':
          return new this.ast.SwitchWhen([].concat(this.$(o.conditions)), this.$(o.body));
        // Super calls
        case 'Super':
          return new this.ast.Super(this.$(o.accessor), this.$(o.superLiteral));
        case 'SuperCall':
          return new this.ast.SuperCall(this.$(o.variable), this.$(o.args) || [], this.$(o.soak));
        // Other operations
        case 'Existence':
          return new this.ast.Existence(this.$(o.expression));
        case 'Parens':
          return new this.ast.Parens(this.$(o.body));
        case 'Splat':
          return new this.ast.Splat(this.$(o.name), {
            postfix: this.$(o.postfix)
          });
        // === ERROR HANDLING (Low Frequency) ===
        case 'Try':
          return new this.ast.Try(this.$(o.attempt), this.$(o.catch), this.$(o.ensure), {
            finallyTag: this.$(o.finallyTag)
          });
        case 'Catch':
          return new this.ast.Catch(this.$(o.recovery) || this.$(o.body), this.$(o.variable) || this.$(o.errorVariable));
        case 'Throw':
          return new this.ast.Throw(this.$(o.expression));
        // === MODULES (Low Frequency) ===

          // Import statements
        case 'ImportDeclaration':
          return new this.ast.ImportDeclaration(this.$(o.clause), this.$(o.source));
        case 'ImportClause':
          return new this.ast.ImportClause(this.$(o.defaultBinding), this.$(o.namedImports));
        case 'ImportSpecifierList':
          return new this.ast.ImportSpecifierList(this.$(o.specifiers) || []);
        case 'ImportSpecifier':
          return new this.ast.ImportSpecifier(this.$(o.imported), this.$(o.local));
        case 'ImportDefaultSpecifier':
          return new this.ast.ImportDefaultSpecifier(this.$(o.name) || this.$(o.value) || this.$(o));
        case 'ImportNamespaceSpecifier':
          return new this.ast.ImportNamespaceSpecifier(this.$(o.star), this.$(o.local));
        // Export statements
        case 'ExportNamedDeclaration':
          return new this.ast.ExportNamedDeclaration(this.$(o.clause), this.$(o.source), this.$(o.assertions));
        case 'ExportDefaultDeclaration':
          return new this.ast.ExportDefaultDeclaration(this.$(o.declaration) || this.$(o.value));
        case 'ExportAllDeclaration':
          return new this.ast.ExportAllDeclaration(this.$(o.exported), this.$(o.source), this.$(o.assertions));
        case 'ExportSpecifierList':
          return new this.ast.ExportSpecifierList(this.$(o.specifiers) || []);
        case 'ExportSpecifier':
          return new this.ast.ExportSpecifier(this.$(o.value || o.local), this.$(o.exported));
        // === ADVANCED/RARE FEATURES (Very Low Frequency) ===

          // Advanced literals
        case 'InfinityLiteral':
          return new this.ast.InfinityLiteral();
        case 'NaNLiteral':
          return new this.ast.NaNLiteral();
        case 'DefaultLiteral':
          return new this.ast.DefaultLiteral(this.$(o.value) || 'default');
        // Advanced operations
        case 'YieldReturn':
          return new this.ast.YieldReturn(this.$(o.expression), {
            returnKeyword: this.$(o.returnKeyword)
          });
        case 'AwaitReturn':
          return new this.ast.AwaitReturn(this.$(o.expression), {
            returnKeyword: this.$(o.returnKeyword)
          });
        case 'DynamicImportCall':
          return new this.ast.DynamicImportCall(this.$(o.variable), this.$(o.args) || []);
        case 'DynamicImport':
          return new this.ast.DynamicImport();
        case 'TaggedTemplateCall':
          return new this.ast.TaggedTemplateCall(this.$(o.variable), this.$(o.template), this.$(o.soak));
        case 'MetaProperty':
          return new this.ast.MetaProperty(this.$(o.identifier), this.$(o.accessor));
        case 'RegexWithInterpolations':
          return new this.ast.RegexWithInterpolations(this.$(o.invocation), {
            heregexCommentTokens: this.$(o.heregexCommentTokens)
          });
        // Rare array operation
        case 'Elision':
          return new this.ast.Elision(); // Sparse array holes
        default:
          console.warn("Unknown $ast type:", o.$ast);
          return new this.ast.Literal(`# Missing AST node: ${o.$ast}`);
      }
    }

  };

  module.exports = Backend;

}).call(this);
